<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>简单复习下前端算法复杂度相关的知识 | duangdong的algorithm</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/logo.png">
    <link rel="manifest" href="/manifest.json">
    <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?0088ce24040b03f2947322ab31d23414";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
    <script>
  var _hmt = _hmt || [];
  _hmt.push(['_requirePlugin', 'UrlChangeTracker', {
    shouldTrackUrlChange: function (newPath, oldPath) {
      newPath = newPath.split('#')[0];
      oldPath = oldPath.split('#')[0];
      return newPath != oldPath;
    }}
  ]);
  </script>
    <meta name="description" content="前端相关知识归纳总结">
    <meta name="keywords" content="qd-blog,node,vuepress,leetcode,algorithm">
    
    <link rel="preload" href="/assets/css/0.styles.b4a844ec.css" as="style"><link rel="preload" href="/assets/js/app.950eebbc.js" as="script"><link rel="preload" href="/assets/js/2.57da4f88.js" as="script"><link rel="preload" href="/assets/js/1.a76cc220.js" as="script"><link rel="preload" href="/assets/js/28.e60083e4.js" as="script"><link rel="prefetch" href="/assets/js/10.50f73657.js"><link rel="prefetch" href="/assets/js/11.0390ceee.js"><link rel="prefetch" href="/assets/js/12.f88bec36.js"><link rel="prefetch" href="/assets/js/13.963ad03b.js"><link rel="prefetch" href="/assets/js/14.512f15b9.js"><link rel="prefetch" href="/assets/js/15.a674496c.js"><link rel="prefetch" href="/assets/js/16.ed7e507f.js"><link rel="prefetch" href="/assets/js/17.de667ca5.js"><link rel="prefetch" href="/assets/js/18.b44e84af.js"><link rel="prefetch" href="/assets/js/19.5b5ad6a1.js"><link rel="prefetch" href="/assets/js/20.6800493a.js"><link rel="prefetch" href="/assets/js/21.6589052c.js"><link rel="prefetch" href="/assets/js/22.f648d829.js"><link rel="prefetch" href="/assets/js/23.b85d0d4e.js"><link rel="prefetch" href="/assets/js/24.d81147fb.js"><link rel="prefetch" href="/assets/js/25.ed5233ca.js"><link rel="prefetch" href="/assets/js/26.83f1ef57.js"><link rel="prefetch" href="/assets/js/27.2565321e.js"><link rel="prefetch" href="/assets/js/29.49b5374e.js"><link rel="prefetch" href="/assets/js/3.13e892f5.js"><link rel="prefetch" href="/assets/js/30.9ad0e230.js"><link rel="prefetch" href="/assets/js/31.c97534c6.js"><link rel="prefetch" href="/assets/js/32.b90554dc.js"><link rel="prefetch" href="/assets/js/33.9d15b4c0.js"><link rel="prefetch" href="/assets/js/34.297b5f45.js"><link rel="prefetch" href="/assets/js/35.029c4cac.js"><link rel="prefetch" href="/assets/js/36.bc299146.js"><link rel="prefetch" href="/assets/js/37.9068edfd.js"><link rel="prefetch" href="/assets/js/38.8c781d87.js"><link rel="prefetch" href="/assets/js/39.87c06c9c.js"><link rel="prefetch" href="/assets/js/4.5bdb9365.js"><link rel="prefetch" href="/assets/js/40.b05763a5.js"><link rel="prefetch" href="/assets/js/41.447511bf.js"><link rel="prefetch" href="/assets/js/42.cef1f724.js"><link rel="prefetch" href="/assets/js/43.cae02230.js"><link rel="prefetch" href="/assets/js/44.833e4694.js"><link rel="prefetch" href="/assets/js/45.2933ab3e.js"><link rel="prefetch" href="/assets/js/46.1108fab7.js"><link rel="prefetch" href="/assets/js/47.1a5b2293.js"><link rel="prefetch" href="/assets/js/48.3f01058a.js"><link rel="prefetch" href="/assets/js/49.24929fd6.js"><link rel="prefetch" href="/assets/js/5.7c68fdb5.js"><link rel="prefetch" href="/assets/js/50.7e052a76.js"><link rel="prefetch" href="/assets/js/51.ae3eb599.js"><link rel="prefetch" href="/assets/js/52.bab65685.js"><link rel="prefetch" href="/assets/js/53.abacf47c.js"><link rel="prefetch" href="/assets/js/54.9d8ffddf.js"><link rel="prefetch" href="/assets/js/55.ac9707fe.js"><link rel="prefetch" href="/assets/js/56.9a9c42d4.js"><link rel="prefetch" href="/assets/js/57.f4d88e89.js"><link rel="prefetch" href="/assets/js/58.816a3870.js"><link rel="prefetch" href="/assets/js/59.8a6b3c7f.js"><link rel="prefetch" href="/assets/js/6.c8da7ca7.js"><link rel="prefetch" href="/assets/js/7.e4c88d0e.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.5143d2e0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b4a844ec.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">duangdong的algorithm</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/algorithm/" class="nav-link router-link-active">
  数据结构
</a></div><div class="nav-item"><a href="/leetcode/" class="nav-link">
  Leetcode
</a></div><div class="nav-item"><a href="/leetcode-summary/" class="nav-link">
  算法题
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/algorithm/" class="nav-link router-link-active">
  数据结构
</a></div><div class="nav-item"><a href="/leetcode/" class="nav-link">
  Leetcode
</a></div><div class="nav-item"><a href="/leetcode-summary/" class="nav-link">
  算法题
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/algorithm/" aria-current="page" class="sidebar-link">算法相关</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端实际项目使用</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/algorithm/动态规划.html" class="sidebar-link">前端也能学算法：由浅入深讲解动态规划</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>排序</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/algorithm/由浅入深讲解贪心算法.html" class="sidebar-link">前端也能学算法：由浅入深讲解贪心算法</a></li><li><a href="/algorithm/简单复习下前端算法复杂度相关的知识.html" class="active sidebar-link">简单复习下前端算法复杂度相关的知识</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>算法进阶</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/algorithm/贪心.html" class="sidebar-link">前端也能学算法：由浅入深讲解贪心算法</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="简单复习下前端算法复杂度相关的知识"><a href="#简单复习下前端算法复杂度相关的知识" class="header-anchor">#</a> 简单复习下前端算法复杂度相关的知识</h1> <blockquote><p><a href="https://mp.weixin.qq.com/s/TQpBj4D_2LaVKzTzXBiC7A" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/TQpBj4D_2LaVKzTzXBiC7A<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>从广义上讲</p> <blockquote><p>数据结构就是指<code>一组数据的存储结构</code>。</p> <p>算法就是<code>操作数据的一组方法</code>。</p></blockquote> <h2 id="从狭义上讲"><a href="#从狭义上讲" class="header-anchor">#</a> 从狭义上讲</h2> <p>是指某些著名的数据结构和算法，比如队列、栈、堆、二分查找、动态规划等</p> <h2 id="数据结构和算法关系"><a href="#数据结构和算法关系" class="header-anchor">#</a> 数据结构和算法关系</h2> <p>数据结构是为算法服务的，算法要作用在特定的数据结构之上</p> <blockquote><p>比如，因为数组具有随机访问的特点，常用的二分查找算法需要用数组来存储数据。但如果我们选择链表这种数据结构，二分查找算法就无法工作了，因为链表并不支持随机访问</p></blockquote> <h1 id="复杂度分析"><a href="#复杂度分析" class="header-anchor">#</a> 复杂度分析</h1> <h2 id="事后统计法的局限性"><a href="#事后统计法的局限性" class="header-anchor">#</a> 事后统计法的局限性</h2> <ol><li>测试结果非常依赖测试环境</li></ol> <p>测试环境中硬件的不同会对测试结果有很大的影响</p> <ol><li>测试结果受数据规模的影响很大</li></ol> <h3 id="对于小规模的数据排序-插入排序可能反倒会比快速排序要快"><a href="#对于小规模的数据排序-插入排序可能反倒会比快速排序要快" class="header-anchor">#</a> 对于小规模的数据排序，插入排序可能反倒会比快速排序要快</h3> <h2 id="大-o-复杂度表示法"><a href="#大-o-复杂度表示法" class="header-anchor">#</a> 大 O 复杂度表示法</h2> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code> int cal(int n) {   int sum = 0;   int i = 1;   int j = 1;   for (; i &lt;= n; ++i) {     j = 1;     for (; j &lt;= n; ++j) {       sum = sum +  i * j;     }   } }
</code></pre></div><p><img src="https://mmbiz.qpic.cn/mmbiz_png/KEXUm19zKo7cbqGKbHhKea4IjdwN9Fd2Hss7JUzXS0oJI5MAkor5fG5GGpIozw4KIkEziad2u9rhcV1Eicy94Wfg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <h3 id="公式"><a href="#公式" class="header-anchor">#</a> 公式：</h3> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/iclmxCdEUxyL0tIn2EOzAAFraeAofUPLzCyoopHPlEqJ4mYRvaEc6dIK5gHYtpAYc35tlf4U7yHjeF9flvrkFyQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <blockquote><p>上边例子可表示为T(n) = O(2n^2+2n+3)</p></blockquote> <p>大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是<code>表示代码执行时间随数据规模增长的变化趋势</code>，所以，也叫<code>作渐进时间复杂度</code>（asymptotic time complexity），简称<code>时间复杂度</code>。</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p><strong>常量级时间</strong></p> <p>即便这段代码循环 10000 次、100000 次，只要是一个已知的数，跟 n 无关，照样也是常量级的执行时间</p> <h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="header-anchor">#</a> 时间复杂度分析</h2> <h3 id="_1-只关注循环执行次数最多的一段代码"><a href="#_1-只关注循环执行次数最多的一段代码" class="header-anchor">#</a> 1. 只关注循环执行次数最多的一段代码</h3> <blockquote><p>忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了</p> <p>我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。这段核心代码执行次数的 n 的量级，就是整段要分析代码的时间复杂度。</p></blockquote> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code> int cal(int n) {   int sum = 0;   int i = 1;   for (; i &lt;= n; ++i) {     sum = sum + i;   }   return sum; }
</code></pre></div><ol><li>第 2、3 行代码都是常量级的执行时间，与 n 的大小无关，所以对于复杂度并没有影响。</li> <li>循环执行次数最多的是第 4、5 行代码，所以这块代码要重点分析。这两行代码被执行了 n 次，所以总的时间复杂度就是 <code>O(n)</code></li></ol> <h3 id="_2-加法法则-总复杂度等于量级最大的那段代码的复杂度"><a href="#_2-加法法则-总复杂度等于量级最大的那段代码的复杂度" class="header-anchor">#</a> 2. 加法法则：总复杂度等于量级最大的那段代码的复杂度</h3> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>int cal(int n) {   int sum_1 = 0;   int p = 1;   for (; p &lt; 100; ++p) {     sum_1 = sum_1 + p;   }
   int sum_2 = 0;   int q = 1;   for (; q &lt; n; ++q) {     sum_2 = sum_2 + q;   }    int sum_3 = 0;   int i = 1;   int j = 1;   for (; i &lt;= n; ++i) {     j = 1;      for (; j &lt;= n; ++j) {       sum_3 = sum_3 +  i * j;     }   }    return sum_1 + sum_2 + sum_3; }
</code></pre></div><p><img src="https://mmbiz.qpic.cn/mmbiz_png/KEXUm19zKo7cbqGKbHhKea4IjdwN9Fd2GRIy0oLBDfcqby1v1v6rcxiawjias1VO95yfGlFhOfBJWGOJmYRHaV6g/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <h3 id="_3-乘法法则-嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"><a href="#_3-乘法法则-嵌套代码的复杂度等于嵌套内外代码复杂度的乘积" class="header-anchor">#</a> 3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</h3> <p>落实到具体的代码上，我们可以把乘法法则看成是<code>嵌套循环</code></p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>int cal(int n) {   int ret = 0;    int i = 1;   for (; i &lt; n; ++i) {     ret = ret + f(i);   }  }   int f(int n) {  int sum = 0;  int i = 1;  for (; i &lt; n; ++i) {    sum = sum + i;  }   return sum; }
</code></pre></div><p><img src="https://mmbiz.qpic.cn/mmbiz_png/KEXUm19zKo7cbqGKbHhKea4IjdwN9Fd262pHnQuQqibg2ibXqnNSAEyhic2hYIteqb8rulabE1k9WYYYibibzc0Qsrw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p>几种常见时间复杂度实例分析</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/KEXUm19zKo7cbqGKbHhKea4IjdwN9Fd2tnl7AaC2kEYNnlXe2sjj2G0cfMpqmLsOnbeabJV6rDbzNfKQ7MibjHQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/iclmxCdEUxyL0tIn2EOzAAFraeAofUPLzH2plTVxicTaUxLBL7Wbp2Zg8qDXiboSt9BE3Q1m3xpiajibgvjR9triafrg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <h4 id="_1-o-1-常量级时间复杂度"><a href="#_1-o-1-常量级时间复杂度" class="header-anchor">#</a> 1. O(1)常量级时间复杂度</h4> <p>要代码的执行时间<code>不随 n 的增大而增长</code>，这样代码的时间复杂度我们都记作 <code>O(1)</code>。</p> <p>只要算法中<code>不存在</code><strong><code>循环语句</code></strong>、<strong><code>递归语句</code></strong>，即使有成千上万行的代码，其时间复杂度也是Ο(1)。</p> <h4 id="_2-o-logn-、o-nlogn-对数阶时间复杂度"><a href="#_2-o-logn-、o-nlogn-对数阶时间复杂度" class="header-anchor">#</a> 2. O(logn)、O(nlogn)对数阶时间复杂度</h4> <ul><li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>i=1; while (i &lt;= n)  {   i = i * 2; }
</code></pre></div><blockquote><p>变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时</p> <p>变量 i 的取值就是一个等比数列</p></blockquote> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/iclmxCdEUxyL0tIn2EOzAAFraeAofUPLz6ZS4He0FztBQxBOqFXiaJSTMREqqp6P7ibBvFPfkJib1YznT3MnljTCwg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/KEXUm19zKo7cbqGKbHhKea4IjdwN9Fd2TOCFicsoDz98V6IQrS3ngLIWx1FnAFuf8SpLN54nNphrxDy2utgUZvQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <h4 id="_3-o-m-n-、o-m-n-由两个数据的规模来决定"><a href="#_3-o-m-n-、o-m-n-由两个数据的规模来决定" class="header-anchor">#</a> 3. O(m+n)、O(m*n)由两个数据的规模来决定</h4> <div class="language- extra-class"><pre class="language-text"><code>int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i &lt; m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j &lt; n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}

复制代码
</code></pre></div><p>上面代码的时间复杂度就是 O(m+n)</p> <h2 id="空间复杂度分析-只计算与n有关的内存空间"><a href="#空间复杂度分析-只计算与n有关的内存空间" class="header-anchor">#</a> 空间复杂度分析（只计算与n有关的内存空间）</h2> <blockquote><p>空间复杂度全称就是<code>渐进空间复杂度</code>（asymptotic space complexity），<code>表示算法的存储空间与数据规模之间的增长关系</code></p> <p>常见的空间复杂度就是 <code>O(1)</code>、<code>O(n)</code>、<code>O(n2 )</code>，像 <code>O(logn)</code>、<code>O(nlogn)</code> 这样的对数阶复杂度平时都用不到</p></blockquote> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>void print(int n) {  int i = 0;  int[] a = new int[n];  for (i; i &lt;n; ++i) {    a[i] = i * i;  }
  for (i = n-1; i &gt;= 0; --i) {    print out a[i]  }}
</code></pre></div><p>第 2 行代码中，我们申请了一个空间存储变量 <code>i</code>，但是它是<code>常量阶的</code>，跟数据规模 <code>n 没有关系</code>，所以我们可以<code>忽略</code>。</p> <p>第 3 行申请了一个大小为 <code>n 的 int 类型数组</code>，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 <code>O(n)</code>。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <div class="language- extra-class"><pre class="language-text"><code>复杂度`也叫`渐进复杂度`，包括`时间复杂度`和`空间复杂度`，用来分析`算法执行效率`与`数据规模`之间的增长关系，可以粗略地表示，`越高阶复杂度的算法，执行效率越低
</code></pre></div><p><img src="https://mmbiz.qpic.cn/mmbiz_png/iclmxCdEUxyL0tIn2EOzAAFraeAofUPLzxLno7YpZWib34FHrtuQJbUotibucvic5iafqHk8CibdI6O34LsOD5ok8obQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <h1 id="浅析最好、最坏、平均、均摊时间复杂度"><a href="#浅析最好、最坏、平均、均摊时间复杂度" class="header-anchor">#</a> 浅析最好、最坏、平均、均摊时间复杂度</h1> <h2 id="最好、最坏情况时间复杂度"><a href="#最好、最坏情况时间复杂度" class="header-anchor">#</a> 最好、最坏情况时间复杂度</h2> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>// n表示数组array的长度int find(int[] array, int n, int x) {  int i = 0;  int pos = -1;  for (; i &lt; n; ++i) {    if (array[i] == x) pos = i;  }  return pos;}
</code></pre></div><p>上面 这段代码的复杂度是 O(n)，其中，n 代表数组的长度</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>int find(int[] array, int n, int x) {  int i = 0;  int pos = -1;  for (; i &lt; n; ++i) {    if (array[i] == x) {       pos = i;       break;  //加入了break    }  }  return pos;}
</code></pre></div><blockquote><p>上边的代码 如果数组中第一个元素正好是要查找的变量 x，那就不需要继续遍历剩下的 n-1 个数据了，那时间复杂度就是 O(1)。</p> <p>但如果数组中不存在变量 x，那我们就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)。所以，不同的情况下，这段代码的时间复杂度是不一样的。</p></blockquote> <h3 id="最好情况时间复杂度就是-在最理想的情况下-执行这段代码的时间复杂度"><a href="#最好情况时间复杂度就是-在最理想的情况下-执行这段代码的时间复杂度" class="header-anchor">#</a> 最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度</h3> <h3 id="最坏情况时间复杂度就是-在最糟糕的情况下-执行这段代码的时间复杂度"><a href="#最坏情况时间复杂度就是-在最糟糕的情况下-执行这段代码的时间复杂度" class="header-anchor">#</a> 最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度</h3> <h2 id="平均情况时间复杂度"><a href="#平均情况时间复杂度" class="header-anchor">#</a> 平均情况时间复杂度</h2> <div class="language- extra-class"><pre class="language-text"><code>// n表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i &lt; n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;  //加入了break
    }
  }
  return pos;
}
</code></pre></div><p>假设<code>在数组中</code>与<code>不在数组中</code>的概率都为 <code>1/2</code>。</p> <p>另外，要查找的数据出现在 <code>0～n-1</code> 这 <code>n</code> 个位置的概率也是一样的，为 <code>1/n</code>。</p> <p>所以，根据概率乘法法则，要查找的数据出现在 <code>0～n-1</code> 中任意位置的概率就是 <code>1/(2n)</code></p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/iclmxCdEUxyL0tIn2EOzAAFraeAofUPLz0x5SRoQFhAVibAu1sS1Lv4eMzhw9ebhyHZmYEbibeGAgPEJIhBu6iaIug/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p>这个值就是<code>概率论</code>中的<code>加权平均值</code>，也叫作<code>期望值</code>，</p> <p>所以<code>平均时间复杂度</code>的全称应该叫<code>加权平均时间复杂度</code>或者<code>期望时间复杂度</code>。</p> <p>用大 O 表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是 <code>O(n)</code>。</p> <blockquote><p>大多数情况下，我们并不需要区分最好、最坏、平均情况时间复杂度三种情况</p> <p>只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分</p></blockquote> <h2 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="header-anchor">#</a> 均摊时间复杂度</h2> <blockquote><p>摊还分析法，通过摊还分析得到的时间复杂度我们起了一个名字，叫均摊时间复杂度。</p></blockquote> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code> // array表示一个长度为n的数组 // 代码中的array.length就等于n int[] array = new int[n]; int count = 0;  void insert(int val) {    if (count == array.length) {       int sum = 0;       for (int i = 0; i &lt; array.length; ++i) {          sum = sum + array[i];       }       array[0] = sum;       count = 1;    }
    array[count] = val;    ++count; }
</code></pre></div><p>这段代码实现了一个往数组中插入数据的功能。</p> <p>当数组满了之后，也就是代码中的 count == array.length 时，我们用 for 循环遍历数组求和，并清空数组，将求和之后的 sum 值放到数组的第一个位置</p> <p>然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组</p> <div class="language- extra-class"><pre class="language-text"><code>最理想的情况下`，数组中有空闲空间，我们只需要将数据插入到数组下标为 count 的位置就可以了，所以最好情况时间复杂度为 `O(1)
</code></pre></div><p><code>最坏的情况下</code>，数组中没有空闲空间了，我们需要先做一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为 O(n)</p> <p><code>平均时间复杂度</code>是O(1): 假设数组的长度是 n，根据数据插入的位置的不同，我们可以分为 n 种情况，每种情况的时间复杂度是 O(1)。除此之外，还有一种“额外”的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是 O(n)。而且，这 n+1 种情况发生的概率一样，都是 1/(n+1)。所以，根据加权平均的计算方法，我们求得的平均时间复杂度就是：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>O(n) 的插入操作 就是 <code>最坏的情况下</code> 求和清空插入 O(1) 的插入操作 就是 <code>最理想的情况下</code> 直接插入</p> <p>每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)，这就是均摊分析的大致思路</p> <blockquote><p>在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。</p></blockquote> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 全局变量，大小为10的数组array，长度len，下标i。int array[] = new int[10]; int len = 10;int i = 0;
// 往数组中添加一个元素void add(int element) {   if (i &gt;= len) { // 数组空间不够了     // 重新申请一个2倍大小的数组空间     int new_array[] = new int[len*2];     // 把原来array数组中的数据依次copy到new_array     for (int j = 0; j &lt; len; ++j) {       new_array[j] = array[j];     }     // new_array复制给array，array现在大小就是2倍len了     array = new_array;     len = 2 * len;   }   // 将element放到下标为i的位置，下标i加一   array[i] = element;   ++i;}
</code></pre></div><blockquote><p>转自：https://juejin.cn/post/7001810638703951902</p></blockquote></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">5/8/2024, 3:01:19 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/algorithm/由浅入深讲解贪心算法.html" class="prev">
        前端也能学算法：由浅入深讲解贪心算法
      </a></span> <span class="next"><a href="/algorithm/算法进阶/ChromeV8源码看JavaScript数组.html">
        前端进阶算法2：从Chrome V8源码看JavaScript数组(附赠腾讯面试题)
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.950eebbc.js" defer></script><script src="/assets/js/2.57da4f88.js" defer></script><script src="/assets/js/1.a76cc220.js" defer></script><script src="/assets/js/28.e60083e4.js" defer></script>
  </body>
</html>
