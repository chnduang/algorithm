<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>10 问 10 答，带你快速入门前端算法 | duangdong的algorithm</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/logo.png">
    <link rel="manifest" href="/manifest.json">
    <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?0088ce24040b03f2947322ab31d23414";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
    <script>
  var _hmt = _hmt || [];
  _hmt.push(['_requirePlugin', 'UrlChangeTracker', {
    shouldTrackUrlChange: function (newPath, oldPath) {
      newPath = newPath.split('#')[0];
      oldPath = oldPath.split('#')[0];
      return newPath != oldPath;
    }}
  ]);
  </script>
    <meta name="description" content="前端相关知识归纳总结">
    <meta name="keywords" content="qd-blog,node,vuepress,leetcode,algorithm">
    
    <link rel="preload" href="/assets/css/0.styles.b4a844ec.css" as="style"><link rel="preload" href="/assets/js/app.950eebbc.js" as="script"><link rel="preload" href="/assets/js/2.57da4f88.js" as="script"><link rel="preload" href="/assets/js/1.a76cc220.js" as="script"><link rel="preload" href="/assets/js/42.cef1f724.js" as="script"><link rel="prefetch" href="/assets/js/10.50f73657.js"><link rel="prefetch" href="/assets/js/11.0390ceee.js"><link rel="prefetch" href="/assets/js/12.f88bec36.js"><link rel="prefetch" href="/assets/js/13.963ad03b.js"><link rel="prefetch" href="/assets/js/14.512f15b9.js"><link rel="prefetch" href="/assets/js/15.a674496c.js"><link rel="prefetch" href="/assets/js/16.ed7e507f.js"><link rel="prefetch" href="/assets/js/17.de667ca5.js"><link rel="prefetch" href="/assets/js/18.b44e84af.js"><link rel="prefetch" href="/assets/js/19.5b5ad6a1.js"><link rel="prefetch" href="/assets/js/20.6800493a.js"><link rel="prefetch" href="/assets/js/21.6589052c.js"><link rel="prefetch" href="/assets/js/22.f648d829.js"><link rel="prefetch" href="/assets/js/23.b85d0d4e.js"><link rel="prefetch" href="/assets/js/24.d81147fb.js"><link rel="prefetch" href="/assets/js/25.ed5233ca.js"><link rel="prefetch" href="/assets/js/26.83f1ef57.js"><link rel="prefetch" href="/assets/js/27.2565321e.js"><link rel="prefetch" href="/assets/js/28.e60083e4.js"><link rel="prefetch" href="/assets/js/29.49b5374e.js"><link rel="prefetch" href="/assets/js/3.13e892f5.js"><link rel="prefetch" href="/assets/js/30.9ad0e230.js"><link rel="prefetch" href="/assets/js/31.c97534c6.js"><link rel="prefetch" href="/assets/js/32.b90554dc.js"><link rel="prefetch" href="/assets/js/33.9d15b4c0.js"><link rel="prefetch" href="/assets/js/34.297b5f45.js"><link rel="prefetch" href="/assets/js/35.029c4cac.js"><link rel="prefetch" href="/assets/js/36.bc299146.js"><link rel="prefetch" href="/assets/js/37.9068edfd.js"><link rel="prefetch" href="/assets/js/38.8c781d87.js"><link rel="prefetch" href="/assets/js/39.87c06c9c.js"><link rel="prefetch" href="/assets/js/4.5bdb9365.js"><link rel="prefetch" href="/assets/js/40.b05763a5.js"><link rel="prefetch" href="/assets/js/41.447511bf.js"><link rel="prefetch" href="/assets/js/43.cae02230.js"><link rel="prefetch" href="/assets/js/44.833e4694.js"><link rel="prefetch" href="/assets/js/45.2933ab3e.js"><link rel="prefetch" href="/assets/js/46.1108fab7.js"><link rel="prefetch" href="/assets/js/47.1a5b2293.js"><link rel="prefetch" href="/assets/js/48.3f01058a.js"><link rel="prefetch" href="/assets/js/49.24929fd6.js"><link rel="prefetch" href="/assets/js/5.7c68fdb5.js"><link rel="prefetch" href="/assets/js/50.7e052a76.js"><link rel="prefetch" href="/assets/js/51.ae3eb599.js"><link rel="prefetch" href="/assets/js/52.bab65685.js"><link rel="prefetch" href="/assets/js/53.abacf47c.js"><link rel="prefetch" href="/assets/js/54.9d8ffddf.js"><link rel="prefetch" href="/assets/js/55.ac9707fe.js"><link rel="prefetch" href="/assets/js/56.9a9c42d4.js"><link rel="prefetch" href="/assets/js/57.f4d88e89.js"><link rel="prefetch" href="/assets/js/58.816a3870.js"><link rel="prefetch" href="/assets/js/59.8a6b3c7f.js"><link rel="prefetch" href="/assets/js/6.c8da7ca7.js"><link rel="prefetch" href="/assets/js/7.e4c88d0e.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.5143d2e0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b4a844ec.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">duangdong的algorithm</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/algorithm/" class="nav-link router-link-active">
  数据结构
</a></div><div class="nav-item"><a href="/leetcode/" class="nav-link">
  Leetcode
</a></div><div class="nav-item"><a href="/leetcode-summary/" class="nav-link">
  算法题
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/algorithm/" class="nav-link router-link-active">
  数据结构
</a></div><div class="nav-item"><a href="/leetcode/" class="nav-link">
  Leetcode
</a></div><div class="nav-item"><a href="/leetcode-summary/" class="nav-link">
  算法题
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/algorithm/" aria-current="page" class="sidebar-link">算法相关</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端实际项目使用</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/algorithm/动态规划.html" class="sidebar-link">前端也能学算法：由浅入深讲解动态规划</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>排序</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/algorithm/由浅入深讲解贪心算法.html" class="sidebar-link">前端也能学算法：由浅入深讲解贪心算法</a></li><li><a href="/algorithm/简单复习下前端算法复杂度相关的知识.html" class="sidebar-link">简单复习下前端算法复杂度相关的知识</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>算法进阶</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/algorithm/算法进阶/ChromeV8源码看JavaScript数组.html" class="sidebar-link">前端进阶算法2：从Chrome V8源码看JavaScript数组(附赠腾讯面试题)</a></li><li><a href="/algorithm/算法进阶/DIff算法看不懂就一起来锤我.html" class="sidebar-link">DIff算法看不懂就一起来锤我</a></li><li><a href="/algorithm/算法进阶/Diff算法核心原理.html" class="sidebar-link">15张图，20分钟吃透Diff算法核心原理</a></li><li><a href="/algorithm/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6/" aria-current="page" class="sidebar-link">算法进阶</a></li><li><a href="/algorithm/算法进阶/一看就懂的队列及配套算法题.html" class="sidebar-link">前端进阶算法6：一看就懂的队列及配套算法题</a></li><li><a href="/algorithm/算法进阶/从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法.html" class="sidebar-link">前端进阶算法3：从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法</a></li><li><a href="/algorithm/算法进阶/别再说你不懂Top-K问题了.html" class="sidebar-link">别再说你不懂Top K问题了</a></li><li><a href="/algorithm/算法进阶/去大厂面试问我算法.html" class="sidebar-link">去大厂面试问我算法，我该怎么办？</a></li><li><a href="/algorithm/算法进阶/吊打面试官之数据结构栈.html" class="sidebar-link">前端进阶算法5：吊打面试官之数据结构栈（+leetcode刷题）</a></li><li><a href="/algorithm/算法进阶/堆排序.html" class="sidebar-link">前端进阶算法：看完这篇，再也不怕堆排序、Top K、中位数问题面试了</a></li><li><a href="/algorithm/算法进阶/头条正在面的哈希表问题.html" class="sidebar-link">前端进阶算法：头条正在面的哈希表问题</a></li><li><a href="/algorithm/算法进阶/如何分析-统计算法的执行效率和资源消耗.html" class="sidebar-link">前端进阶算法1：如何分析、统计算法的执行效率和资源消耗？</a></li><li><a href="/algorithm/算法进阶/小白都可以看懂的树与二叉树.html" class="sidebar-link">前端进阶算法7：小白都可以看懂的树与二叉树</a></li><li><a href="/algorithm/算法进阶/带你快速入门前端算法.html" class="active sidebar-link">10 问 10 答，带你快速入门前端算法</a></li><li><a href="/algorithm/算法进阶/常见算法题及完美题解.html" class="sidebar-link">前端进阶算法：常见算法题及完美题解</a></li><li><a href="/algorithm/算法进阶/链表原来如此简单.html" class="sidebar-link">前端进阶算法4：链表原来如此简单(+leetcode刷题）</a></li></ul></section></li><li><a href="/algorithm/贪心.html" class="sidebar-link">前端也能学算法：由浅入深讲解贪心算法</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_10-问-10-答-带你快速入门前端算法"><a href="#_10-问-10-答-带你快速入门前端算法" class="header-anchor">#</a> 10 问 10 答，带你快速入门前端算法</h1> <p>原创 前端瓶子君 前端瓶子君 <em>2020-04-11</em></p> <h3 id="引言"><a href="#引言" class="header-anchor">#</a> 引言</h3> <p>各位大佬好，本节是前端进阶算法集训营半月的总结与回顾👇，主要内容包括：</p> <ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247484204&amp;idx=1&amp;sn=3433b9191b67ac9b09452b0d6e3a0639&amp;chksm=faec87f4cd9b0ee213f03f451069f4c5fd352cf0c573d043c1819760ef1085a4457af99605a8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">前端进阶算法1：如何分析、统计算法的执行效率和资源消耗？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247484213&amp;idx=1&amp;sn=6b7b9cd11b7a151b1b5396c918d7692f&amp;chksm=faec87edcd9b0efb118b006b13b3df234aa3c8a5aa5bcd168cdf07ee3990fee28a5f039baa0f&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">前端进阶算法2：从Chrome V8源码看JavaScript数组(附赠腾讯面试题)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247484265&amp;idx=1&amp;sn=7feafe63a80ce6371a1b6834884a6d05&amp;chksm=faec87b1cd9b0ea7ea773e24341918cefa1df7ccbc2c12c0fee679fcf62d2603f86351f732d1&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">前端进阶算法3：从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247484292&amp;idx=1&amp;sn=c2dfcccab0ed82267061340f969d5de2&amp;chksm=faec875ccd9b0e4a4b1b015785bd439c9ec37ca6882e9b18f66c523e03110e29f1b6d4c57f62&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">前端进阶算法4：链表原来如此简单(+leetcode刷题）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <p>以及题目：</p> <ul><li><strong>图解leetcode88：合并两个有序数组</strong>[1]</li> <li><strong>字节&amp;leetcode1：两数之和</strong>[2]</li> <li><strong>腾讯：数组扁平化、去重、排序</strong>[3]</li> <li><strong>leetcode349：给定两个数组，编写一个函数来计算它们的交集</strong>[4]</li> <li><strong>leetcode146：设计和实现一个LRU（最近最少使用）缓存机制</strong>[5]</li> <li><strong>阿里算法题：编写一个函数计算多个数组的交集</strong>[6]</li> <li><strong>leetcode21：合并两个有序链表</strong>[7]</li> <li><strong>有赞&amp;leetcode141：判断一个单链表是否有环</strong>[8]</li> <li><strong>图解leetcode206：反转链表</strong>[9]</li></ul> <p>下面进入正文吧👇</p> <h3 id="一、前端进阶算法1-如何分析、统计算法的执行效率和资源消耗"><a href="#一、前端进阶算法1-如何分析、统计算法的执行效率和资源消耗" class="header-anchor">#</a> 一、前端进阶算法1：如何分析、统计算法的执行效率和资源消耗？</h3> <p>好的数据结构与算法能够大大缩短代码的执行时间与存储空间，那么我们如何去衡量它喃？这节就主要介绍算法性能的衡量指标—复杂度分析。</p> <p>复杂度可分为：</p> <ul><li>时间复杂度</li> <li>空间复杂度</li></ul> <h4 id="_1-如何表示算法复杂度"><a href="#_1-如何表示算法复杂度" class="header-anchor">#</a> 1. 如何表示算法复杂度？</h4> <p>通常采用 <strong>大 O 表示法</strong> 来表示复杂度。它并不代表真正的执行时间或存储空间消耗，而是表示代码执行时间随数据规模增长的变化趋势（时间复杂度）或存储空间随数据规模增长的变化趋势（空间复杂度），所以，也叫作<strong>渐进时间（或空间）复杂度（asymptotic time complexity）</strong>，简称<strong>时间（或空间）复杂度</strong>。</p> <h4 id="_2-常见复杂度"><a href="#_2-常见复杂度" class="header-anchor">#</a> 2. 常见复杂度</h4> <p><strong>多项式量级：</strong></p> <ul><li>常量阶：O(1)：当算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)</li> <li>对数阶：O(logn): 简单介绍一下</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let i=1;
while (i &lt;= n)  {
  i = i * 2;
}
</code></pre></div><ul><li>每次循环 <code>i</code> 都乘以 <code>2</code> ，直至 <code>i &gt; n</code> ，即执行过程是：20、21、22、…、2k、…、2x、 n 所以总执行次数 x ，可以写成 2x = n ，则时间复杂度为 O(log2n) 。这里是 <code>2</code> ，也可以是其他常量 <code>k</code> ，时间复杂度也是：O(log~3~n) = O(log32 * log2n) = O(log2n)</li> <li>线性阶：O(n)</li> <li>线性对数阶：O(nlogn)</li> <li>平方阶、立方阶、….、k次方阶：O(n2)、O(n3)、…、O(nk)</li></ul> <p><strong>非多项式量阶：</strong></p> <ul><li>指数阶：O(2n)</li> <li>阶乘阶：O(n!)</li></ul> <h4 id="_3-复杂度的划分"><a href="#_3-复杂度的划分" class="header-anchor">#</a> 3. 复杂度的划分</h4> <p>以时间复杂度为例，时间复杂度受数据本身影响，还分为：</p> <ul><li>最好时间复杂度：在最理想的情况下，执行这段代码的时间复杂度</li> <li>最坏时间复杂度：在最糟糕的情况下，执行这段代码的时间复杂度</li> <li>平均时间复杂度：所有情况下，求一个平均值，可以省略掉系数、低阶、常量</li></ul> <p>详情：<strong>前端进阶算法1：如何分析、统计算法的执行效率和资源消耗？</strong>[10]</p> <h3 id="二、前端进阶算法2-从chrome-v8源码看javascript数组-附赠腾讯面试题"><a href="#二、前端进阶算法2-从chrome-v8源码看javascript数组-附赠腾讯面试题" class="header-anchor">#</a> 二、前端进阶算法2：从Chrome V8源码看JavaScript数组（附赠腾讯面试题）</h3> <h4 id="_1-javascript-中-数组的应用"><a href="#_1-javascript-中-数组的应用" class="header-anchor">#</a> 1. JavaScript 中，数组的应用</h4> <div class="language- extra-class"><pre class="language-text"><code>let arr = [1, 2, 3]
</code></pre></div><p>它的这种特定的存储结构决定了：</p> <p><strong>优点</strong></p> <ul><li>随机访问：可以通过下标随机访问数组中的任意位置上的数据</li></ul> <p><strong>缺点</strong></p> <ul><li>对数据的删除和插入不是很友好</li></ul> <p><strong>查找：</strong> 根据下标随机访问的时间复杂度为 O(1)；</p> <p><strong>插入或删除：</strong> 时间复杂度为 O(n)；</p> <p>在 JavaScript 中的数组几乎是万能的，它不光可以作为一个普通的数组使用，可以作为栈或队列使用。</p> <p>数组：</p> <div class="language- extra-class"><pre class="language-text"><code>let array = [1, 2, 3]
</code></pre></div><p>栈：</p> <div class="language- extra-class"><pre class="language-text"><code>let stack = [1, 2, 3]
// 进栈
stack.push(4)
// 出栈
stcak.pop()
</code></pre></div><p>队列：</p> <div class="language- extra-class"><pre class="language-text"><code>let queue = [1, 2, 3]
// 进队
queue.push(4)
// 出队
queue.shift()
</code></pre></div><h4 id="_2-javascript-中-数组的独特之处"><a href="#_2-javascript-中-数组的独特之处" class="header-anchor">#</a> 2. JavaScript 中，数组的独特之处</h4> <blockquote><p>我们知道在 JavaScript 中，可以在数组中保存不同类型值，并且数组可以动态增长，不像其它语言，例如 C，创建的时候要决定数组的大小，如果数组满了，就要重新申请内存空间。这是为什么喃？</p></blockquote> <p>JavaScript 中， <code>JSArray</code> 继承自 <code>JSObject</code> ，或者说它就是一个特殊的对象，内部是以 key-value 形式存储数据，所以 JavaScript 中的数组可以存放不同类型的值。它有两种存储方式，快数组与慢数组，初始化空数组时，使用快数组，快数组使用连续的内存空间，当数组长度达到最大时，<code>JSArray</code> 会进行动态的扩容，以存储更多的元素，相对慢数组，性能要好得多。当数组中 <code>hole</code> 太多时，会转变成慢数组，即以哈希表的方式（ key-value 的形式）存储数据，以节省内存空间。</p> <p>具体快慢数组、动态扩容前往：<strong>前端进阶算法2：从Chrome V8源码看JavaScript数组（附赠腾讯面试题）</strong>[11]</p> <h3 id="三、前端进阶算法3-从浏览器缓存淘汰策略和vue的keep-alive学习lru算法"><a href="#三、前端进阶算法3-从浏览器缓存淘汰策略和vue的keep-alive学习lru算法" class="header-anchor">#</a> 三、前端进阶算法3：从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法</h3> <h4 id="_1-浏览器缓存淘汰策略"><a href="#_1-浏览器缓存淘汰策略" class="header-anchor">#</a> 1. 浏览器缓存淘汰策略</h4> <p>当我们打开一个网页时，例如 <code>https://github.com/sisterAn/JavaScript-Algorithms</code> ，它会在发起真正的网络请求前，查询浏览器缓存，看是否有要请求的文件，如果有，浏览器将会拦截请求，返回缓存文件，并直接结束请求，不会再去服务器上下载。如果不存在，才会去服务器请求。</p> <p>其实，浏览器中的缓存是一种在本地保存资源副本，它的大小是有限的，当我们请求数过多时，缓存空间会被用满，此时，继续进行网络请求就需要确定缓存中哪些数据被保留，哪些数据被移除，这就是<strong>浏览器缓存淘汰策略</strong>，最常见的淘汰策略有 FIFO（先进先出）、LFU（最少使用）、LRU（最近最少使用）。</p> <p>LRU （ <code>Least Recently Used</code> ：最近最少使用 ）缓存淘汰策略，故名思义，就是根据数据的历史访问记录来进行淘汰数据，其核心思想是 <strong>如果数据最近被访问过，那么将来被访问的几率也更高</strong> ，优先淘汰最近没有被访问到的数据。</p> <p>画个图帮助我们理解 LRU：</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQ3WsOP2syTPC4uAkQaScm1vaibj2l4F1OW4AiaEyTAaWq0yN9icXgR4twutq8J1ThxuTrQxfeDgm3IA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <h4 id="_2-vue-的-keep-alive-源码解读"><a href="#_2-vue-的-keep-alive-源码解读" class="header-anchor">#</a> 2. Vue 的 keep-alive 源码解读</h4> <p>在 <code>keep-alive</code> 缓存超过 <code>max</code> 时，使用的缓存淘汰算法就是 LRU 算法，它在实现的过程中用到了 <code>cache</code> 对象用于保存缓存的组件实例及 <code>key</code> 值，<code>keys</code> 数组用于保存缓存组件的 <code>key</code>，当 <code>keep-alive</code> 中渲染一个需要缓存的实例时：</p> <ul><li>判断缓存中是否已缓存了该实例，缓存了则直接获取，并调整 <code>key</code> 在 <code>keys</code> 中的位置（移除 <code>keys</code> 中 <code>key</code> ，并放入 <code>keys</code> 数组的最后一位）</li> <li>如果没有缓存，则缓存该实例，若 <code>keys</code> 的长度大于 <code>max</code> （缓存长度超过上限），则移除 <code>keys[0]</code> 缓存</li></ul> <p>主要实现LRU代码：</p> <div class="language- extra-class"><pre class="language-text"><code>// --------------------------------------------------
// 下面就是 LRU 算法了，
// 如果在缓存里有则调整，
// 没有则放入（长度超过 max，则淘汰最近没有访问的）
// --------------------------------------------------
// 如果命中缓存，则从缓存中获取 vnode 的组件实例，
// 并且调整 key 的顺序放入 keys 数组的末尾
if (cache[key]) {
  vnode.componentInstance = cache[key].componentInstance;
  // make current key freshest
  remove(keys, key);
  keys.push(key);
}
// 如果没有命中缓存,就把 vnode 放进缓存
else {
  cache[key] = vnode;
  keys.push(key);
  // prune oldest entry
  // 如果配置了 max 并且缓存的长度超过了 this.max，还要从缓存中删除第一个
  if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) {
    pruneCacheEntry(cache, keys[0], keys, this._vnode);
  }
}
</code></pre></div><p>源码详情：<strong>前端进阶算法3：从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法</strong>[12]</p> <h3 id="四、前端进阶算法4-链表原来如此简单-leetcode刷题"><a href="#四、前端进阶算法4-链表原来如此简单-leetcode刷题" class="header-anchor">#</a> 四、前端进阶算法4：链表原来如此简单（+leetcode刷题）</h3> <h4 id="_1-图解链表"><a href="#_1-图解链表" class="header-anchor">#</a> 1. 图解链表</h4> <p>常用的链表类型有单链表、双链表以及循环链表，其中 <code>next</code> 为后继指针，指向它的后继节点，<code>prev</code> 为前驱指针，指向它的前驱节点。</p> <p><strong>单链表</strong></p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQ3WsOP2syTPC4uAkQaScm1FFt3MOlGW5Uia2GnF906dJmsBq6DFXk6ibicSmTMdGz9DbQVZ9X6yIDAA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p><strong>双链表</strong></p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQ3WsOP2syTPC4uAkQaScm1kJaibq1enTywseChcGXhBIibZMibMSkC0rCts2Wgo38F1SPica8via0GgLQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p><strong>循环链表</strong></p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQ3WsOP2syTPC4uAkQaScm1dlKquJjOHVVVZ9yJWtN23gYiaeTib3m8ZLnP4ObMlMdd9IQpBN9M0tng/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <h4 id="_2-链表复杂度一览表"><a href="#_2-链表复杂度一览表" class="header-anchor">#</a> 2. 链表复杂度一览表</h4> <p><strong>单链表</strong></p> <table><thead><tr><th style="text-align:center;">操作方法</th> <th style="text-align:center;">时间复杂度</th> <th style="text-align:center;">说明</th></tr></thead> <tbody><tr><td style="text-align:center;">append</td> <td style="text-align:center;">O(n)</td> <td style="text-align:center;">在链表尾部追加节点</td></tr> <tr><td style="text-align:center;">search</td> <td style="text-align:center;">O(n)</td> <td style="text-align:center;">在链表中查找任意元素</td></tr> <tr><td style="text-align:center;">insert</td> <td style="text-align:center;">O(n)</td> <td style="text-align:center;">在链表中任意位置插入一个节点</td></tr> <tr><td style="text-align:center;">remove</td> <td style="text-align:center;">O(n)</td> <td style="text-align:center;">删除链表中任意位置的一个节点</td></tr> <tr><td style="text-align:center;">searchNext</td> <td style="text-align:center;">O(1)</td> <td style="text-align:center;">查找某节点的后继节点</td></tr> <tr><td style="text-align:center;">insertNext</td> <td style="text-align:center;">O(1)</td> <td style="text-align:center;">在某一节点后插入一个节点（后继节点）</td></tr> <tr><td style="text-align:center;">removeNext</td> <td style="text-align:center;">O(1)</td> <td style="text-align:center;">在某一节点后删除一个节点（后继节点）</td></tr></tbody></table> <p><strong>双链表</strong></p> <table><thead><tr><th style="text-align:center;">操作方法</th> <th style="text-align:center;">时间复杂度</th> <th style="text-align:center;">说明</th></tr></thead> <tbody><tr><td style="text-align:center;">search</td> <td style="text-align:center;">O(n)</td> <td style="text-align:center;">在链表中查找任意元素</td></tr> <tr><td style="text-align:center;">insert</td> <td style="text-align:center;">O(n)</td> <td style="text-align:center;">在链表中任意位置插入一个节点</td></tr> <tr><td style="text-align:center;">remove</td> <td style="text-align:center;">O(n)</td> <td style="text-align:center;">删除链表中任意位置的一个节点</td></tr> <tr><td style="text-align:center;">searchNext 或 searchPre</td> <td style="text-align:center;">O(1)</td> <td style="text-align:center;">查找某节点的后继节点或前驱节点</td></tr> <tr><td style="text-align:center;">insertNext 或 insertPre</td> <td style="text-align:center;">O(1)</td> <td style="text-align:center;">插入某节点的后继节点或前驱节点</td></tr> <tr><td style="text-align:center;">removeNext 或 removePre</td> <td style="text-align:center;">O(1)</td> <td style="text-align:center;">删除某节点的前驱节点或后继节点</td></tr></tbody></table> <p><strong>循环链表</strong></p> <table><thead><tr><th style="text-align:center;">操作方法</th> <th style="text-align:center;">时间复杂度</th> <th style="text-align:center;">说明</th></tr></thead> <tbody><tr><td style="text-align:center;">search</td> <td style="text-align:center;">O(n)</td> <td style="text-align:center;">在链表中查找任意元素</td></tr> <tr><td style="text-align:center;">insert</td> <td style="text-align:center;">O(n)</td> <td style="text-align:center;">在链表中任意位置插入一个节点</td></tr> <tr><td style="text-align:center;">remove</td> <td style="text-align:center;">O(n)</td> <td style="text-align:center;">删除链表中任意位置的一个节点</td></tr> <tr><td style="text-align:center;">searchNext</td> <td style="text-align:center;">O(1)</td> <td style="text-align:center;">查找某节点的后继节点</td></tr> <tr><td style="text-align:center;">insertNext</td> <td style="text-align:center;">O(1)</td> <td style="text-align:center;">在某一节点后插入一个节点（后继节点）</td></tr> <tr><td style="text-align:center;">removeNext</td> <td style="text-align:center;">O(1)</td> <td style="text-align:center;">在某一节点后删除一个节点（后继节点）</td></tr></tbody></table> <p>详情：<strong>前端进阶算法4：链表原来如此简单（+leetcode刷题）</strong>[13]</p> <h3 id="五、图解leetcode88-合并两个有序数组"><a href="#五、图解leetcode88-合并两个有序数组" class="header-anchor">#</a> 五、图解leetcode88：合并两个有序数组</h3> <h4 id="_1-题目"><a href="#_1-题目" class="header-anchor">#</a> 1. 题目</h4> <p>给你两个有序整数数组 <code>nums1</code> 和 <code>nums2</code>，请你将 <code>nums2</code> 合并到 <code>nums1</code> 中，使 <code>num1</code> 成为一个有序数组。</p> <p>说明:</p> <p>初始化 <code>nums1</code> 和 <code>nums2</code> 的元素数量分别为 <code>m</code> 和 <code>n</code> 。你可以假设 <code>nums1</code> 有足够的空间（空间大小大于或等于 <code>m + n</code> ）来保存 <code>nums2</code> 中的元素。</p> <p><strong>示例:</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
</code></pre></div><h4 id="_2-解答"><a href="#_2-解答" class="header-anchor">#</a> 2. 解答</h4> <p><strong>解题思路：</strong></p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQ3WsOP2syTPC4uAkQaScm1yLq60Diceic2MMgId8HhDfzcn0Mm5nIKWXFzRj2xpEWuOV72TxFVH5fA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <ul><li><p><code>nums1</code> 、 <code>nums2</code> 有序，若把 <code>nums2</code> 全部合并到 <code>nums1</code> ，则合并后的 <code>nums1</code> 长度为 <code>m+n</code></p></li> <li><p>我们可以从下标 <code>m+n-1</code> 的位置填充 <code>nums1</code> ，比较 <code>nums1[len1]</code> 与 <code>nums2[len2]</code> 的大小，将最大值写入 <code>nums1[len]</code>，即</p></li> <li><ul><li><code>nums1[len1]&gt;=nums2[len2]</code> ，<code>nums1[len--] = nums1[len1--]</code> ,这里 <code>--</code> 是因为写入成功后，下标自动建议，继续往前比较</li> <li>否则 <code>nums1[len--] = nums2[len2--]</code></li></ul></li> <li><p>边界条件：</p></li> <li><ul><li>若 <code>len1 &lt; 0</code>，即 <code>len2 &gt;= 0</code> ，此时 <code>nums1</code> 已重写入， <code>nums2</code> 还未合并完，仅仅需要将 <code>nums2</code> 的剩余元素（0…len）写入 <code>nums2</code> 即可，写入后，合并完成</li> <li>若 <code>len2 &lt; 0</code>，此时 <code>nums2</code> 已全部合并到 <code>nums1</code> ，合并完成</li></ul></li></ul> <p><strong>时间复杂度为 O(m+n)</strong></p> <p><strong>代码实现：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>var merge = function(nums1, m, nums2, n) {
    let len1 = m - 1,
        len2 = n - 1,
        len = m + n - 1
    while(len2 &gt;= 0) {
        if(len1 &lt; 0) {
            nums1[len--] = nums2[len2--]
            continue
        }
        nums1[len--] = nums1[len1] &gt;= nums2[len2] ? nums1[len1--]: nums2[len2--]
    }
};
</code></pre></div><h4 id="_3-更多解答请看-图解leetcode88-合并两个有序数组-14"><a href="#_3-更多解答请看-图解leetcode88-合并两个有序数组-14" class="header-anchor">#</a> 3. 更多解答请看：图解leetcode88：合并两个有序数组[14]</h4> <h3 id="六、字节-leetcode1-两数之和"><a href="#六、字节-leetcode1-两数之和" class="header-anchor">#</a> 六、字节&amp;leetcode1：两数之和</h3> <h4 id="_1-题目-2"><a href="#_1-题目-2" class="header-anchor">#</a> 1. 题目</h4> <p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code> ，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p> <p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p> <p><strong>示例:</strong></p> <div class="language- extra-class"><pre class="language-text"><code>给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
</code></pre></div><h4 id="_2-解答-2"><a href="#_2-解答-2" class="header-anchor">#</a> 2. 解答</h4> <p><strong>解题思路：</strong></p> <ul><li><p>初始化一个 <code>map = new Map()</code></p></li> <li><p>从第一个元素开始遍历 <code>nums</code></p></li> <li><p>获取目标值与 <code>nums[i]</code> 的差值，即 <code>k = target - nums[i]</code> ，判断差值在 <code>map</code> 中是否存在</p></li> <li><ul><li>不存在（ <code>map.has(k)</code> 为 <code>false</code> ） ，则将 <code>nums[i]</code> 加入到 <code>map</code> 中（key为<code>nums[i]</code>, value为 <code>i</code> ，方便查找map中是否存在某值，并可以通过 <code>get</code> 方法直接拿到下标）</li> <li>存在（ <code>map.has(k)</code> ），返回 <code>[map.get(k), i]</code> ，求解结束</li></ul></li> <li><p>遍历结束，则 <code>nums</code> 中没有符合条件的两个数，返回 <code>[]</code></p></li></ul> <p><strong>时间复杂度：O(n)</strong></p> <p><strong>代码实现：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>var twoSum = function(nums, target) {
    let map = new Map()
    for(let i = 0; i&lt; nums.length; i++) {
        let k = target-nums[i]
        if(map.has(k)) {
            return [map.get(k), i]
        }
        map.set(nums[i], i)
    }
    return [];
};
</code></pre></div><h4 id="_3-更多解答请看-字节-leetcode1-两数之和-15"><a href="#_3-更多解答请看-字节-leetcode1-两数之和-15" class="header-anchor">#</a> 3. 更多解答请看：字节&amp;leetcode1：两数之和[15]</h4> <h3 id="七、腾讯-数组扁平化、去重、排序"><a href="#七、腾讯-数组扁平化、去重、排序" class="header-anchor">#</a> 七、腾讯：数组扁平化、去重、排序</h3> <h4 id="_1-题目-3"><a href="#_1-题目-3" class="header-anchor">#</a> 1. 题目</h4> <blockquote><p>已知如下数组：var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];</p> <p>编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组</p></blockquote> <h4 id="_2-答案"><a href="#_2-答案" class="header-anchor">#</a> 2. 答案：</h4> <div class="language- extra-class"><pre class="language-text"><code>var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]
// 扁平化
let flatArr = arr.flat(4)
// 去重
let disArr = Array.from(new Set(flatArr))
// 排序
let result = disArr.sort(function(a, b) {
    return a-b
})
console.log(result)
// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
</code></pre></div><p>感谢 <strong>352800205</strong> 的补充：<code>flat()</code> 方法对node版本有要求，至少需要12.0以上</p> <h4 id="_3-更多解答请看-腾讯-数组扁平化、去重、排序-16"><a href="#_3-更多解答请看-腾讯-数组扁平化、去重、排序-16" class="header-anchor">#</a> 3. 更多解答请看：腾讯：数组扁平化、去重、排序[16]</h4> <h3 id="八、leetcode349-给定两个数组-编写一个函数来计算它们的交集"><a href="#八、leetcode349-给定两个数组-编写一个函数来计算它们的交集" class="header-anchor">#</a> 八、leetcode349：给定两个数组，编写一个函数来计算它们的交集</h3> <h4 id="_1-题目-4"><a href="#_1-题目-4" class="header-anchor">#</a> 1. 题目</h4> <p>给定两个数组，编写一个函数来计算它们的交集。</p> <p><strong>示例 1:</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入: nums1 = [1,2,2,1], nums2 = [2,2]
输出: [2]
</code></pre></div><p><strong>示例 2:</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出: [9,4]
</code></pre></div><p><strong>说明:</strong></p> <p>输出结果中的每个元素一定是唯一的。我们可以不考虑输出结果的顺序。</p> <h4 id="_2-答案-2"><a href="#_2-答案-2" class="header-anchor">#</a> 2. 答案</h4> <p><strong>解题思路：</strong></p> <ul><li><code>filter</code> 过滤</li> <li><code>Set</code> 去重</li></ul> <p><strong>代码实现：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>var intersection = function(nums1, nums2) {
    return [...new Set(nums1.filter((item)=&gt;nums2.includes(item)))]
};
</code></pre></div><h4 id="_3-更多解答请看-leetcode349-给定两个数组-编写一个函数来计算它们的交集-17"><a href="#_3-更多解答请看-leetcode349-给定两个数组-编写一个函数来计算它们的交集-17" class="header-anchor">#</a> 3. 更多解答请看：leetcode349：给定两个数组，编写一个函数来计算它们的交集[17]</h4> <h3 id="九、leetcode146-设计和实现一个lru-最近最少使用-缓存机制"><a href="#九、leetcode146-设计和实现一个lru-最近最少使用-缓存机制" class="header-anchor">#</a> 九、leetcode146：设计和实现一个LRU（最近最少使用）缓存机制</h3> <h4 id="_1-题目-5"><a href="#_1-题目-5" class="header-anchor">#</a> 1. 题目</h4> <p>运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作：获取数据 <code>get</code> 和写入数据 <code>put</code> 。</p> <p>获取数据 <code>get(key)</code> - 如果密钥 ( <code>key</code> ) 存在于缓存中，则获取密钥的值（总是正数），否则返回 <code>-1</code> 。写入数据 <code>put(key, value)</code> - 如果密钥不存在，则写入数据。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据，从而为新数据留出空间。</p> <p><strong>进阶:</strong></p> <p>你是否可以在 <strong>O(1)</strong> 时间复杂度内完成这两种操作？</p> <p><strong>示例:</strong></p> <div class="language- extra-class"><pre class="language-text"><code>LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回  1
cache.put(3, 3);    // 该操作会使得密钥 2 作废
cache.get(2);       // 返回 -1 (未找到)
cache.put(4, 4);    // 该操作会使得密钥 1 作废
cache.get(1);       // 返回 -1 (未找到)
cache.get(3);       // 返回  3
cache.get(4);       // 返回  4
</code></pre></div><h4 id="_2-答案-3"><a href="#_2-答案-3" class="header-anchor">#</a> 2. 答案</h4> <p><strong>基础解法：数组+对象实现</strong></p> <p>类 vue keep-alive 实现</p> <div class="language- extra-class"><pre class="language-text"><code>var LRUCache = function(capacity) {
    this.keys = []
    this.cache = Object.create(null)
    this.capacity = capacity
};

LRUCache.prototype.get = function(key) {
    if(this.cache[key]) {
        // 调整位置
        remove(this.keys, key)
        this.keys.push(key)
        return this.cache[key]
    }
    return -1
};

LRUCache.prototype.put = function(key, value) {
    if(this.cache[key]) {
        // 存在即更新
        this.cache[key] = value
        remove(this.keys, key)
        this.keys.push(key)
    } else {
        // 不存在即加入
        this.keys.push(key)
        this.cache[key] = value
        // 判断缓存是否已超过最大值
        if(this.keys.length &gt; this.capacity) {
            removeCache(this.cache, this.keys, this.keys[0])
        }
    }
};

// 移除 key
function remove(arr, key) {
    if (arr.length) {
        const index = arr.indexOf(key)
        if (index &gt; -1) {
            return arr.splice(index, 1)
        }
    }
}

// 移除缓存中 key
function removeCache(cache, keys, key) {
    cache[key] = null
    remove(keys, key)
}
</code></pre></div><p><strong>进阶：Map</strong></p> <p>利用 Map 既能保存键值对，并且能够记住键的原始插入顺序</p> <div class="language- extra-class"><pre class="language-text"><code>var LRUCache = function(capacity) {
    this.cache = new Map()
    this.capacity = capacity
}

LRUCache.prototype.get = function(key) {
    if (this.cache.has(key)) {
        // 存在即更新
        let temp = this.cache.get(key)
        this.cache.delete(key)
        this.cache.set(key, temp)
        return temp
    }
    return -1
}

LRUCache.prototype.put = function(key, value) {
    if (this.cache.has(key)) {
        // 存在即更新（删除后加入）
        this.cache.delete(key)
    } else if (this.cache.size &gt;= this.capacity) {
        // 不存在即加入
        // 缓存超过最大值，则移除最近没有使用的
        this.cache.delete(this.cache.keys().next().value)
    }
    this.cache.set(key, value)
}
</code></pre></div><h4 id="_3-更多解答请看-leetcode146-设计和实现一个lru-最近最少使用-缓存机制-18"><a href="#_3-更多解答请看-leetcode146-设计和实现一个lru-最近最少使用-缓存机制-18" class="header-anchor">#</a> 3. 更多解答请看：leetcode146：设计和实现一个LRU（最近最少使用）缓存机制[18]</h4> <h3 id="十、阿里算法题-编写一个函数计算多个数组的交集"><a href="#十、阿里算法题-编写一个函数计算多个数组的交集" class="header-anchor">#</a> 十、阿里算法题：编写一个函数计算多个数组的交集</h3> <h4 id="_1-题目-6"><a href="#_1-题目-6" class="header-anchor">#</a> 1. 题目</h4> <p>**要求：**输出结果中的每个元素一定是唯一的</p> <h4 id="_2-答案-4"><a href="#_2-答案-4" class="header-anchor">#</a> 2. 答案</h4> <p>使用 reducer 函数</p> <div class="language- extra-class"><pre class="language-text"><code>var intersection = function(...args) {
    if (args.length === 0) {
    return []
  }
  if (args.length === 1) {
    return args[0]
  }
  return [...new Set(args.reduce((result, arg) =&gt; {
    return result.filter(item =&gt; arg.includes(item))
  }))]
};
</code></pre></div><h4 id="_3-更多解答请看-阿里算法题-编写一个函数计算多个数组的交集-19"><a href="#_3-更多解答请看-阿里算法题-编写一个函数计算多个数组的交集-19" class="header-anchor">#</a> 3. 更多解答请看：阿里算法题：编写一个函数计算多个数组的交集[19]</h4> <h3 id="十一、leetcode21-合并两个有序链表"><a href="#十一、leetcode21-合并两个有序链表" class="header-anchor">#</a> 十一、leetcode21：合并两个有序链表</h3> <h4 id="_1-题目-7"><a href="#_1-题目-7" class="header-anchor">#</a> 1. 题目</h4> <p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p> <p><strong>示例：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4
输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4
</code></pre></div><h4 id="_2-答案-5"><a href="#_2-答案-5" class="header-anchor">#</a> 2. 答案</h4> <p><strong>解答：</strong></p> <p><strong>确定解题的数据结构：</strong> 单链表</p> <p><strong>确定解题思路：</strong> 从链表头开始比较，<code>l1</code> 与 <code>l2</code> 是有序递增的，所以比较 <code>l1.val</code> 与 <code>l2.val</code>的较小值就是合并后链表的最小值，次小值就是小节点的 <code>next.val</code> 与大节点的 <code>val</code> 比较的较小值，依次递归，直到递归到 <code>l1</code> <code>l2</code> 均为 <code>null</code></p> <p><strong>画图实现：</strong> 画图帮助理解一下</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p><strong>确定边界条件：</strong> 当递归到任意链表为 <code>null</code> ，直接将 <code>next</code> 指向另外的链表即可，不需要继续递归了</p> <p><strong>代码实现：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>function mergeTwoLists(l1, l2) {
    if(l1 === null) {
        return l2
    }
    if(l2 === null) {
        return l1
    }
    if(l1.val &lt;= l2.val) {
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    } else {
        l2.next = mergeTwoLists(l2.next, l1)
        return l2
    }
}
</code></pre></div><h4 id="_3-更多解答请看-leetcode21-合并两个有序链表-20"><a href="#_3-更多解答请看-leetcode21-合并两个有序链表-20" class="header-anchor">#</a> 3. 更多解答请看：leetcode21：合并两个有序链表[20]</h4> <h3 id="十二、有赞-leetcode141-判断一个单链表是否有环"><a href="#十二、有赞-leetcode141-判断一个单链表是否有环" class="header-anchor">#</a> 十二、有赞&amp;leetcode141：判断一个单链表是否有环</h3> <h4 id="_1-题目-8"><a href="#_1-题目-8" class="header-anchor">#</a> 1. 题目</h4> <p>给定一个链表，判断链表中是否有环。</p> <p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 <code>0</code>开始）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p> <p><strong>示例 1：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
</code></pre></div><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p><strong>示例 2：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
</code></pre></div><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p><strong>示例 3：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
</code></pre></div><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p><strong>进阶：</strong></p> <p>你能用 O(1)（即，常量）内存解决此问题吗？</p> <h4 id="_2-答案-6"><a href="#_2-答案-6" class="header-anchor">#</a> 2. 答案</h4> <h5 id="解法一-标志法"><a href="#解法一-标志法" class="header-anchor">#</a> 解法一：标志法</h5> <p>给每个已遍历过的节点加标志位，遍历链表，当出现下一个节点已被标志时，则证明单链表有环</p> <div class="language- extra-class"><pre class="language-text"><code>var hasCycle = function(head) {
    while(head) {
        if(head.flag) return true
        head.flag = true
        head = head.next
    }
    return false
};
</code></pre></div><p><strong>时间复杂度：O(n)</strong></p> <p><strong>空间复杂度：O(n)</strong></p> <h5 id="解法二-利用-json-stringify-不能序列化含有循环引用的结构"><a href="#解法二-利用-json-stringify-不能序列化含有循环引用的结构" class="header-anchor">#</a> 解法二：利用 <code>JSON.stringify()</code> 不能序列化含有循环引用的结构</h5> <div class="language- extra-class"><pre class="language-text"><code>var hasCycle = function(head) {
    try{
        JSON.stringify(head);
        return false;
    }
    catch(err){
        return true;
    }
};
</code></pre></div><p><strong>时间复杂度：O(n)</strong></p> <p><strong>空间复杂度：O(n)</strong></p> <h5 id="解法三-快慢指针-双指针法"><a href="#解法三-快慢指针-双指针法" class="header-anchor">#</a> 解法三：快慢指针（双指针法）</h5> <p>设置快慢两个指针，遍历单链表，快指针一次走两步，慢指针一次走一步，如果单链表中存在环，则快慢指针终会指向同一个节点，否则直到快指针指向 <code>null</code> 时，快慢指针都不可能相遇</p> <div class="language- extra-class"><pre class="language-text"><code>var hasCycle = function(head) {
    if(!head || !head.next) {
        return false
    }
    let fast = head.next.next, slow = head
    while(fast !== slow) {
        if(!fast || !fast.next) return false
        fast = fast.next.next
        slow = slow.next
    }
    return true
};
</code></pre></div><p><strong>时间复杂度：O(n)</strong></p> <p><strong>空间复杂度：O(1)</strong></p> <h4 id="_3-更多解答请看-有赞-leetcode141-判断一个单链表是否有环-21"><a href="#_3-更多解答请看-有赞-leetcode141-判断一个单链表是否有环-21" class="header-anchor">#</a> 3. 更多解答请看：有赞&amp;leetcode141：判断一个单链表是否有环[21]</h4> <h3 id="十三、图解leetcode206-反转链表"><a href="#十三、图解leetcode206-反转链表" class="header-anchor">#</a> 十三、图解leetcode206：反转链表</h3> <h4 id="_1-题目-9"><a href="#_1-题目-9" class="header-anchor">#</a> 1. 题目</h4> <p><strong>示例:</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
</code></pre></div><p>**进阶:**你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p> <h4 id="_2-解答-3"><a href="#_2-解答-3" class="header-anchor">#</a> 2. 解答</h4> <h5 id="解法一-迭代法"><a href="#解法一-迭代法" class="header-anchor">#</a> 解法一：迭代法</h5> <p><strong>解题思路：</strong> 将单链表中的每个节点的后继指针指向它的前驱节点即可</p> <p><strong>画图实现：</strong> 画图帮助理解一下</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p><strong>确定边界条件：</strong> 当链表为 <code>null</code> 或链表中仅有一个节点时，不需要反转</p> <p><strong>代码实现：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>var reverseList = function(head) {
    if(!head || !head.next) return head
    var prev = null, curr = head
    while(curr) {
        // 用于临时存储 curr 后继节点
        var next = curr.next
        // 反转 curr 的后继指针
        curr.next = prev
        // 变更prev、curr 
        // 待反转节点指向下一个节点 
        prev = curr
        curr = next
    }
    head = prev
    return head
};
</code></pre></div><p><strong>时间复杂度：O(n)</strong></p> <p><strong>空间复杂度：O(1)</strong></p> <h5 id="解法二-尾递归法"><a href="#解法二-尾递归法" class="header-anchor">#</a> 解法二：尾递归法</h5> <p><strong>解题思路：</strong> 从头节点开始，递归反转它的每一个节点，直到 <code>null</code> ，思路和解法一类似</p> <p><strong>代码实现：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>var reverseList = function(head) {
    if(!head || !head.next) return head
    head = reverse(null, head)
    return head
};

var reverse = function(prev, curr) {
    if(!curr) return prev
    var next = curr.next
    curr.next = prev
    return reverse(curr, next)
};
</code></pre></div><p><strong>时间复杂度：O(n)</strong></p> <p><strong>空间复杂度：O(n)</strong></p> <h5 id="解法三-递归法"><a href="#解法三-递归法" class="header-anchor">#</a> 解法三：递归法</h5> <p><strong>解题思路：</strong> 不断递归反转当前节点 <code>head</code> 的后继节点 <code>next</code></p> <p><strong>画图实现：</strong> 画图帮助理解一下</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p><strong>代码实现：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>var reverseList = function(head) {
    if(!head || !head.next) return head
    var next = head.next
    // 递归反转
    var reverseHead = reverseList(next)
    // 变更指针
    next.next = head
    head.next = null
    return reverseHead
};
</code></pre></div><p><strong>时间复杂度：O(n)</strong></p> <p><strong>空间复杂度：O(n)</strong></p> <h4 id="_3-更多解答请看-图解-leetcode206-反转链表-22"><a href="#_3-更多解答请看-图解-leetcode206-反转链表-22" class="header-anchor">#</a> 3. 更多解答请看：图解 leetcode206：反转链表[22]</h4> <h3 id="十四、前端算法集训营第一期免费加入啦"><a href="#十四、前端算法集训营第一期免费加入啦" class="header-anchor">#</a> 十四、前端算法集训营第一期免费加入啦</h3> <p>欢迎关注「前端瓶子君」，回复「算法」自动加入，从0到1构建完整的数据结构与算法体系！</p> <p>在这里，瓶子君不仅介绍算法，还将算法与前端各个领域进行结合，包括浏览器、HTTP、V8、React、Vue源码等。</p> <p>在这里，你可以每天学习一道大厂算法题（阿里、腾讯、百度、字节等等）或 leetcode，瓶子君都会在第二天解答哟！</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>⬆️ <strong>扫码关注公众号「前端瓶子君」，回复「算法」即可自动加入 👍👍👍</strong></p> <p><a href="https://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247484298&amp;idx=1&amp;sn=846c8c4117fa0eb5f9a7e66c54b7ae5a&amp;chksm=faec8752cd9b0e44326a3b532ec3e5f57498c83642211c68017dd212f1ddeca53b45b44fe42e&amp;scene=178&amp;cur_album_id=1342984294104662017&amp;rd2werd=1&amp;key=6b251770640032827c15d145b3fb42b4be42b8c0fe29a4bace1dfad3933fc7b5c44d4e18a36192539ad91625e242ec5a25eeb8edc3f1272ce1b89cd01926986bcdd7db23979837ea36d4344f7da3cb95738b281c1134d7abbe777fd58e3605b765f90ce904ed4c03544132fb8d06923787eb7caa8ea3a1d41404e0d797f4f93c&amp;ascene=1&amp;uin=MTE5NzkwMDQyOA%3D%3D&amp;devicetype=iMac+MacBookPro16%2C1+OSX+OSX+10.16+build(20G95)&amp;version=13010510&amp;nettype=WIFI&amp;lang=zh_CN&amp;fontScale=100&amp;exportkey=AVa0oS1%2FhPgXikJEJRCvabU%3D&amp;pass_ticket=wFWGmZwhuThchaxD%2F8KCFyP5ohv32kJThs87R2RE0n8DjhSFnI501UNUy31Bvchp&amp;wx_header=0&amp;fontgear=3.000000" target="_blank" rel="noopener noreferrer">》》面试官都在用的题库，点击学习《《<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="github地址"><a href="#github地址" class="header-anchor">#</a> github地址</h3> <p>[1]图解leetcode88：合并两个有序数组: <em>https://github.com/sisterAn/JavaScript-Algorithms/issues/3</em>[2]字节&amp;leetcode1：两数之和: <em>https://github.com/sisterAn/JavaScript-Algorithms/issues/4</em>[3]腾讯：数组扁平化、去重、排序: <em>https://github.com/sisterAn/JavaScript-Algorithms/issues/5</em>[4]leetcode349：给定两个数组，编写一个函数来计算它们的交集: <em>https://github.com/sisterAn/JavaScript-Algorithms/issues/6</em>[5]leetcode146：设计和实现一个LRU（最近最少使用）缓存机制: <em>https://github.com/sisterAn/JavaScript-Algorithms/issues/7</em>[6]阿里算法题：编写一个函数计算多个数组的交集: <em>https://github.com/sisterAn/JavaScript-Algorithms/issues/10</em>[7]leetcode21：合并两个有序链表: <em>https://github.com/sisterAn/JavaScript-Algorithms/issues/11</em>[8]有赞&amp;leetcode141：判断一个单链表是否有环: <em>https://github.com/sisterAn/JavaScript-Algorithms/issues/13</em>[9]图解leetcode206：反转链表: <em>https://github.com/sisterAn/JavaScript-Algorithms/issues/14</em>[10]前端进阶算法1：如何分析、统计算法的执行效率和资源消耗？: <em>https://github.com/sisterAn/JavaScript-Algorithms/issues/1</em>[11]前端进阶算法2：从Chrome V8源码看JavaScript数组（附赠腾讯面试题）: <em>https://github.com/sisterAn/JavaScript-Algorithms/issues/2</em>[12]前端进阶算法3：从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法: <em>https://github.com/sisterAn/JavaScript-Algorithms/issues/9</em>[13]前端进阶算法4：链表原来如此简单（+leetcode刷题）: <em>https://github.com/sisterAn/JavaScript-Algorithms/issues/12</em>[14]图解leetcode88：合并两个有序数组: <em>https://github.com/sisterAn/JavaScript-Algorithms/issues/3</em>[15]字节&amp;leetcode1：两数之和: <em>https://github.com/sisterAn/JavaScript-Algorithms/issues/4</em>[16]腾讯：数组扁平化、去重、排序: <em>https://github.com/sisterAn/JavaScript-Algorithms/issues/5</em>[17]leetcode349：给定两个数组，编写一个函数来计算它们的交集: <em>https://github.com/sisterAn/JavaScript-Algorithms/issues/6</em>[18]leetcode146：设计和实现一个LRU（最近最少使用）缓存机制: <em>https://github.com/sisterAn/JavaScript-Algorithms/issues/7</em>[19]阿里算法题：编写一个函数计算多个数组的交集: <em>https://github.com/sisterAn/JavaScript-Algorithms/issues/10</em>[20]leetcode21：合并两个有序链表: <em>https://github.com/sisterAn/JavaScript-Algorithms/issues/11</em>[21]有赞&amp;leetcode141：判断一个单链表是否有环: <em>https://github.com/sisterAn/JavaScript-Algorithms/issues/13</em>[22]图解 leetcode206：反转链表: <em>https://github.com/sisterAn/JavaScript-Algorithms/issues/14</em></p> <p><img src="https://mmbiz.qlogo.cn/mmbiz_jpg/iaUXCIgN4lOFcYSsSBnCia2E6kJJmR2Suh7a0Lm4TsmAxtmiaYRr5etvyHb7vIA6jb9kfVl2WSQBiciauzhLA50mtxg/0?wx_fmt=jpeg" alt="作者"></p> <p>前端瓶子君</p> <p><img src="https://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247484298&amp;idx=1&amp;sn=846c8c4117fa0eb5f9a7e66c54b7ae5a&amp;chksm=faec8752cd9b0e44326a3b532ec3e5f57498c83642211c68017dd212f1ddeca53b45b44fe42e&amp;scene=178&amp;cur_album_id=1342984294104662017&amp;rd2werd=1&amp;key=6b251770640032827c15d145b3fb42b4be42b8c0fe29a4bace1dfad3933fc7b5c44d4e18a36192539ad91625e242ec5a25eeb8edc3f1272ce1b89cd01926986bcdd7db23979837ea36d4344f7da3cb95738b281c1134d7abbe777fd58e3605b765f90ce904ed4c03544132fb8d06923787eb7caa8ea3a1d41404e0d797f4f93c&amp;ascene=1&amp;uin=MTE5NzkwMDQyOA%3D%3D&amp;devicetype=iMac+MacBookPro16%2C1+OSX+OSX+10.16+build(20G95)&amp;version=13010510&amp;nettype=WIFI&amp;lang=zh_CN&amp;fontScale=100&amp;exportkey=AVa0oS1%2FhPgXikJEJRCvabU%3D&amp;pass_ticket=wFWGmZwhuThchaxD%2F8KCFyP5ohv32kJThs87R2RE0n8DjhSFnI501UNUy31Bvchp&amp;wx_header=0&amp;fontgear=3.000000" alt="赞赏二维码"><a href="https://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247484298&amp;idx=1&amp;sn=846c8c4117fa0eb5f9a7e66c54b7ae5a&amp;chksm=faec8752cd9b0e44326a3b532ec3e5f57498c83642211c68017dd212f1ddeca53b45b44fe42e&amp;scene=178&amp;cur_album_id=1342984294104662017&amp;rd2werd=1&amp;key=6b251770640032827c15d145b3fb42b4be42b8c0fe29a4bace1dfad3933fc7b5c44d4e18a36192539ad91625e242ec5a25eeb8edc3f1272ce1b89cd01926986bcdd7db23979837ea36d4344f7da3cb95738b281c1134d7abbe777fd58e3605b765f90ce904ed4c03544132fb8d06923787eb7caa8ea3a1d41404e0d797f4f93c&amp;ascene=1&amp;uin=MTE5NzkwMDQyOA%3D%3D&amp;devicetype=iMac+MacBookPro16%2C1+OSX+OSX+10.16+build(20G95)&amp;version=13010510&amp;nettype=WIFI&amp;lang=zh_CN&amp;fontScale=100&amp;exportkey=AVa0oS1%2FhPgXikJEJRCvabU%3D&amp;pass_ticket=wFWGmZwhuThchaxD%2F8KCFyP5ohv32kJThs87R2RE0n8DjhSFnI501UNUy31Bvchp&amp;wx_header=0&amp;fontgear=3.000000##" target="_blank" rel="noopener noreferrer">喜欢作者<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>1 人喜欢</p> <p><img src="http://wx.qlogo.cn/mmhead/zULCKyBNbgbKjaMkWQU9TDibJ5u6baic5O3ia4D2PSwT94/132" alt="img"></p> <p>阅读 2488</p> <p>赞3在看16</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">5/8/2024, 3:01:19 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/algorithm/算法进阶/小白都可以看懂的树与二叉树.html" class="prev">
        前端进阶算法7：小白都可以看懂的树与二叉树
      </a></span> <span class="next"><a href="/algorithm/算法进阶/常见算法题及完美题解.html">
        前端进阶算法：常见算法题及完美题解
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.950eebbc.js" defer></script><script src="/assets/js/2.57da4f88.js" defer></script><script src="/assets/js/1.a76cc220.js" defer></script><script src="/assets/js/42.cef1f724.js" defer></script>
  </body>
</html>
