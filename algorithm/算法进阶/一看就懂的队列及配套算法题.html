<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端进阶算法6：一看就懂的队列及配套算法题 | duangdong的algorithm</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/logo.png">
    <link rel="manifest" href="/manifest.json">
    <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?0088ce24040b03f2947322ab31d23414";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
    <script>
  var _hmt = _hmt || [];
  _hmt.push(['_requirePlugin', 'UrlChangeTracker', {
    shouldTrackUrlChange: function (newPath, oldPath) {
      newPath = newPath.split('#')[0];
      oldPath = oldPath.split('#')[0];
      return newPath != oldPath;
    }}
  ]);
  </script>
    <meta name="description" content="前端相关知识归纳总结">
    <meta name="keywords" content="qd-blog,node,vuepress,leetcode,algorithm">
    
    <link rel="preload" href="/assets/css/0.styles.b4a844ec.css" as="style"><link rel="preload" href="/assets/js/app.950eebbc.js" as="script"><link rel="preload" href="/assets/js/2.57da4f88.js" as="script"><link rel="preload" href="/assets/js/1.a76cc220.js" as="script"><link rel="preload" href="/assets/js/33.9d15b4c0.js" as="script"><link rel="prefetch" href="/assets/js/10.50f73657.js"><link rel="prefetch" href="/assets/js/11.0390ceee.js"><link rel="prefetch" href="/assets/js/12.f88bec36.js"><link rel="prefetch" href="/assets/js/13.963ad03b.js"><link rel="prefetch" href="/assets/js/14.512f15b9.js"><link rel="prefetch" href="/assets/js/15.a674496c.js"><link rel="prefetch" href="/assets/js/16.ed7e507f.js"><link rel="prefetch" href="/assets/js/17.de667ca5.js"><link rel="prefetch" href="/assets/js/18.b44e84af.js"><link rel="prefetch" href="/assets/js/19.5b5ad6a1.js"><link rel="prefetch" href="/assets/js/20.6800493a.js"><link rel="prefetch" href="/assets/js/21.6589052c.js"><link rel="prefetch" href="/assets/js/22.f648d829.js"><link rel="prefetch" href="/assets/js/23.b85d0d4e.js"><link rel="prefetch" href="/assets/js/24.d81147fb.js"><link rel="prefetch" href="/assets/js/25.ed5233ca.js"><link rel="prefetch" href="/assets/js/26.83f1ef57.js"><link rel="prefetch" href="/assets/js/27.2565321e.js"><link rel="prefetch" href="/assets/js/28.e60083e4.js"><link rel="prefetch" href="/assets/js/29.49b5374e.js"><link rel="prefetch" href="/assets/js/3.13e892f5.js"><link rel="prefetch" href="/assets/js/30.9ad0e230.js"><link rel="prefetch" href="/assets/js/31.c97534c6.js"><link rel="prefetch" href="/assets/js/32.b90554dc.js"><link rel="prefetch" href="/assets/js/34.297b5f45.js"><link rel="prefetch" href="/assets/js/35.029c4cac.js"><link rel="prefetch" href="/assets/js/36.bc299146.js"><link rel="prefetch" href="/assets/js/37.9068edfd.js"><link rel="prefetch" href="/assets/js/38.8c781d87.js"><link rel="prefetch" href="/assets/js/39.87c06c9c.js"><link rel="prefetch" href="/assets/js/4.5bdb9365.js"><link rel="prefetch" href="/assets/js/40.b05763a5.js"><link rel="prefetch" href="/assets/js/41.447511bf.js"><link rel="prefetch" href="/assets/js/42.cef1f724.js"><link rel="prefetch" href="/assets/js/43.cae02230.js"><link rel="prefetch" href="/assets/js/44.833e4694.js"><link rel="prefetch" href="/assets/js/45.2933ab3e.js"><link rel="prefetch" href="/assets/js/46.1108fab7.js"><link rel="prefetch" href="/assets/js/47.1a5b2293.js"><link rel="prefetch" href="/assets/js/48.3f01058a.js"><link rel="prefetch" href="/assets/js/49.24929fd6.js"><link rel="prefetch" href="/assets/js/5.7c68fdb5.js"><link rel="prefetch" href="/assets/js/50.7e052a76.js"><link rel="prefetch" href="/assets/js/51.ae3eb599.js"><link rel="prefetch" href="/assets/js/52.bab65685.js"><link rel="prefetch" href="/assets/js/53.abacf47c.js"><link rel="prefetch" href="/assets/js/54.9d8ffddf.js"><link rel="prefetch" href="/assets/js/55.ac9707fe.js"><link rel="prefetch" href="/assets/js/56.9a9c42d4.js"><link rel="prefetch" href="/assets/js/57.f4d88e89.js"><link rel="prefetch" href="/assets/js/58.816a3870.js"><link rel="prefetch" href="/assets/js/59.8a6b3c7f.js"><link rel="prefetch" href="/assets/js/6.c8da7ca7.js"><link rel="prefetch" href="/assets/js/7.e4c88d0e.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.5143d2e0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b4a844ec.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">duangdong的algorithm</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/algorithm/" class="nav-link router-link-active">
  数据结构
</a></div><div class="nav-item"><a href="/leetcode/" class="nav-link">
  Leetcode
</a></div><div class="nav-item"><a href="/leetcode-summary/" class="nav-link">
  算法题
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/algorithm/" class="nav-link router-link-active">
  数据结构
</a></div><div class="nav-item"><a href="/leetcode/" class="nav-link">
  Leetcode
</a></div><div class="nav-item"><a href="/leetcode-summary/" class="nav-link">
  算法题
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/algorithm/" aria-current="page" class="sidebar-link">算法相关</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端实际项目使用</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/algorithm/动态规划.html" class="sidebar-link">前端也能学算法：由浅入深讲解动态规划</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>排序</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/algorithm/由浅入深讲解贪心算法.html" class="sidebar-link">前端也能学算法：由浅入深讲解贪心算法</a></li><li><a href="/algorithm/简单复习下前端算法复杂度相关的知识.html" class="sidebar-link">简单复习下前端算法复杂度相关的知识</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>算法进阶</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/algorithm/算法进阶/ChromeV8源码看JavaScript数组.html" class="sidebar-link">前端进阶算法2：从Chrome V8源码看JavaScript数组(附赠腾讯面试题)</a></li><li><a href="/algorithm/算法进阶/DIff算法看不懂就一起来锤我.html" class="sidebar-link">DIff算法看不懂就一起来锤我</a></li><li><a href="/algorithm/算法进阶/Diff算法核心原理.html" class="sidebar-link">15张图，20分钟吃透Diff算法核心原理</a></li><li><a href="/algorithm/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6/" aria-current="page" class="sidebar-link">算法进阶</a></li><li><a href="/algorithm/算法进阶/一看就懂的队列及配套算法题.html" class="active sidebar-link">前端进阶算法6：一看就懂的队列及配套算法题</a></li><li><a href="/algorithm/算法进阶/从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法.html" class="sidebar-link">前端进阶算法3：从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法</a></li><li><a href="/algorithm/算法进阶/别再说你不懂Top-K问题了.html" class="sidebar-link">别再说你不懂Top K问题了</a></li><li><a href="/algorithm/算法进阶/去大厂面试问我算法.html" class="sidebar-link">去大厂面试问我算法，我该怎么办？</a></li><li><a href="/algorithm/算法进阶/吊打面试官之数据结构栈.html" class="sidebar-link">前端进阶算法5：吊打面试官之数据结构栈（+leetcode刷题）</a></li><li><a href="/algorithm/算法进阶/堆排序.html" class="sidebar-link">前端进阶算法：看完这篇，再也不怕堆排序、Top K、中位数问题面试了</a></li><li><a href="/algorithm/算法进阶/头条正在面的哈希表问题.html" class="sidebar-link">前端进阶算法：头条正在面的哈希表问题</a></li><li><a href="/algorithm/算法进阶/如何分析-统计算法的执行效率和资源消耗.html" class="sidebar-link">前端进阶算法1：如何分析、统计算法的执行效率和资源消耗？</a></li><li><a href="/algorithm/算法进阶/小白都可以看懂的树与二叉树.html" class="sidebar-link">前端进阶算法7：小白都可以看懂的树与二叉树</a></li><li><a href="/algorithm/算法进阶/带你快速入门前端算法.html" class="sidebar-link">10 问 10 答，带你快速入门前端算法</a></li><li><a href="/algorithm/算法进阶/常见算法题及完美题解.html" class="sidebar-link">前端进阶算法：常见算法题及完美题解</a></li><li><a href="/algorithm/算法进阶/链表原来如此简单.html" class="sidebar-link">前端进阶算法4：链表原来如此简单(+leetcode刷题）</a></li></ul></section></li><li><a href="/algorithm/贪心.html" class="sidebar-link">前端也能学算法：由浅入深讲解贪心算法</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="前端进阶算法6-一看就懂的队列及配套算法题"><a href="#前端进阶算法6-一看就懂的队列及配套算法题" class="header-anchor">#</a> 前端进阶算法6：一看就懂的队列及配套算法题</h1> <p>原创 前端瓶子君 前端瓶子君 <em>2020-05-07</em></p> <h3 id="引言"><a href="#引言" class="header-anchor">#</a> 引言</h3> <p>队列这种数据结构，据瓶子君了解，前端需要了解的队列结构主要有：双端队列、滑动窗口，它们都是算法中是比较常用的数据结构。</p> <p>因此，本节主要内容为：</p> <ul><li>数据结构：队列（Queue）</li> <li>双端队列（Deque）</li> <li>双端队列的应用：翻转字符串中的单词</li> <li>滑动窗口</li> <li>滑动窗口应用：无重复字符的最长公共子串</li> <li>最后来一道 leetcode 题目：滑动窗口最大值问题</li></ul> <p>下面进入正文吧👇</p> <h3 id="一、数据结构-队列"><a href="#一、数据结构-队列" class="header-anchor">#</a> 一、数据结构：队列</h3> <p>队列和栈类似，不同的是队列是先进先出 (FIFO) 原则的有序集合，它的结构类似如下：</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQYTquARVybx8MjPHdibmMQ3IuXGLOhmcmtJ200WtHn0YllOP9dP3boyZnCydoVHaO4ut0PAjFZtHQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p>常见队列的操作有：<code>enqueue(e)</code> 进队、 <code>dequeue()</code> 出队、 <code>isEmpty()</code> 是否是空队、 <code>front()</code> 获取队头元素、<code>clear()</code> 清空队，以及 <code>size()</code> 获取队列长度。</p> <p><strong>代码实现</strong></p> <div class="language- extra-class"><pre class="language-text"><code>function Queue() {
  let items = []
  this.enqueue = function(e) {
    items.push(e)
  }
  this.dequeue = function() {
    return items.shift()
  }
  this.isEmpty = function() {
    return items.length === 0
  }
  this.front = function() {
    return items[0]
  }
  this.clear = function() { 
    items = [] 
  }
  this.size = function() {
    return items.length
  }
}
</code></pre></div><p><strong>查找：从对头开始查找，从时间复杂度为 O(n)</strong></p> <p><strong>插入或删除：进栈与出栈的时间复杂度为 O(1)</strong></p> <h3 id="二、双端队列-deque"><a href="#二、双端队列-deque" class="header-anchor">#</a> 二、双端队列（Deque）</h3> <h4 id="_1-什么是-deque"><a href="#_1-什么是-deque" class="header-anchor">#</a> 1. 什么是 Deque</h4> <p>Deque 在原有队列的基础上扩充了：队头、队尾都可以进队出队，它的数据结构如下：</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQYTquARVybx8MjPHdibmMQ3xb74S80z3om74a8kE6VicG7qYfKU5APb3DBeiblUtQfLJxick48qLFwZw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p><strong>代码实现：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>function Deque() {
  let items = []
  this.addFirst = function(e) {
    items.unshift(e)
  }
  this.removeFirst = function() {
    return items.shift()
  }
  this.addLast = function(e) {
    items.push(e)
  }
  this.removeLast = function() {
    return items.pop()
  }
  this.isEmpty = function() {
    return items.length === 0
  }
  this.front = function() {
    return items[0]
  }
  this.clear = function() { 
    items = [] 
  }
  this.size = function() {
    return items.length
  }
}
</code></pre></div><p>下面看一道经典的双端队列问题👇</p> <h4 id="_2-字节-leetcode151-翻转字符串里的单词"><a href="#_2-字节-leetcode151-翻转字符串里的单词" class="header-anchor">#</a> 2. 字节&amp;leetcode151：翻转字符串里的单词</h4> <p>给定一个字符串，逐个翻转字符串中的每个单词。</p> <p><strong>示例 1：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入: &quot;the sky is blue&quot;
输出: &quot;blue is sky the&quot;
</code></pre></div><p><strong>示例 2：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入: &quot;  hello world!  &quot;
输出: &quot;world! hello&quot;
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
</code></pre></div><p><strong>示例 3：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入: &quot;a good   example&quot;
输出: &quot;example good a&quot;
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
</code></pre></div><p><strong>说明：</strong></p> <ul><li>无空格字符构成一个单词。</li> <li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li> <li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li></ul> <p><strong>解题思路：使用双端队列解题</strong></p> <ul><li>首先去除字符串左右空格</li> <li>逐个读取字符串中的每个单词，依次放入双端队列的对头</li> <li>再将队列转换成字符串输出（已空格为分隔符）</li></ul> <p><strong>画图理解：</strong></p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQYTquARVybx8MjPHdibmMQ3E3MeFSibiaA8HY4zaE4cmGo43wgQjB6VQ4eWkme1uf4w3u09X4NtSwiaA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQYTquARVybx8MjPHdibmMQ3zmsV8zYxw7Uxfm1kibib844YZda0vHMGhWrE4MmkYRVjnQzuBqgRABZQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQYTquARVybx8MjPHdibmMQ3PwiaCqkU3LjKfHvq5HCVV1GJiclx0SzZxibmKxBH2Dt8zGb6L9kGdmia0g/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p><strong>代码实现：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>var reverseWords = function(s) {
    let left = 0
    let right = s.length - 1
    let queue = []
    let word = ''
    while (s.charAt(left) === ' ') left ++
    while (s.charAt(right) === ' ') right --
    while (left &lt;= right) {
        let char = s.charAt(left)
        if (char === ' ' &amp;&amp; word) {
            queue.unshift(word)
            word = ''
        } else if (char !== ' '){
            word += char
        }
        left++
    }
    queue.unshift(word)
    return queue.join(' ')
};
</code></pre></div><p>更多解法详见 图解字节&amp;leetcode151：翻转字符串里的单词</p> <h3 id="三、滑动窗口"><a href="#三、滑动窗口" class="header-anchor">#</a> 三、滑动窗口</h3> <h4 id="_1-什么是滑动窗口"><a href="#_1-什么是滑动窗口" class="header-anchor">#</a> 1. 什么是滑动窗口</h4> <p>这是队列的另一个重要应用</p> <p>顾名思义，滑动窗口就是一个运行在一个大数组上的子列表，该数组是一个底层元素集合。</p> <p>假设有数组 [a b c d e f g h ]，一个大小为 3 的 <strong>滑动窗口</strong>在其上滑动，则有：</p> <div class="language- extra-class"><pre class="language-text"><code>[a b c]
  [b c d]
    [c d e]
      [d e f]
        [e f g]
          [f g h]
</code></pre></div><p>一般情况下就是使用这个窗口在数组的 <strong>合法区间</strong> 内进行滑动，同时 <strong>动态地</strong> 记录一些有用的数据，很多情况下，能够极大地提高算法地效率。</p> <p>下面看一道经典的滑动窗口问题👇</p> <h4 id="_2-字节-leetcode3-无重复字符的最长子串"><a href="#_2-字节-leetcode3-无重复字符的最长子串" class="header-anchor">#</a> 2. 字节&amp;Leetcode3：无重复字符的最长子串</h4> <p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p> <p><strong>示例 1:</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入: &quot;abcabcbb&quot;
输出: 3 
解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。
</code></pre></div><p><strong>示例 2:</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入: &quot;bbbbb&quot;
输出: 1
解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。
</code></pre></div><p><strong>示例 3:</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入: &quot;pwwkew&quot;
输出: 3
解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。
</code></pre></div><p><strong>解题思路：</strong> 使用一个数组来维护滑动窗口</p> <p>遍历字符串，判断字符是否在滑动窗口数组里</p> <ul><li>不在则 <code>push</code> 进数组</li> <li>在则删除滑动窗口数组里相同字符及相同字符前的字符，然后将当前字符 <code>push</code> 进数组</li> <li>然后将 <code>max</code> 更新为当前最长子串的长度</li></ul> <p>遍历完，返回 <code>max</code> 即可</p> <p><strong>画图帮助理解一下：</strong></p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQYTquARVybx8MjPHdibmMQ33RHCZXCsOAibOwsqgQAtY3FGcFCXy2CuPYxFibnraAu4FnnlicfLRALHQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p><strong>代码实现：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>var lengthOfLongestSubstring = function(s) {
    let arr = [], max = 0
    for(let i = 0; i &lt; s.length; i++) {
        let index = arr.indexOf(s[i])
        if(index !== -1) {
            arr.splice(0, index+1);
        }
        arr.push(s.charAt(i))
        max = Math.max(arr.length, max) 
    }
    return max
};
</code></pre></div><p><strong>时间复杂度：O(n2)， 其中 <code>arr.indexOf()</code> 时间复杂度为 O(n) ，<code>arr.splice(0, index+1)</code> 的时间复杂度也为 O(n)</strong></p> <p><strong>空间复杂度：O(n)</strong></p> <p>更多解法详见 字节&amp;Leetcode3：无重复字符的最长子串</p> <p>最后，来尝试一道leetcode题目吧！</p> <h3 id="四、leetcode239-滑动窗口最大值问题"><a href="#四、leetcode239-滑动窗口最大值问题" class="header-anchor">#</a> 四、leetcode239：滑动窗口最大值问题</h3> <p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p> <p><strong>示例:</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
</code></pre></div><p><strong>解释:</strong></p> <blockquote><p>滑动窗口的位置         最大值</p> <p>[1  3  -1] -3  5  3  6  7    3</p> <p>1 [3  -1  -3] 5  3  6  7    3</p> <p>1  3 [-1  -3  5] 3  6  7    5</p> <p>1  3  -1 [-3  5  3] 6  7    5</p> <p>1  3  -1  -3 [5  3  6] 7    6</p> <p>1  3  -1  -3  5 [3  6  7]    7</p></blockquote> <p><strong>提示：</strong></p> <p>你可以假设 <code>k</code> 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p> <p>可以自己尝试解答一下，欢迎将答案提交到 https://github.com/sisterAn/JavaScript-Algorithms/issues/33 ，瓶子君将明日解答😊</p> <h3 id="五、往期精彩"><a href="#五、往期精彩" class="header-anchor">#</a> 五、往期精彩</h3> <ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247484444&amp;idx=1&amp;sn=dba5d92f934241059b6f7a827ef212d7&amp;chksm=faec80c4cd9b09d236f046e3a521f7aaf9897c505f818853c85071b2719f22fe89522926a6fb&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">前端进阶算法：常见算法题及完美题解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247484391&amp;idx=1&amp;sn=fd828d06827160b94c69cf4c9e37f545&amp;chksm=faec873fcd9b0e2936ef8b22d082b130605f5ee64c3999ba32121ee0e4e18b6676c44d77060c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">视频面试超高频在线编程题，搞懂这些足以应对大部分公司<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247484417&amp;idx=1&amp;sn=c08cd285e412053dc2c2f1336752c5c9&amp;chksm=faec80d9cd9b09cf266f62dbc5a1b26f5c9f897f6509ed379a20a8333a005b2d8701f6b9bb37&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">前端进阶算法5：全方位解读前端用到的栈结构（+leetcode刷题）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247484298&amp;idx=1&amp;sn=846c8c4117fa0eb5f9a7e66c54b7ae5a&amp;chksm=faec8752cd9b0e44326a3b532ec3e5f57498c83642211c68017dd212f1ddeca53b45b44fe42e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">10 问 10 答，带你快速入门前端算法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247484292&amp;idx=1&amp;sn=c2dfcccab0ed82267061340f969d5de2&amp;chksm=faec875ccd9b0e4a4b1b015785bd439c9ec37ca6882e9b18f66c523e03110e29f1b6d4c57f62&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">前端进阶算法4：链表原来如此简单(+leetcode刷题）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247484265&amp;idx=1&amp;sn=7feafe63a80ce6371a1b6834884a6d05&amp;chksm=faec87b1cd9b0ea7ea773e24341918cefa1df7ccbc2c12c0fee679fcf62d2603f86351f732d1&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">前端进阶算法3：从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247484249&amp;idx=1&amp;sn=0352d8071caac441ff1c5af3260fe484&amp;chksm=faec8781cd9b0e97bfab3b48f51fc9172b2409378f890de8017d5cd2c62bb004ee58fc8d522c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">瓶子君前端算法集训营第一期开营啦，免费哟<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247484213&amp;idx=1&amp;sn=6b7b9cd11b7a151b1b5396c918d7692f&amp;chksm=faec87edcd9b0efb118b006b13b3df234aa3c8a5aa5bcd168cdf07ee3990fee28a5f039baa0f&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">前端进阶算法2：从Chrome  V8源码看JavaScript数组(附赠腾讯面试题)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247484204&amp;idx=1&amp;sn=3433b9191b67ac9b09452b0d6e3a0639&amp;chksm=faec87f4cd9b0ee213f03f451069f4c5fd352cf0c573d043c1819760ef1085a4457af99605a8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">前端进阶算法1：如何分析、统计算法的执行效率和资源消耗？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h3 id="六、前端算法集训营第一期免费加入啦"><a href="#六、前端算法集训营第一期免费加入啦" class="header-anchor">#</a> 六、前端算法集训营第一期免费加入啦</h3> <p>欢迎关注「前端瓶子君」，回复「算法」自动加入，从0到1构建完整的数据结构与算法体系！</p> <p>在这里，瓶子君不仅介绍算法，还将算法与前端各个领域进行结合，包括浏览器、HTTP、V8、React、Vue源码等。</p> <p>在这里，你可以每天学习一道大厂算法题（阿里、腾讯、百度、字节等等）或 leetcode，瓶子君都会在第二天解答哟！</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">5/8/2024, 3:01:19 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/algorithm/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6/" class="prev router-link-active">
        算法进阶
      </a></span> <span class="next"><a href="/algorithm/算法进阶/从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法.html">
        前端进阶算法3：从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.950eebbc.js" defer></script><script src="/assets/js/2.57da4f88.js" defer></script><script src="/assets/js/1.a76cc220.js" defer></script><script src="/assets/js/33.9d15b4c0.js" defer></script>
  </body>
</html>
