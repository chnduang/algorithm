<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>去大厂面试问我算法，我该怎么办？ | duangdong的algorithm</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/logo.png">
    <link rel="manifest" href="/manifest.json">
    <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?0088ce24040b03f2947322ab31d23414";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
    <script>
  var _hmt = _hmt || [];
  _hmt.push(['_requirePlugin', 'UrlChangeTracker', {
    shouldTrackUrlChange: function (newPath, oldPath) {
      newPath = newPath.split('#')[0];
      oldPath = oldPath.split('#')[0];
      return newPath != oldPath;
    }}
  ]);
  </script>
    <meta name="description" content="前端相关知识归纳总结">
    <meta name="keywords" content="qd-blog,node,vuepress,leetcode,algorithm">
    
    <link rel="preload" href="/assets/css/0.styles.b4a844ec.css" as="style"><link rel="preload" href="/assets/js/app.950eebbc.js" as="script"><link rel="preload" href="/assets/js/2.57da4f88.js" as="script"><link rel="preload" href="/assets/js/1.a76cc220.js" as="script"><link rel="preload" href="/assets/js/36.bc299146.js" as="script"><link rel="prefetch" href="/assets/js/10.50f73657.js"><link rel="prefetch" href="/assets/js/11.0390ceee.js"><link rel="prefetch" href="/assets/js/12.f88bec36.js"><link rel="prefetch" href="/assets/js/13.963ad03b.js"><link rel="prefetch" href="/assets/js/14.512f15b9.js"><link rel="prefetch" href="/assets/js/15.a674496c.js"><link rel="prefetch" href="/assets/js/16.ed7e507f.js"><link rel="prefetch" href="/assets/js/17.de667ca5.js"><link rel="prefetch" href="/assets/js/18.b44e84af.js"><link rel="prefetch" href="/assets/js/19.5b5ad6a1.js"><link rel="prefetch" href="/assets/js/20.6800493a.js"><link rel="prefetch" href="/assets/js/21.6589052c.js"><link rel="prefetch" href="/assets/js/22.f648d829.js"><link rel="prefetch" href="/assets/js/23.b85d0d4e.js"><link rel="prefetch" href="/assets/js/24.d81147fb.js"><link rel="prefetch" href="/assets/js/25.ed5233ca.js"><link rel="prefetch" href="/assets/js/26.83f1ef57.js"><link rel="prefetch" href="/assets/js/27.2565321e.js"><link rel="prefetch" href="/assets/js/28.e60083e4.js"><link rel="prefetch" href="/assets/js/29.49b5374e.js"><link rel="prefetch" href="/assets/js/3.13e892f5.js"><link rel="prefetch" href="/assets/js/30.9ad0e230.js"><link rel="prefetch" href="/assets/js/31.c97534c6.js"><link rel="prefetch" href="/assets/js/32.b90554dc.js"><link rel="prefetch" href="/assets/js/33.9d15b4c0.js"><link rel="prefetch" href="/assets/js/34.297b5f45.js"><link rel="prefetch" href="/assets/js/35.029c4cac.js"><link rel="prefetch" href="/assets/js/37.9068edfd.js"><link rel="prefetch" href="/assets/js/38.8c781d87.js"><link rel="prefetch" href="/assets/js/39.87c06c9c.js"><link rel="prefetch" href="/assets/js/4.5bdb9365.js"><link rel="prefetch" href="/assets/js/40.b05763a5.js"><link rel="prefetch" href="/assets/js/41.447511bf.js"><link rel="prefetch" href="/assets/js/42.cef1f724.js"><link rel="prefetch" href="/assets/js/43.cae02230.js"><link rel="prefetch" href="/assets/js/44.833e4694.js"><link rel="prefetch" href="/assets/js/45.2933ab3e.js"><link rel="prefetch" href="/assets/js/46.1108fab7.js"><link rel="prefetch" href="/assets/js/47.1a5b2293.js"><link rel="prefetch" href="/assets/js/48.3f01058a.js"><link rel="prefetch" href="/assets/js/49.24929fd6.js"><link rel="prefetch" href="/assets/js/5.7c68fdb5.js"><link rel="prefetch" href="/assets/js/50.7e052a76.js"><link rel="prefetch" href="/assets/js/51.ae3eb599.js"><link rel="prefetch" href="/assets/js/52.bab65685.js"><link rel="prefetch" href="/assets/js/53.abacf47c.js"><link rel="prefetch" href="/assets/js/54.9d8ffddf.js"><link rel="prefetch" href="/assets/js/55.ac9707fe.js"><link rel="prefetch" href="/assets/js/56.9a9c42d4.js"><link rel="prefetch" href="/assets/js/57.f4d88e89.js"><link rel="prefetch" href="/assets/js/58.816a3870.js"><link rel="prefetch" href="/assets/js/59.8a6b3c7f.js"><link rel="prefetch" href="/assets/js/6.c8da7ca7.js"><link rel="prefetch" href="/assets/js/7.e4c88d0e.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.5143d2e0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b4a844ec.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">duangdong的algorithm</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/algorithm/" class="nav-link router-link-active">
  数据结构
</a></div><div class="nav-item"><a href="/leetcode/" class="nav-link">
  Leetcode
</a></div><div class="nav-item"><a href="/leetcode-summary/" class="nav-link">
  算法题
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/algorithm/" class="nav-link router-link-active">
  数据结构
</a></div><div class="nav-item"><a href="/leetcode/" class="nav-link">
  Leetcode
</a></div><div class="nav-item"><a href="/leetcode-summary/" class="nav-link">
  算法题
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/algorithm/" aria-current="page" class="sidebar-link">算法相关</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端实际项目使用</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/algorithm/动态规划.html" class="sidebar-link">前端也能学算法：由浅入深讲解动态规划</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>排序</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/algorithm/由浅入深讲解贪心算法.html" class="sidebar-link">前端也能学算法：由浅入深讲解贪心算法</a></li><li><a href="/algorithm/简单复习下前端算法复杂度相关的知识.html" class="sidebar-link">简单复习下前端算法复杂度相关的知识</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>算法进阶</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/algorithm/算法进阶/ChromeV8源码看JavaScript数组.html" class="sidebar-link">前端进阶算法2：从Chrome V8源码看JavaScript数组(附赠腾讯面试题)</a></li><li><a href="/algorithm/算法进阶/DIff算法看不懂就一起来锤我.html" class="sidebar-link">DIff算法看不懂就一起来锤我</a></li><li><a href="/algorithm/算法进阶/Diff算法核心原理.html" class="sidebar-link">15张图，20分钟吃透Diff算法核心原理</a></li><li><a href="/algorithm/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6/" aria-current="page" class="sidebar-link">算法进阶</a></li><li><a href="/algorithm/算法进阶/一看就懂的队列及配套算法题.html" class="sidebar-link">前端进阶算法6：一看就懂的队列及配套算法题</a></li><li><a href="/algorithm/算法进阶/从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法.html" class="sidebar-link">前端进阶算法3：从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法</a></li><li><a href="/algorithm/算法进阶/别再说你不懂Top-K问题了.html" class="sidebar-link">别再说你不懂Top K问题了</a></li><li><a href="/algorithm/算法进阶/去大厂面试问我算法.html" class="active sidebar-link">去大厂面试问我算法，我该怎么办？</a></li><li><a href="/algorithm/算法进阶/吊打面试官之数据结构栈.html" class="sidebar-link">前端进阶算法5：吊打面试官之数据结构栈（+leetcode刷题）</a></li><li><a href="/algorithm/算法进阶/堆排序.html" class="sidebar-link">前端进阶算法：看完这篇，再也不怕堆排序、Top K、中位数问题面试了</a></li><li><a href="/algorithm/算法进阶/头条正在面的哈希表问题.html" class="sidebar-link">前端进阶算法：头条正在面的哈希表问题</a></li><li><a href="/algorithm/算法进阶/如何分析-统计算法的执行效率和资源消耗.html" class="sidebar-link">前端进阶算法1：如何分析、统计算法的执行效率和资源消耗？</a></li><li><a href="/algorithm/算法进阶/小白都可以看懂的树与二叉树.html" class="sidebar-link">前端进阶算法7：小白都可以看懂的树与二叉树</a></li><li><a href="/algorithm/算法进阶/带你快速入门前端算法.html" class="sidebar-link">10 问 10 答，带你快速入门前端算法</a></li><li><a href="/algorithm/算法进阶/常见算法题及完美题解.html" class="sidebar-link">前端进阶算法：常见算法题及完美题解</a></li><li><a href="/algorithm/算法进阶/链表原来如此简单.html" class="sidebar-link">前端进阶算法4：链表原来如此简单(+leetcode刷题）</a></li></ul></section></li><li><a href="/algorithm/贪心.html" class="sidebar-link">前端也能学算法：由浅入深讲解贪心算法</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="去大厂面试问我算法-我该怎么办"><a href="#去大厂面试问我算法-我该怎么办" class="header-anchor">#</a> 去大厂面试问我算法，我该怎么办？</h1> <p>原创 前端瓶子君 前端瓶子君 <em>2020-04-18</em></p> <p>收录于话题#前端进阶算法14个</p> <h3 id="引言"><a href="#引言" class="header-anchor">#</a> 引言</h3> <p>现在大厂面试几乎都会问到算法，回答不上来会让你在面试官前大打折扣。前端怎么进阶算法喃？</p> <p>本周是瓶子君前端进阶算法的第三周🎉🎉🎉，这里，会带你 从 0 到 1 构建完整的前端数据结构与算法体系。</p> <p>本周已经不单是简单的链表操作（一般链表的问题可以考虑使用快慢指针），开始涉及五大常用算法策略、二叉树、Trie树、队列等，这里仅作为入门，后面会详细介绍，发散思维，你会发现面试中的算法、开发中的算法真的很 easy。</p> <p><strong>往期精彩系列</strong></p> <ul><li><strong><a href="http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247484298&amp;idx=1&amp;sn=846c8c4117fa0eb5f9a7e66c54b7ae5a&amp;chksm=faec8752cd9b0e44326a3b532ec3e5f57498c83642211c68017dd212f1ddeca53b45b44fe42e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">10问10答，带你快速入门前端算法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></strong></li> <li><strong><a href="http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247484292&amp;idx=1&amp;sn=c2dfcccab0ed82267061340f969d5de2&amp;chksm=faec875ccd9b0e4a4b1b015785bd439c9ec37ca6882e9b18f66c523e03110e29f1b6d4c57f62&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">前端进阶算法4：链表原来如此简单(+leetcode刷题）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></strong></li> <li><strong><a href="http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247484265&amp;idx=1&amp;sn=7feafe63a80ce6371a1b6834884a6d05&amp;chksm=faec87b1cd9b0ea7ea773e24341918cefa1df7ccbc2c12c0fee679fcf62d2603f86351f732d1&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">前端进阶算法3：从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></strong></li> <li><strong><a href="http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247484249&amp;idx=1&amp;sn=0352d8071caac441ff1c5af3260fe484&amp;chksm=faec8781cd9b0e97bfab3b48f51fc9172b2409378f890de8017d5cd2c62bb004ee58fc8d522c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">瓶子君前端算法集训营第一期开营啦，免费哟<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></strong></li> <li><strong><a href="http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247484213&amp;idx=1&amp;sn=6b7b9cd11b7a151b1b5396c918d7692f&amp;chksm=faec87edcd9b0efb118b006b13b3df234aa3c8a5aa5bcd168cdf07ee3990fee28a5f039baa0f&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">前端进阶算法2：从Chrome V8源码看JavaScript数组(附赠腾讯面试题)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></strong></li> <li>**<a href="http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247484204&amp;idx=1&amp;sn=3433b9191b67ac9b09452b0d6e3a0639&amp;chksm=faec87f4cd9b0ee213f03f451069f4c5fd352cf0c573d043c1819760ef1085a4457af99605a8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">前端进阶算法1：如何分析、统计算法的执行效率和资源消耗？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
**</li></ul> <p><strong>以及题目（群内每日一题，瓶子君第二天解答）：</strong></p> <ul><li><strong>图解leetcode88：合并两个有序数组</strong>[1]</li> <li><strong>字节&amp;leetcode1：两数之和</strong>[2]</li> <li><strong>腾讯：数组扁平化、去重、排序</strong>[3]</li> <li><strong>leetcode349：给定两个数组，编写一个函数来计算它们的交集</strong>[4]</li> <li><strong>leetcode146：设计和实现一个LRU（最近最少使用）缓存机制</strong>[5]</li> <li><strong>阿里算法题：编写一个函数计算多个数组的交集</strong>[6]</li> <li><strong>leetcode21：合并两个有序链表</strong>[7]</li> <li><strong>有赞&amp;leetcode141：判断一个单链表是否有环</strong>[8]</li> <li><strong>图解leetcode206：反转链表</strong>[9]</li> <li><strong>leetcode876：求链表的中间结点</strong>[10]</li> <li><strong>leetcode19：删除链表倒数第 n 个结点</strong>[11]</li> <li><strong>图解字节&amp;leetcode160：编写一个程序，找到两个单链表相交的起始节点</strong>[12]</li> <li><strong>图解字节&amp;leetcode151：翻转字符串里的单词</strong>[13]</li> <li><strong>图解leetcode14：最长公共前缀</strong>[14]</li></ul> <p>因微信公众号不支持外链，点击底部「阅读原文」，查看整个系列！</p> <p>本节是第三周的总结与回顾，下面开始进入正题吧！👇👇👇</p> <h3 id="一、图解字节-leetcode14-最长公共前缀"><a href="#一、图解字节-leetcode14-最长公共前缀" class="header-anchor">#</a> 一、图解字节&amp;leetcode14：最长公共前缀</h3> <h4 id="_1-题目"><a href="#_1-题目" class="header-anchor">#</a> 1. 题目</h4> <p>编写一个函数来查找字符串数组中的最长公共前缀。</p> <p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p> <p><strong>示例 1:</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]
输出: &quot;fl&quot;
</code></pre></div><p><strong>示例 2:</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]
输出: &quot;&quot;
解释: 输入不存在公共前缀。
</code></pre></div><h4 id="_2-答案"><a href="#_2-答案" class="header-anchor">#</a> 2. 答案</h4> <h5 id="解法一-逐个比较"><a href="#解法一-逐个比较" class="header-anchor">#</a> 解法一：逐个比较</h5> <p><strong>解题思路：</strong> 从前往后一次比较字符串，获取公共前缀</p> <p><strong>画图帮助理解一下：</strong></p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQITfA6ULXFLqnvsoooBlLjzL8FaNwBnXoV96MCZhWOELZSFfyQxWg0sYTlSW9YcLibQhBzYAndq1g/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"><img src="https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQITfA6ULXFLqnvsoooBlLjZ5CY50SOrt5gD553EX9cfcu16wgBmicw68uKvib0VvZiaq6I6xx5V0TSg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"><img src="https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQITfA6ULXFLqnvsoooBlLjOlGB6Lxc2VNXL6QK7TQ9HeG6sLDE7GVZwvqNibWpOefHowNsv74zz6w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p><strong>代码实现：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>var longestCommonPrefix = function(strs) {
    if (strs === null || strs.length === 0) return &quot;&quot;;
    let prevs = strs[0]
    for(let i = 1; i &lt; strs.length; i++) {
        let j = 0
        for(; j &lt; prevs.length &amp;&amp; j &lt; strs[i].length; j++) {
            if(prevs.charAt(j) !== strs[i].charAt(j)) break
        }
        prevs = prevs.substring(0, j)
        if(prevs === &quot;&quot;) return &quot;&quot;
    }
    return prevs
};
</code></pre></div><p><strong>时间复杂度：O(s)，s 是所有字符串中字符数量的总和</strong></p> <p><strong>空间复杂度：O(1)</strong></p> <h5 id="解法二-仅需最大、最小字符串的最长公共前缀"><a href="#解法二-仅需最大、最小字符串的最长公共前缀" class="header-anchor">#</a> 解法二：仅需最大、最小字符串的最长公共前缀</h5> <p><strong>解题思路：</strong> 获取数组中的最大值及最小值字符串，最小字符串与最大字符串的最长公共前缀也为其他字符串的公共前缀，即为字符串数组的最长公共前缀</p> <p>例如 <code>abc</code> 、 <code>abcd</code> 、<code>ab</code> 、<code>ac</code> ，最小 <code>ab</code> 与最大 <code>ac</code> 的最长公共前缀一定也是 <code>abc</code> 、  <code>abcd</code> 的公共前缀</p> <p><strong>画图帮助理解一下：</strong></p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQITfA6ULXFLqnvsoooBlLj2CWebGpwueEcEXzVABHic05wqrjtyHTFguQ2qWRO4F9S0ksia1YfY3hg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p><strong>代码实现：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>var longestCommonPrefix = function(strs) {
    if (strs === null || strs.length === 0) return &quot;&quot;;
    if(strs.length === 1) return strs[0]
    let min = 0, max = 0
    for(let i = 1; i &lt; strs.length; i++) {
        if(strs[min] &gt; strs[i]) min = i
        if(strs[max] &lt; strs[i]) max = i
    }
    for(let j = 0; j &lt; strs[min].length; j++) {
        if(strs[min].charAt(j) !== strs[max].charAt(j)) {
            return strs[min].substring(0, j)
        }
    }
    return strs[min]
};
</code></pre></div><p><strong>时间复杂度：O(n+m)，n是数组的长度， m 是字符串数组中最短字符的长度</strong></p> <p><strong>空间复杂度：O(1)</strong></p> <h5 id="解法三-分治策略-归并思想"><a href="#解法三-分治策略-归并思想" class="header-anchor">#</a> 解法三：分治策略 归并思想</h5> <p>分治，顾名思义，就是分而治之，将一个复杂的问题，分成两个或多个相似的子问题，在把子问题分成更小的子问题，直到更小的子问题可以简单求解，求解子问题，则原问题的解则为子问题解的合并。</p> <p>这道题就是一个典型的分治策略问题：</p> <ul><li>问题：求多个字符串的最长公共前缀</li> <li>分解成多个相似的子问题：求两个字符串的最长公共前缀</li> <li>子问题可以简单求解：两个字符串的最长公共前缀求解很简单</li> <li>原问题的解为子问题解的合并：多个字符串的最长公共前缀为两两字符串的最长公共前缀的最长公共前缀，我们可以归并比较两最长公共前缀字符串的最长公共前缀，知道最后归并比较成一个，则为字符串数组的最长公共前缀：<code>LCP(S1, S2, ..., Sn) = LCP(LCP(S1, Sk), LCP(Sk+1, Sn))</code></li></ul> <p><strong>画图帮助理解一下：</strong></p> <p>以 <code>abc</code> 、 <code>abcd</code> 、<code>ab</code> 、<code>ac</code> 为例：</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQITfA6ULXFLqnvsoooBlLj7yIOibdzzqSvbiaqaZt5FHTSicLAX2uVEckEAXtgpr3S0WGunE1EmMqjg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p><strong>代码实现：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>var longestCommonPrefix = function(strs) {
    if (strs === null || strs.length === 0) return &quot;&quot;;
    return lCPrefixRec(strs)
};

// 若分裂后的两个数组长度不为 1，则继续分裂
// 直到分裂后的数组长度都为 1，
// 然后比较获取最长公共前缀
function lCPrefixRec(arr) {
  let length = arr.length
  if(length === 1) {
    return arr[0]
  }
  let mid = Math.floor(length / 2),
      left = arr.slice(0, mid),
      right = arr.slice(mid, length)
  return lCPrefixTwo(lCPrefixRec(left), lCPrefixRec(right))
}

// 求 str1 与 str2 的最长公共前缀
function lCPrefixTwo(str1, str2) {
    let j = 0
    for(; j &lt; str1.length &amp;&amp; j &lt; str2.length; j++) {
        if(str1.charAt(j) !== str2.charAt(j)) {
            break
        }
    }
    return str1.substring(0, j)
}
</code></pre></div><p><strong>时间复杂度：O(s)，s 是所有字符串中字符数量的总和</strong></p> <p><strong>空间复杂度：O(m*logn)，n是数组的长度，m为字符串数组中最长字符的长度</strong></p> <h5 id="解法四-trie-树-字典树"><a href="#解法四-trie-树-字典树" class="header-anchor">#</a> 解法四：Trie 树（字典树）</h5> <p>Trie 树，也称为字典树或前缀树，顾名思义，它是用来处理字符串匹配问题的数据结构，以及用来解决集合中查找固定前缀字符串的数据结构。</p> <p><strong>解题思路：</strong> 构建一个 Trie 树，字符串数组的最长公共序列就为从根节点开始遍历树，直到：</p> <ul><li>遍历节点存在超过一个子节点的节点</li> <li>或遍历节点为一个字符串的结束字符</li></ul> <p>为止，走过的字符为字符串数组的最长公共前缀</p> <p><strong>画图帮助理解一下：</strong></p> <p>构建一个 Trie 树，以 <code>abc</code> 、 <code>abcd</code> 、<code>ab</code> 、<code>ac</code> 为例：</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQITfA6ULXFLqnvsoooBlLjfkjZ7tEol0phdqWVU24KTUoQFf2cxG2WaP8oMy8Y1psX4jawiaKUDsg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p><strong>代码实现：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>var longestCommonPrefix = function(strs) {
    if (strs === null || strs.length === 0) return &quot;&quot;;
    // 初始化 Trie 树
    let trie = new Trie()
    // 构建 Trie 树
    for(let i = 0; i &lt; strs.length; i++) {
        if(!trie.insert(strs[i])) return &quot;&quot;
    }
    // 返回最长公共前缀
    return trie.searchLongestPrefix()
};
// Trie 树
var Trie = function() {
    this.root = new TrieNode()
};
var TrieNode = function() {
    // next 放入当前节点的子节点
    this.next = {};
    // 当前是否是结束节点
    this.isEnd = false;
};
Trie.prototype.insert = function(word) {
    if (!word) return false
    let node = this.root
    for (let i = 0; i &lt; word.length; i++) {
        if (!node.next[word[i]]) {
            node.next[word[i]] = new TrieNode()
        }
        node = node.next[word[i]]
    }
    node.isEnd = true
    return true
};
Trie.prototype.searchLongestPrefix = function() {
    let node = this.root
    let prevs = ''
    while(node.next) {
        let keys = Object.keys(node.next)
        if(keys.length !== 1) break
        if(node.next[keys[0]].isEnd) {
            prevs += keys[0]
            break
        }
        prevs += keys[0]
        node = node.next[keys[0]]
    }
    return prevs
}
</code></pre></div><p><strong>时间复杂度：O(s+m)，s 是所有字符串中字符数量的总和，m为字符串数组中最长字符的长度，构建 Trie 树需要 O(s) ，最长公共前缀查询操作的复杂度为 O(m)</strong></p> <p><strong>空间复杂度：O(s)，用于构建 Trie 树</strong></p> <p><strong>leetcode</strong>[15]</p> <h4 id="_3-更多解法请看-图解字节-leetcode14-最长公共前缀-16"><a href="#_3-更多解法请看-图解字节-leetcode14-最长公共前缀-16" class="header-anchor">#</a> 3. 更多解法请看 图解字节&amp;leetcode14：最长公共前缀[16]</h4> <h3 id="二、图解字节-leetcode151-翻转字符串里的单词"><a href="#二、图解字节-leetcode151-翻转字符串里的单词" class="header-anchor">#</a> 二、图解字节&amp;leetcode151：翻转字符串里的单词</h3> <h4 id="_1-题目-2"><a href="#_1-题目-2" class="header-anchor">#</a> 1. 题目</h4> <p>给定一个字符串，逐个翻转字符串中的每个单词。</p> <p><strong>示例 1：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入: &quot;the sky is blue&quot;
输出: &quot;blue is sky the&quot;
</code></pre></div><p><strong>示例 2：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入: &quot;  hello world!  &quot;
输出: &quot;world! hello&quot;
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
</code></pre></div><p><strong>示例 3：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入: &quot;a good   example&quot;
输出: &quot;example good a&quot;
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
</code></pre></div><p><strong>说明：</strong></p> <ul><li>无空格字符构成一个单词。</li> <li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li> <li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li></ul> <h4 id="_2-答案-2"><a href="#_2-答案-2" class="header-anchor">#</a> 2. 答案</h4> <h5 id="解法一-正则-js-api"><a href="#解法一-正则-js-api" class="header-anchor">#</a> 解法一：正则 + JS API</h5> <div class="language- extra-class"><pre class="language-text"><code>var reverseWords = function(s) {
    return s.trim().replace(/\s+/g, ' ').split(' ').reverse().join(' ')
};
</code></pre></div><h5 id="解法二-双端队列-不使用-api"><a href="#解法二-双端队列-不使用-api" class="header-anchor">#</a> 解法二：双端队列（不使用 API）</h5> <p>双端队列，故名思义就是两端都可以进队的队列</p> <p><strong>解题思路：</strong></p> <ul><li>首先去除字符串左右空格</li> <li>逐个读取字符串中的每个单词，依次放入双端队列的对头</li> <li>再将队列转换成字符串输出（已空格为分隔符）</li></ul> <p><strong>画图理解：</strong></p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQITfA6ULXFLqnvsoooBlLjDibmANDVfdicXAR7l4UrvPfBLwcicNXTZMv9Dxm4swhmicBSsLrPv1NtXg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQITfA6ULXFLqnvsoooBlLjUnBJ3TKV33rKWAacib7LXS4icQ8dE4rPNa8AacKrxK24eW9bic0icnwxBg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQITfA6ULXFLqnvsoooBlLjjibo0fdz6UMibbrZ8oupBBQWRZwNibsfqNnOQOF2uA3NBmdu4FzWuN5SA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p><strong>代码实现：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>var reverseWords = function(s) {
    let left = 0
    let right = s.length - 1
    let queue = []
    let word = ''
    while (s.charAt(left) === ' ') left ++
    while (s.charAt(right) === ' ') right --
    while (left &lt;= right) {
        let char = s.charAt(left)
        if (char === ' ' &amp;&amp; word) {
            queue.unshift(word)
            word = ''
        } else if (char !== ' '){
            word += char
        }
        left++
    }
    queue.unshift(word)
    return queue.join(' ')
};
</code></pre></div><p><strong>leetcode</strong>[17]</p> <h4 id="_3-更多解法请看-图解字节-leetcode151-翻转字符串里的单词-18"><a href="#_3-更多解法请看-图解字节-leetcode151-翻转字符串里的单词-18" class="header-anchor">#</a> 3. 更多解法请看 图解字节&amp;leetcode151：翻转字符串里的单词[18]</h4> <h3 id="三、图解字节-leetcode160-编写一个程序-找到两个单链表相交的起始节点"><a href="#三、图解字节-leetcode160-编写一个程序-找到两个单链表相交的起始节点" class="header-anchor">#</a> 三、图解字节&amp;leetcode160：编写一个程序，找到两个单链表相交的起始节点</h3> <h4 id="_1-题目-3"><a href="#_1-题目-3" class="header-anchor">#</a> 1. 题目</h4> <p>编写一个程序，找到两个单链表相交的起始节点。</p> <p>如下面的两个链表：</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQITfA6ULXFLqnvsoooBlLjFGibiaAt794fhicoYwtJMjODpGTDghiadSnXroXp3ibggD1zAFFRIRTtKwQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p>在节点 c1 开始相交。</p> <p><strong>示例 1：</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <div class="language- extra-class"><pre class="language-text"><code>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
</code></pre></div><p><strong>示例 2：</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <div class="language- extra-class"><pre class="language-text"><code>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
</code></pre></div><p><strong>示例 3：</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <div class="language- extra-class"><pre class="language-text"><code>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。
</code></pre></div><p><strong>注意：</strong></p> <ul><li>如果两个链表没有交点，返回 null.</li> <li>在返回结果后，两个链表仍须保持原有的结构。</li> <li>可假定整个链表结构中没有循环。</li> <li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</li></ul> <h4 id="_2-答案-3"><a href="#_2-答案-3" class="header-anchor">#</a> 2. 答案</h4> <h5 id="解法一-标记法-简单但空间复杂度为o-n-不符合-仅做参考"><a href="#解法一-标记法-简单但空间复杂度为o-n-不符合-仅做参考" class="header-anchor">#</a> 解法一：标记法(简单但空间复杂度为O(n)，不符合，仅做参考)</h5> <p><strong>解题思路：</strong> 两次遍历，先遍历一个链表，给链表中的每个节点都增加一个标志位，然后遍历另外一个链表，遍历到第一个已被标志过的节点为两链表相交的起始节点。</p> <p>若遍历完都没有发现已被标志过的节点，则两链表不相交，返回 <code>null</code></p> <div class="language- extra-class"><pre class="language-text"><code>var getIntersectionNode = function(headA, headB) {
    while(headA) {
        headA.flag = true
        headA = headA.next
    }
    while(headB) {
        if (headB.flag) return headB
        headB = headB.next
    }
    return null
};
</code></pre></div><p><strong>时间复杂度：O(n)</strong></p> <p><strong>空间复杂度：O(n)</strong></p> <h5 id="解法二-双指针法"><a href="#解法二-双指针法" class="header-anchor">#</a> 解法二：双指针法</h5> <p><strong>解题思路：</strong> 如果 A、B 两链表相交，则 A 、B 自相交点往后的链表是一致的。</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>我们可以尝试消除 A、B 链表的长度差，同步遍历上图中的方框里的节点，判断是否有相同节点，若有相同则是两链表相交，返回第一个相同节点 即可。否则返回 <code>null</code> ，两链表不相交。</p> <p><strong>解题步骤：</strong></p> <ul><li>同步遍历 A、B 链表 <code>pA</code> 、 <code>pB</code> ，直到遍历完其中一个链表（短链表），如上图，设A为长链表</li> <li>那么此时 A、B 两遍表的长度差就为 <code>pA</code> 到链尾的长度，此时可以把 <code>pB</code> 指向长链表的表头 <code>headA</code> ，继续同步遍历，直到遍历完长链表</li> <li>此时，<code>headA</code> 到 <code>pB</code> 的长度就为两链表的长度差，<code>pB</code> 到链表的长度与 <code>headB</code> 到链尾的长度一致</li> <li>此时，可将 <code>pA</code> 指向 <code>headB</code> ，然后同步遍历 <code>pB</code> 及 <code>pA</code> ，直到有相交节点，返回相交节点，否则返回 <code>null</code></li></ul> <p><strong>画图帮助理解：</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <div class="language- extra-class"><pre class="language-text"><code>var getIntersectionNode = function(headA, headB) {
    // 清除高度差
    let pA = headA, pB = headB
    while(pA || pB) {
        if(pA === pB) return pA
        pA = pA === null ? headB : pA.next
        pB = pB === null ? headA : pB.next
    }
    return null
};
</code></pre></div><p><strong>时间复杂度：O(n)</strong></p> <p><strong>空间复杂度：O(1)</strong></p> <p><strong>leetcode</strong>[19]</p> <h4 id="_3-更多解法请看-图解字节-leetcode160-编写一个程序-找到两个单链表相交的起始节点-20"><a href="#_3-更多解法请看-图解字节-leetcode160-编写一个程序-找到两个单链表相交的起始节点-20" class="header-anchor">#</a> 3. 更多解法请看 图解字节&amp;leetcode160：编写一个程序，找到两个单链表相交的起始节点[20]</h4> <h3 id="四、leetcode19-删除链表倒数第-n-个结点"><a href="#四、leetcode19-删除链表倒数第-n-个结点" class="header-anchor">#</a> 四、leetcode19：删除链表倒数第 n 个结点</h3> <h4 id="_1-题目-4"><a href="#_1-题目-4" class="header-anchor">#</a> 1. 题目</h4> <p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p> <p><strong>示例：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.
当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.
</code></pre></div><p><strong>说明：</strong></p> <p>给定的 n 保证是有效的。</p> <p><strong>进阶：</strong></p> <p>你能尝试使用一趟扫描实现吗？</p> <h4 id="_2-解法-快慢指针"><a href="#_2-解法-快慢指针" class="header-anchor">#</a> 2. 解法：快慢指针</h4> <p><strong>解题思路：</strong> 需要删除链表中的倒数第 <code>n</code> 个节点，我们需要知道的就是倒数第 <code>n+1</code> 个节点，然后删除删除倒数第 <code>n+1</code> 节点的后继节点即可</p> <p><strong>步骤：</strong></p> <p>使用 2 个指针：</p> <ul><li><code>fast</code> 快指针提前走 <code>n+1</code> 步</li> <li><code>slow</code> 指针指向当前距离 <code>fast</code> 倒数第 <code>n</code> 个节点， 初始为 <code>head</code></li></ul> <p>然后， <code>fast</code> 、 <code>slow</code> 同步向前走，直到 <code>fast.next</code> 为 <code>null</code></p> <p>此时，<code>fast</code> 为最后一个节点，<code>slow</code> 就是倒数第 <code>n+1</code> 个节点，此时问题就变更为删除链表中的 <code>slow</code> 的后继节点</p> <p>但存在一个问题，当链表长度为 <code>n</code> 时，<code>fast</code> 是前进不到 <code>n+1</code> 个节点位置的，所以此时有两种解决思路：</p> <ul><li>创建一个头节点 <code>preHead</code> ，设置 <code>preHead.next = head</code> ，这样就可以解决以上问题，删除倒数第 <code>n</code> 个节点后，返回的 <code>preHead.next</code> 即可</li> <li>另外一种是，<code>fast</code> 快指针提前走 <code>n</code> 步后，判断 <code>fast.next</code> 是否为 <code>null</code> ，即 <code>fast</code>是否是最后一个节点，如果是，则 <code>head</code> 为倒数第 <code>n</code> 个节点，此时问题可以简化为删除头节点；如果不是， <code>fast = fast.next</code> ，<code>fast</code> 再前进一步，<code>slow</code> 为倒数第 <code>n+1</code> 个节点，也解决了以上问题。</li></ul> <h5 id="解决方案一-添加-prehead-节点"><a href="#解决方案一-添加-prehead-节点" class="header-anchor">#</a> 解决方案一：添加 <code>preHead</code> 节点</h5> <div class="language- extra-class"><pre class="language-text"><code>var removeNthFromEnd = function(head, n) {
    let preHead = new ListNode(0)
    preHead.next = head
    let fast = preHead, slow = preHead
    // 快先走 n+1 步
    while(n--) {
        fast = fast.next
    }
    // fast、slow 一起前进
    while(fast &amp;&amp; fast.next) {
        fast = fast.next
        slow = slow.next
    }
    slow.next = slow.next.next
    return preHead.next
};
</code></pre></div><h5 id="解决方案二-单独处理倒数第-n-节点"><a href="#解决方案二-单独处理倒数第-n-节点" class="header-anchor">#</a> 解决方案二：单独处理倒数第 <code>n</code> 节点</h5> <div class="language- extra-class"><pre class="language-text"><code>var removeNthFromEnd = function(head, n) {
    let fast = head, slow = head
    // 快先走 n 步
    while(--n) {
        fast = fast.next
    }
    if(!fast.next) return head.next
    fast = fast.next
    // fast、slow 一起前进
    while(fast &amp;&amp; fast.next) {
        fast = fast.next
        slow = slow.next
    }
    slow.next = slow.next.next
    return head
};
</code></pre></div><p><strong>时间复杂度：O(n)</strong></p> <p><strong>空间复杂度：O(1)</strong></p> <p><strong>leetcode</strong>[21]</p> <h4 id="_3-更多解法请看-leetcode19-删除链表倒数第-n-个结点-22"><a href="#_3-更多解法请看-leetcode19-删除链表倒数第-n-个结点-22" class="header-anchor">#</a> 3. 更多解法请看 leetcode19：删除链表倒数第 n 个结点[22]</h4> <h3 id="五、leetcode876-求链表的中间结点"><a href="#五、leetcode876-求链表的中间结点" class="header-anchor">#</a> 五、leetcode876：求链表的中间结点</h3> <h4 id="_1-题目-5"><a href="#_1-题目-5" class="header-anchor">#</a> 1. 题目</h4> <p>给定一个带有头结点 <code>head</code> 的非空单链表，返回链表的中间结点。</p> <p>如果有两个中间结点，则返回第二个中间结点。</p> <p><strong>示例 1：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入：[1,2,3,4,5]
输出：此列表中的结点 3 (序列化形式：[3,4,5])
返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。

注意，我们返回了一个 ListNode 类型的对象 ans，这样：
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.
</code></pre></div><p><strong>示例 2：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入：[1,2,3,4,5,6]
输出：此列表中的结点 4 (序列化形式：[4,5,6])

由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。
</code></pre></div><p><strong>提示：</strong></p> <p>给定链表的结点数介于 1 和 100 之间。</p> <h4 id="_2-解法-快慢指针-2"><a href="#_2-解法-快慢指针-2" class="header-anchor">#</a> 2. 解法：快慢指针</h4> <p><strong>解题思路：</strong> 快指针一次走两步，慢指针一次走一步，当快指针走到终点时，慢指针刚好走到中间</p> <div class="language- extra-class"><pre class="language-text"><code>var middleNode = function(head) {
    let fast = head, slow = head
    while(fast &amp;&amp; fast.next) {
        slow = slow.next
        fast = fast.next.next
    }
    return slow
};
</code></pre></div><p><strong>时间复杂度：O(n)</strong></p> <p><strong>空间复杂度：O(1)</strong></p> <p><strong>leetcode</strong>[23]</p> <h4 id="_3-更多解法请看-leetcode876-求链表的中间结点-24"><a href="#_3-更多解法请看-leetcode876-求链表的中间结点-24" class="header-anchor">#</a> 3. 更多解法请看 leetcode876：求链表的中间结点[24]</h4> <h3 id="六、图解leetcode206-反转链表"><a href="#六、图解leetcode206-反转链表" class="header-anchor">#</a> 六、图解leetcode206：反转链表</h3> <h4 id="_1-题目-6"><a href="#_1-题目-6" class="header-anchor">#</a> 1. 题目</h4> <p><strong>示例:</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
</code></pre></div><p>**进阶:**你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p> <h4 id="_2-答案-4"><a href="#_2-答案-4" class="header-anchor">#</a> 2. 答案</h4> <h5 id="解法一-迭代法"><a href="#解法一-迭代法" class="header-anchor">#</a> 解法一：迭代法</h5> <p><strong>解题思路：</strong> 将单链表中的每个节点的后继指针指向它的前驱节点即可</p> <p><strong>画图实现：</strong> 画图帮助理解一下</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p><strong>确定边界条件：</strong> 当链表为 <code>null</code> 或链表中仅有一个节点时，不需要反转</p> <p><strong>代码实现：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>var reverseList = function(head) {
    if(!head || !head.next) return head
    var prev = null, curr = head
    while(curr) {
        // 用于临时存储 curr 后继节点
        var next = curr.next
        // 反转 curr 的后继指针
        curr.next = prev
        // 变更prev、curr 
        // 待反转节点指向下一个节点 
        prev = curr
        curr = next
    }
    head = prev
    return head
};
</code></pre></div><p><strong>时间复杂度：O(n)</strong></p> <p><strong>空间复杂度：O(1)</strong></p> <h5 id="解法二-尾递归法"><a href="#解法二-尾递归法" class="header-anchor">#</a> 解法二：尾递归法</h5> <p><strong>解题思路：</strong> 从头节点开始，递归反转它的每一个节点，直到 <code>null</code> ，思路和解法一类似</p> <p><strong>代码实现：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>var reverseList = function(head) {
    if(!head || !head.next) return head
    head = reverse(null, head)
    return head
};

var reverse = function(prev, curr) {
    if(!curr) return prev
    var next = curr.next
    curr.next = prev
    return reverse(curr, next)
};
</code></pre></div><p><strong>时间复杂度：O(n)</strong></p> <p><strong>空间复杂度：O(n)</strong></p> <h5 id="解法三-递归法"><a href="#解法三-递归法" class="header-anchor">#</a> 解法三：递归法</h5> <p><strong>解题思路：</strong> 不断递归反转当前节点 <code>head</code> 的后继节点 <code>next</code></p> <p><strong>画图实现：</strong> 画图帮助理解一下</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p><strong>代码实现：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>var reverseList = function(head) {
    if(!head || !head.next) return head
    var next = head.next
    // 递归反转
    var reverseHead = reverseList(next)
    // 变更指针
    next.next = head
    head.next = null
    return reverseHead
};
</code></pre></div><p><strong>时间复杂度：O(n)</strong></p> <p><strong>空间复杂度：O(n)</strong></p> <p><strong>leetcode</strong>[25]</p> <h4 id="_3-更多解法请看-leetcode206-反转链表-26"><a href="#_3-更多解法请看-leetcode206-反转链表-26" class="header-anchor">#</a> 3. 更多解法请看 leetcode206：反转链表[26]</h4> <h3 id="七、前端算法集训营第一期免费加入啦"><a href="#七、前端算法集训营第一期免费加入啦" class="header-anchor">#</a> 七、前端算法集训营第一期免费加入啦</h3> <p>快来加入我们吧，在这里从0到1构建完整的数据结构与算法体系！</p> <p>在这里，瓶子君不仅介绍算法，还将算法与前端各个领域进行结合，包括浏览器、HTTP、V8、React、Vue源码等。</p> <p>在这里，你可以每天学习一道大厂算法题（阿里、腾讯、百度、字节等等）或 leetcode，瓶子君都会在第二天解答哟！</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">5/8/2024, 3:01:19 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/algorithm/算法进阶/别再说你不懂Top-K问题了.html" class="prev">
        别再说你不懂Top K问题了
      </a></span> <span class="next"><a href="/algorithm/算法进阶/吊打面试官之数据结构栈.html">
        前端进阶算法5：吊打面试官之数据结构栈（+leetcode刷题）
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.950eebbc.js" defer></script><script src="/assets/js/2.57da4f88.js" defer></script><script src="/assets/js/1.a76cc220.js" defer></script><script src="/assets/js/36.bc299146.js" defer></script>
  </body>
</html>
