<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端进阶算法2：从Chrome V8源码看JavaScript数组(附赠腾讯面试题) | duangdong的algorithm</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/logo.png">
    <link rel="manifest" href="/manifest.json">
    <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?0088ce24040b03f2947322ab31d23414";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
    <script>
  var _hmt = _hmt || [];
  _hmt.push(['_requirePlugin', 'UrlChangeTracker', {
    shouldTrackUrlChange: function (newPath, oldPath) {
      newPath = newPath.split('#')[0];
      oldPath = oldPath.split('#')[0];
      return newPath != oldPath;
    }}
  ]);
  </script>
    <meta name="description" content="前端相关知识归纳总结">
    <meta name="keywords" content="qd-blog,node,vuepress,leetcode,algorithm">
    
    <link rel="preload" href="/assets/css/0.styles.b4a844ec.css" as="style"><link rel="preload" href="/assets/js/app.950eebbc.js" as="script"><link rel="preload" href="/assets/js/2.57da4f88.js" as="script"><link rel="preload" href="/assets/js/1.a76cc220.js" as="script"><link rel="preload" href="/assets/js/29.49b5374e.js" as="script"><link rel="prefetch" href="/assets/js/10.50f73657.js"><link rel="prefetch" href="/assets/js/11.0390ceee.js"><link rel="prefetch" href="/assets/js/12.f88bec36.js"><link rel="prefetch" href="/assets/js/13.963ad03b.js"><link rel="prefetch" href="/assets/js/14.512f15b9.js"><link rel="prefetch" href="/assets/js/15.a674496c.js"><link rel="prefetch" href="/assets/js/16.ed7e507f.js"><link rel="prefetch" href="/assets/js/17.de667ca5.js"><link rel="prefetch" href="/assets/js/18.b44e84af.js"><link rel="prefetch" href="/assets/js/19.5b5ad6a1.js"><link rel="prefetch" href="/assets/js/20.6800493a.js"><link rel="prefetch" href="/assets/js/21.6589052c.js"><link rel="prefetch" href="/assets/js/22.f648d829.js"><link rel="prefetch" href="/assets/js/23.b85d0d4e.js"><link rel="prefetch" href="/assets/js/24.d81147fb.js"><link rel="prefetch" href="/assets/js/25.ed5233ca.js"><link rel="prefetch" href="/assets/js/26.83f1ef57.js"><link rel="prefetch" href="/assets/js/27.2565321e.js"><link rel="prefetch" href="/assets/js/28.e60083e4.js"><link rel="prefetch" href="/assets/js/3.13e892f5.js"><link rel="prefetch" href="/assets/js/30.9ad0e230.js"><link rel="prefetch" href="/assets/js/31.c97534c6.js"><link rel="prefetch" href="/assets/js/32.b90554dc.js"><link rel="prefetch" href="/assets/js/33.9d15b4c0.js"><link rel="prefetch" href="/assets/js/34.297b5f45.js"><link rel="prefetch" href="/assets/js/35.029c4cac.js"><link rel="prefetch" href="/assets/js/36.bc299146.js"><link rel="prefetch" href="/assets/js/37.9068edfd.js"><link rel="prefetch" href="/assets/js/38.8c781d87.js"><link rel="prefetch" href="/assets/js/39.87c06c9c.js"><link rel="prefetch" href="/assets/js/4.5bdb9365.js"><link rel="prefetch" href="/assets/js/40.b05763a5.js"><link rel="prefetch" href="/assets/js/41.447511bf.js"><link rel="prefetch" href="/assets/js/42.cef1f724.js"><link rel="prefetch" href="/assets/js/43.cae02230.js"><link rel="prefetch" href="/assets/js/44.833e4694.js"><link rel="prefetch" href="/assets/js/45.2933ab3e.js"><link rel="prefetch" href="/assets/js/46.1108fab7.js"><link rel="prefetch" href="/assets/js/47.1a5b2293.js"><link rel="prefetch" href="/assets/js/48.3f01058a.js"><link rel="prefetch" href="/assets/js/49.24929fd6.js"><link rel="prefetch" href="/assets/js/5.7c68fdb5.js"><link rel="prefetch" href="/assets/js/50.7e052a76.js"><link rel="prefetch" href="/assets/js/51.ae3eb599.js"><link rel="prefetch" href="/assets/js/52.bab65685.js"><link rel="prefetch" href="/assets/js/53.abacf47c.js"><link rel="prefetch" href="/assets/js/54.9d8ffddf.js"><link rel="prefetch" href="/assets/js/55.ac9707fe.js"><link rel="prefetch" href="/assets/js/56.9a9c42d4.js"><link rel="prefetch" href="/assets/js/57.f4d88e89.js"><link rel="prefetch" href="/assets/js/58.816a3870.js"><link rel="prefetch" href="/assets/js/59.8a6b3c7f.js"><link rel="prefetch" href="/assets/js/6.c8da7ca7.js"><link rel="prefetch" href="/assets/js/7.e4c88d0e.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.5143d2e0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b4a844ec.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">duangdong的algorithm</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/algorithm/" class="nav-link router-link-active">
  数据结构
</a></div><div class="nav-item"><a href="/leetcode/" class="nav-link">
  Leetcode
</a></div><div class="nav-item"><a href="/leetcode-summary/" class="nav-link">
  算法题
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/algorithm/" class="nav-link router-link-active">
  数据结构
</a></div><div class="nav-item"><a href="/leetcode/" class="nav-link">
  Leetcode
</a></div><div class="nav-item"><a href="/leetcode-summary/" class="nav-link">
  算法题
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/algorithm/" aria-current="page" class="sidebar-link">算法相关</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端实际项目使用</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/algorithm/动态规划.html" class="sidebar-link">前端也能学算法：由浅入深讲解动态规划</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>排序</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/algorithm/由浅入深讲解贪心算法.html" class="sidebar-link">前端也能学算法：由浅入深讲解贪心算法</a></li><li><a href="/algorithm/简单复习下前端算法复杂度相关的知识.html" class="sidebar-link">简单复习下前端算法复杂度相关的知识</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>算法进阶</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/algorithm/算法进阶/ChromeV8源码看JavaScript数组.html" class="active sidebar-link">前端进阶算法2：从Chrome V8源码看JavaScript数组(附赠腾讯面试题)</a></li><li><a href="/algorithm/算法进阶/DIff算法看不懂就一起来锤我.html" class="sidebar-link">DIff算法看不懂就一起来锤我</a></li><li><a href="/algorithm/算法进阶/Diff算法核心原理.html" class="sidebar-link">15张图，20分钟吃透Diff算法核心原理</a></li><li><a href="/algorithm/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6/" aria-current="page" class="sidebar-link">算法进阶</a></li><li><a href="/algorithm/算法进阶/一看就懂的队列及配套算法题.html" class="sidebar-link">前端进阶算法6：一看就懂的队列及配套算法题</a></li><li><a href="/algorithm/算法进阶/从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法.html" class="sidebar-link">前端进阶算法3：从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法</a></li><li><a href="/algorithm/算法进阶/别再说你不懂Top-K问题了.html" class="sidebar-link">别再说你不懂Top K问题了</a></li><li><a href="/algorithm/算法进阶/去大厂面试问我算法.html" class="sidebar-link">去大厂面试问我算法，我该怎么办？</a></li><li><a href="/algorithm/算法进阶/吊打面试官之数据结构栈.html" class="sidebar-link">前端进阶算法5：吊打面试官之数据结构栈（+leetcode刷题）</a></li><li><a href="/algorithm/算法进阶/堆排序.html" class="sidebar-link">前端进阶算法：看完这篇，再也不怕堆排序、Top K、中位数问题面试了</a></li><li><a href="/algorithm/算法进阶/头条正在面的哈希表问题.html" class="sidebar-link">前端进阶算法：头条正在面的哈希表问题</a></li><li><a href="/algorithm/算法进阶/如何分析-统计算法的执行效率和资源消耗.html" class="sidebar-link">前端进阶算法1：如何分析、统计算法的执行效率和资源消耗？</a></li><li><a href="/algorithm/算法进阶/小白都可以看懂的树与二叉树.html" class="sidebar-link">前端进阶算法7：小白都可以看懂的树与二叉树</a></li><li><a href="/algorithm/算法进阶/带你快速入门前端算法.html" class="sidebar-link">10 问 10 答，带你快速入门前端算法</a></li><li><a href="/algorithm/算法进阶/常见算法题及完美题解.html" class="sidebar-link">前端进阶算法：常见算法题及完美题解</a></li><li><a href="/algorithm/算法进阶/链表原来如此简单.html" class="sidebar-link">前端进阶算法4：链表原来如此简单(+leetcode刷题）</a></li></ul></section></li><li><a href="/algorithm/贪心.html" class="sidebar-link">前端也能学算法：由浅入深讲解贪心算法</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="前端进阶算法2-从chrome-v8源码看javascript数组-附赠腾讯面试题"><a href="#前端进阶算法2-从chrome-v8源码看javascript数组-附赠腾讯面试题" class="header-anchor">#</a> 前端进阶算法2：从Chrome V8源码看JavaScript数组(附赠腾讯面试题)</h1> <p>原创 前端瓶子君 前端瓶子君 <em>2020-04-02</em></p> <h3 id="简介"><a href="#简介" class="header-anchor">#</a> 简介</h3> <p>数组、链表、栈、队列都是线性表，它表示的结构都是一段线性的结构，与之对应的就是非线性表，例如树、图、堆等，它表示的结构都非线性。</p> <p>本节主要介绍 JavaScript 数组，在开始本章节前，思考一个问题：</p> <p>我们知道在 JavaScript 中，可以在数组中保存不同类型值，并且数组可以动态增长，不像其它语言，例如 C，创建的时候要决定数组的大小，如果数组满了，就要重新申请内存空间。这是为什么喃？</p> <p>本节从 Chrome v8 源码角度回答这个问题，分为四个方面：</p> <ul><li>数组基础入门</li> <li>JavaScript 中，数组为什么可以保存不同类型？</li> <li>JavaScript 中，数组是如何存储的喃？</li> <li>JavaScript 中，数组的动态扩容与减容（ <code>FastElements</code> ）</li></ul> <p>下面进入正题吧！（文末有惊喜）😊</p> <p>想要更多更快的学习本系列，可以关注公众号「前端瓶子君」和我的「Github：https://github.com/sisterAn/JavaScript-Algorithms」</p> <h3 id="一、数组-基础"><a href="#一、数组-基础" class="header-anchor">#</a> 一、数组（基础）</h3> <p>一种最基础的数据结构，每种编程语言都有，它编号从 0 开始，代表一组连续的储存结构，用来储存同一种类型的数据。</p> <div class="language- extra-class"><pre class="language-text"><code>let arr = [1, 2, 3]
</code></pre></div><p>它的这种特定的存储结构（连续存储空间存储同一类型数据）决定了：</p> <p><strong>优点</strong></p> <ul><li>随机访问：可以通过下标随机访问数组中的任意位置上的数据</li></ul> <p><strong>缺点</strong></p> <ul><li>对数据的删除和插入不是很友好</li></ul> <p><strong>查找：</strong> 根据下标随机访问的时间复杂度为 O(1)；</p> <p><strong>插入或删除：</strong> 时间复杂度为 O(n)；</p> <p>在 JavaScript 中的数组几乎是万能的，它不光可以作为一个普通的数组使用，可以作为栈或队列使用。</p> <p>数组：</p> <div class="language- extra-class"><pre class="language-text"><code>let array = [1, 2, 3]
</code></pre></div><p>栈：</p> <div class="language- extra-class"><pre class="language-text"><code>let stack = [1, 2, 3]
// 进栈
stack.push(4)
// 出栈
stcak.pop()
</code></pre></div><p>队列：</p> <div class="language- extra-class"><pre class="language-text"><code>let queue = [1, 2, 3]
// 进队
queue.push(4)
// 出队
queue.shift()
</code></pre></div><h3 id="二、javascript-中-数组可以保存不同类型值"><a href="#二、javascript-中-数组可以保存不同类型值" class="header-anchor">#</a> 二、JavaScript 中，数组可以保存不同类型值</h3> <p>看一下 Chrome v8 源码：</p> <div class="language- extra-class"><pre class="language-text"><code>// The JSArray describes JavaScript Arrays
//  Such an array can be in one of two modes:
//    - fast, backing storage is a FixedArray and length &lt;= elements.length();
//       Please note: push and pop can be used to grow and shrink the array.
//    - slow, backing storage is a HashTable with numbers as keys.
class JSArray: public JSObject {
 public:
  // [length]: The length property.
  DECL_ACCESSORS(length, Object)
    
  // ...
   
  // Number of element slots to pre-allocate for an empty array.
  static const int kPreallocatedArrayElements = 4;
};
</code></pre></div><p>我们可以看到 <code>JSArray</code> 是继承自 <code>JSObject</code> 的，所以在 JavaScript 中，数组可以是一个特殊的对象，内部也是以 key-value 形式存储数据，所以 JavaScript 中的数组可以存放不同类型的值。</p> <h3 id="三、javascript-中-数组的存储"><a href="#三、javascript-中-数组的存储" class="header-anchor">#</a> 三、JavaScript 中，数组的存储</h3> <div class="language- extra-class"><pre class="language-text"><code>// The JSArray describes JavaScript Arrays
//  Such an array can be in one of two modes:
//    - fast, backing storage is a FixedArray and length &lt;= elements.length();
//       Please note: push and pop can be used to grow and shrink the array.
//    - slow, backing storage is a HashTable with numbers as keys.
class JSArray: public JSObject {
 public:
  // [length]: The length property.
  DECL_ACCESSORS(length, Object)
    
  // ...
   
  // Number of element slots to pre-allocate for an empty array.
  static const int kPreallocatedArrayElements = 4;
};
</code></pre></div><p><code>JSArray</code> 继承于 <code>JSObject</code> ，从注释上看，它有两种存储方式：</p> <ul><li>fast：存储结构是 <code>FixedArray</code> ，并且数组长度 <code>&lt;= elements.length()</code> ，<code>push</code> 或 <code>pop</code> 时可能会伴随着动态扩容或减容</li> <li>slow：存储结构是 <code>HashTable</code>（哈希表），并且数组下标作为 <code>key</code></li></ul> <p><code>fast</code> 模式下数组在源码里面叫 <code>FastElements</code> ，而 <code>slow</code> 模式下的叫做 <code>SlowElements</code> 。</p> <h4 id="_1-快数组-fastelements"><a href="#_1-快数组-fastelements" class="header-anchor">#</a> 1. 快数组（FastElements）</h4> <p><code>FixedArray</code> 是 V8 实现的一个类似于数组的类，它表示一段连续的内存，可以使用索引直接定位。新创建的空数组默认就是快数组。当数组满（数组的长度达到数组在内存中申请的内存容量最大值）的时候，继续 <code>push</code> 时， <code>JSArray</code> 会进行动态的扩容，以存储更多的元素。</p> <h4 id="_2-慢数组-slowelements"><a href="#_2-慢数组-slowelements" class="header-anchor">#</a> 2. 慢数组（SlowElements）</h4> <p>慢数组以哈希表的形式存储在内存空间里，它不需要开辟连续的存储空间，但需要额外维护一个哈希表，与快数组相比，性能相对较差。</p> <div class="language- extra-class"><pre class="language-text"><code>// src/objects/dictionary.h
class EXPORT_TEMPLATE_DECLARE(V8_EXPORT_PRIVATE) Dictionary
    : public HashTable&lt;Derived, Shape&gt; {
  using DerivedHashTable = HashTable&lt;Derived, Shape&gt;;

 public:
  using Key = typename Shape::Key;
  // Returns the value at entry.
  inline Object ValueAt(InternalIndex entry);
  inline Object ValueAt(const Isolate* isolate, InternalIndex entry);
  
  // ...
};
</code></pre></div><p>从源码中可以看出，它的内部就是一个 HashTable。</p> <h4 id="_3-什么时候会从-fast-转变为-slow-喃"><a href="#_3-什么时候会从-fast-转变为-slow-喃" class="header-anchor">#</a> 3. 什么时候会从 fast 转变为 slow 喃？</h4> <p>从 Chrome V8 源码上看，</p> <div class="language- extra-class"><pre class="language-text"><code>// src/objects/js-objects.h
static const uint32_t kMaxGap = 1024;

// src/objects/dictionary.h
// JSObjects prefer dictionary elements if the dictionary saves this much
// memory compared to a fast elements backing store.
static const uint32_t kPreferFastElementsSizeFactor = 3;

// src/objects/js-objects-inl.h
// If the fast-case backing storage takes up much more memory than a dictionary
// backing storage would, the object should have slow elements.
// static
static inline bool ShouldConvertToSlowElements(uint32_t used_elements,
                                               uint32_t new_capacity) {
  uint32_t size_threshold = NumberDictionary::kPreferFastElementsSizeFactor *
                            NumberDictionary::ComputeCapacity(used_elements) *
                            NumberDictionary::kEntrySize;
  // 快数组新容量是扩容后的容量3倍之多时，也会被转成慢数组
  return size_threshold &lt;= new_capacity;
}

static inline bool ShouldConvertToSlowElements(JSObject object,
                                               uint32_t capacity,
                                               uint32_t index,
                                               uint32_t* new_capacity) {
  STATIC_ASSERT(JSObject::kMaxUncheckedOldFastElementsLength &lt;=
                JSObject::kMaxUncheckedFastElementsLength);
  if (index &lt; capacity) {
    *new_capacity = capacity;
    return false;
  }
  // 当加入的索引值（例如例3中的2000）比当前容量capacity 大于等于 1024时，
  // 返回true，转为慢数组
  if (index - capacity &gt;= JSObject::kMaxGap) return true;
  *new_capacity = JSObject::NewElementsCapacity(index + 1);
  DCHECK_LT(index, *new_capacity);
  // TODO(ulan): Check if it works with young large objects.
  if (*new_capacity &lt;= JSObject::kMaxUncheckedOldFastElementsLength ||
      (*new_capacity &lt;= JSObject::kMaxUncheckedFastElementsLength &amp;&amp;
       ObjectInYoungGeneration(object))) {
    return false;
  }
  return ShouldConvertToSlowElements(object.GetFastElementsUsage(),
                                     *new_capacity);
}
</code></pre></div><p>所以，当处于以下情况时，快数组会被转变为慢数组：</p> <ul><li>当加入的索引值 index 比当前容量 capacity 差值大于等于 1024 时（index - capacity &gt;= 1024）</li> <li>快数组新容量是扩容后的容量 3 倍之多时</li></ul> <p>例如：向快数组里增加一个大索引同类型值</p> <div class="language- extra-class"><pre class="language-text"><code>var arr = [1, 2, 3]
arr[2000] = 10;
</code></pre></div><p>当往 <code>arr</code> 增加一个 <code>2000</code> 的索引时，<code>arr</code> 被转成慢数组。节省了大量的内存空间（从索引为 2 到索引为 2000）。</p> <h4 id="_4-什么时候会从-slow-转变为-fast-喃"><a href="#_4-什么时候会从-slow-转变为-fast-喃" class="header-anchor">#</a> 4. 什么时候会从 slow 转变为 fast 喃？</h4> <p>我们已经知道在什么时候会出现由快变慢，那由慢变快就很简单了</p> <div class="language- extra-class"><pre class="language-text"><code>static bool ShouldConvertToFastElements(JSObject object,
                                        NumberDictionary dictionary,
                                        uint32_t index,
                                        uint32_t* new_capacity) {
  // If properties with non-standard attributes or accessors were added, we
  // cannot go back to fast elements.
  if (dictionary.requires_slow_elements()) return false;
  // Adding a property with this index will require slow elements.
  if (index &gt;= static_cast&lt;uint32_t&gt;(Smi::kMaxValue)) return false;
  if (object.IsJSArray()) {
    Object length = JSArray::cast(object).length();
    if (!length.IsSmi()) return false;
    *new_capacity = static_cast&lt;uint32_t&gt;(Smi::ToInt(length));
  } else if (object.IsJSArgumentsObject()) {
    return false;
  } else {
    *new_capacity = dictionary.max_number_key() + 1;
  }
  *new_capacity = Max(index + 1, *new_capacity);
  uint32_t dictionary_size = static_cast&lt;uint32_t&gt;(dictionary.Capacity()) *
                             NumberDictionary::kEntrySize;
  // Turn fast if the dictionary only saves 50% space.
  return 2 * dictionary_size &gt;= *new_capacity;
}
</code></pre></div><p>当慢数组的元素可存放在快数组中且长度在 smi 之间且仅节省了50%的空间，则会转变为快数组</p> <h3 id="四、javascript-中-数组的动态扩容与减容-fastelements"><a href="#四、javascript-中-数组的动态扩容与减容-fastelements" class="header-anchor">#</a> 四、JavaScript 中，数组的动态扩容与减容（FastElements）</h3> <p>默认空数组初始化大小为 <code>4</code> :</p> <div class="language- extra-class"><pre class="language-text"><code>// Number of element slots to pre-allocate for an empty array.
static const int kPreallocatedArrayElements = 4;
</code></pre></div><p>在 JavaScript 中，当数组执行 <code>push</code> 操作时，一旦发现数组内存不足，将进行扩容。</p> <p>在 Chrome 源码中， <code>push</code> 的操作是用汇编实现的，在 c++ 里嵌入的汇编，以提高执行效率，并且在汇编的基础上用 c++ 封装了一层，在编译执行的时候，会将这些 c++ 代码转成汇编代码。</p> <p>计算新容量的函数：</p> <div class="language- extra-class"><pre class="language-text"><code>// js-objects.h
static const uint32_t kMinAddedElementsCapacity = 16;

// code-stub-assembler.cc
Node* CodeStubAssembler::CalculateNewElementsCapacity(Node* old_capacity,
                                                      ParameterMode mode) {
  CSA_SLOW_ASSERT(this, MatchesParameterMode(old_capacity, mode));
  Node* half_old_capacity = WordOrSmiShr(old_capacity, 1, mode);
  Node* new_capacity = IntPtrOrSmiAdd(half_old_capacity, old_capacity, mode);
  Node* padding =
      IntPtrOrSmiConstant(JSObject::kMinAddedElementsCapacity, mode);
  return IntPtrOrSmiAdd(new_capacity, padding, mode);
}
</code></pre></div><p>所以扩容后新容量计公式为：</p> <blockquote><p>new_capacity = old_capacity /2 + old_capacity + 16</p></blockquote> <p>即老的容量的 1.5 倍加上 16 。初始化为 4 个，当 <code>push</code> 第 5 个的时候，容量将会变成：</p> <blockquote><p>new_capacity = 4 / 2 + 4 + 16 = 22</p></blockquote> <p>接着申请一块这么大的内存，把老的数据拷过去，把新元素放在当前 length 位置，然后将数组的 length + 1，并返回 length。</p> <p>所以，扩容可以分为以下几步：</p> <ul><li><code>push</code> 操作时，发现数组内存不足</li> <li>申请 new_capacity = old_capacity /2 + old_capacity + 16 那么长度的内存空间</li> <li>将数组拷贝到新内存中</li> <li>把新元素放在当前 length 位置</li> <li>数组的 length + 1</li> <li>返回 length</li></ul> <p>整个过程，用户是无感知的，不像 C，需用用户手动申请内存空间。</p> <p>当数组执行 <code>pop</code> 操作时，会判断 <code>pop</code> 后数组的容量，是否需要进行减容。</p> <p>不同于数组的 <code>push</code> 使用汇编实现的， <code>pop</code> 使用 c++ 实现的。</p> <p>判断是否进行减容：</p> <div class="language- extra-class"><pre class="language-text"><code>if (2 * length &lt;= capacity) {
  // If more than half the elements won't be used, trim the array.
  isolate-&gt;heap()-&gt;RightTrimFixedArray(*backing_store, capacity - length);
} else {
  // Otherwise, fill the unused tail with holes.
  BackingStore::cast(*backing_store)-&gt;FillWithHoles(length, old_length);
}
</code></pre></div><p>所以，当数组 <code>pop</code> 后，如果数组容量大于等于 length 的 2 倍，则进行容量调整，使用 <code>RightTrimFixedArray</code> 函数，计算出需要释放的空间大小，做好标记，等待 GC 回收；如果数组容量小于 length 的 2 倍，则用 holes 对象填充。</p> <p>所以，减容可以分为以下几步：</p> <ul><li><code>pop</code> 操作时，获取数组 <code>length</code></li> <li>获取 <code>length - 1</code> 上的元素（要删除的元素）</li> <li>数组 <code>length - 1</code></li> <li>判断数组的总容量是否大于等于 length - 1 的 2 倍</li> <li>是的话，使用 <code>RightTrimFixedArray</code> 函数，计算出需要释放的空间大小，并做好标记，等待 <code>GC</code> 回收</li> <li>不是的话，用 <code>holes</code> 对象填充</li> <li>返回要删除的元素</li></ul> <h3 id="五、解答开篇问题"><a href="#五、解答开篇问题" class="header-anchor">#</a> 五、解答开篇问题</h3> <p>JavaScript 中， <code>JSArray</code> 继承自 <code>JSObject</code> ，或者说它就是一个特殊的对象，内部是以 key-value 形式存储数据，所以 JavaScript 中的数组可以存放不同类型的值。它有两种存储方式，快数组与慢数组，初始化空数组时，使用快数组，快数组使用连续的内存空间，当数组长度达到最大时，<code>JSArray</code> 会进行动态的扩容，以存储更多的元素，相对慢数组，性能要好得多。当数组中 <code>hole</code> 太多时，会转变成慢数组，即以哈希表的方式（ key-value 的形式）存储数据，以节省内存空间。</p> <h3 id="六、最后附赠一道前端面试题-腾讯-数组扁平化、去重、排序"><a href="#六、最后附赠一道前端面试题-腾讯-数组扁平化、去重、排序" class="header-anchor">#</a> 六、最后附赠一道前端面试题（腾讯）：数组扁平化、去重、排序</h3> <p>关于 <code>Array</code> 的属性、方法这里不再做介绍，详看 MDN Array 。</p> <p>面试题：</p> <blockquote><p>已知如下数组：var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];</p> <p>编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组</p></blockquote> <p>答案：</p> <div class="language- extra-class"><pre class="language-text"><code>var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]
// 扁平化
let flatArr = arr.flat(4)
// 去重
let disArr = Array.from(new Set(flatArr))
// 排序
let result = disArr.sort(function(a, b) {
    return a-b
})
console.log(result)
// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
</code></pre></div><p>关于 Set 请查阅 Set、WeakSet、Map及WeakMap</p> <p>参考链接：</p> <p>探究JS V8引擎下的“数组”底层实现</p> <p>从Chrome源码看JS Array的实现</p> <h3 id="七、认识更多的前端道友-一起进阶前端开发"><a href="#七、认识更多的前端道友-一起进阶前端开发" class="header-anchor">#</a> 七、认识更多的前端道友，一起进阶前端开发</h3> <p>前端算法集训营第一期开营啦🎉🎉🎉</p> <p>在这里，你可以和志同道合的前端朋友们一起进阶前端算法，从0到1构建完整的数据结构与算法体系。</p> <p>扫码加入【前端算法交流群交流群</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">5/8/2024, 3:01:19 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/algorithm/简单复习下前端算法复杂度相关的知识.html" class="prev">
        简单复习下前端算法复杂度相关的知识
      </a></span> <span class="next"><a href="/algorithm/算法进阶/DIff算法看不懂就一起来锤我.html">
        DIff算法看不懂就一起来锤我
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.950eebbc.js" defer></script><script src="/assets/js/2.57da4f88.js" defer></script><script src="/assets/js/1.a76cc220.js" defer></script><script src="/assets/js/29.49b5374e.js" defer></script>
  </body>
</html>
