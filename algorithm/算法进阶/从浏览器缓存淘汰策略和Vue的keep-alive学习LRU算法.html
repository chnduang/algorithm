<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端进阶算法3：从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法 | duangdong的algorithm</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/logo.png">
    <link rel="manifest" href="/manifest.json">
    <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?0088ce24040b03f2947322ab31d23414";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
    <script>
  var _hmt = _hmt || [];
  _hmt.push(['_requirePlugin', 'UrlChangeTracker', {
    shouldTrackUrlChange: function (newPath, oldPath) {
      newPath = newPath.split('#')[0];
      oldPath = oldPath.split('#')[0];
      return newPath != oldPath;
    }}
  ]);
  </script>
    <meta name="description" content="前端相关知识归纳总结">
    <meta name="keywords" content="qd-blog,node,vuepress,leetcode,algorithm">
    
    <link rel="preload" href="/assets/css/0.styles.b4a844ec.css" as="style"><link rel="preload" href="/assets/js/app.950eebbc.js" as="script"><link rel="preload" href="/assets/js/2.57da4f88.js" as="script"><link rel="preload" href="/assets/js/1.a76cc220.js" as="script"><link rel="preload" href="/assets/js/34.297b5f45.js" as="script"><link rel="prefetch" href="/assets/js/10.50f73657.js"><link rel="prefetch" href="/assets/js/11.0390ceee.js"><link rel="prefetch" href="/assets/js/12.f88bec36.js"><link rel="prefetch" href="/assets/js/13.963ad03b.js"><link rel="prefetch" href="/assets/js/14.512f15b9.js"><link rel="prefetch" href="/assets/js/15.a674496c.js"><link rel="prefetch" href="/assets/js/16.ed7e507f.js"><link rel="prefetch" href="/assets/js/17.de667ca5.js"><link rel="prefetch" href="/assets/js/18.b44e84af.js"><link rel="prefetch" href="/assets/js/19.5b5ad6a1.js"><link rel="prefetch" href="/assets/js/20.6800493a.js"><link rel="prefetch" href="/assets/js/21.6589052c.js"><link rel="prefetch" href="/assets/js/22.f648d829.js"><link rel="prefetch" href="/assets/js/23.b85d0d4e.js"><link rel="prefetch" href="/assets/js/24.d81147fb.js"><link rel="prefetch" href="/assets/js/25.ed5233ca.js"><link rel="prefetch" href="/assets/js/26.83f1ef57.js"><link rel="prefetch" href="/assets/js/27.2565321e.js"><link rel="prefetch" href="/assets/js/28.e60083e4.js"><link rel="prefetch" href="/assets/js/29.49b5374e.js"><link rel="prefetch" href="/assets/js/3.13e892f5.js"><link rel="prefetch" href="/assets/js/30.9ad0e230.js"><link rel="prefetch" href="/assets/js/31.c97534c6.js"><link rel="prefetch" href="/assets/js/32.b90554dc.js"><link rel="prefetch" href="/assets/js/33.9d15b4c0.js"><link rel="prefetch" href="/assets/js/35.029c4cac.js"><link rel="prefetch" href="/assets/js/36.bc299146.js"><link rel="prefetch" href="/assets/js/37.9068edfd.js"><link rel="prefetch" href="/assets/js/38.8c781d87.js"><link rel="prefetch" href="/assets/js/39.87c06c9c.js"><link rel="prefetch" href="/assets/js/4.5bdb9365.js"><link rel="prefetch" href="/assets/js/40.b05763a5.js"><link rel="prefetch" href="/assets/js/41.447511bf.js"><link rel="prefetch" href="/assets/js/42.cef1f724.js"><link rel="prefetch" href="/assets/js/43.cae02230.js"><link rel="prefetch" href="/assets/js/44.833e4694.js"><link rel="prefetch" href="/assets/js/45.2933ab3e.js"><link rel="prefetch" href="/assets/js/46.1108fab7.js"><link rel="prefetch" href="/assets/js/47.1a5b2293.js"><link rel="prefetch" href="/assets/js/48.3f01058a.js"><link rel="prefetch" href="/assets/js/49.24929fd6.js"><link rel="prefetch" href="/assets/js/5.7c68fdb5.js"><link rel="prefetch" href="/assets/js/50.7e052a76.js"><link rel="prefetch" href="/assets/js/51.ae3eb599.js"><link rel="prefetch" href="/assets/js/52.bab65685.js"><link rel="prefetch" href="/assets/js/53.abacf47c.js"><link rel="prefetch" href="/assets/js/54.9d8ffddf.js"><link rel="prefetch" href="/assets/js/55.ac9707fe.js"><link rel="prefetch" href="/assets/js/56.9a9c42d4.js"><link rel="prefetch" href="/assets/js/57.f4d88e89.js"><link rel="prefetch" href="/assets/js/58.816a3870.js"><link rel="prefetch" href="/assets/js/59.8a6b3c7f.js"><link rel="prefetch" href="/assets/js/6.c8da7ca7.js"><link rel="prefetch" href="/assets/js/7.e4c88d0e.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.5143d2e0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b4a844ec.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">duangdong的algorithm</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/algorithm/" class="nav-link router-link-active">
  数据结构
</a></div><div class="nav-item"><a href="/leetcode/" class="nav-link">
  Leetcode
</a></div><div class="nav-item"><a href="/leetcode-summary/" class="nav-link">
  算法题
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/algorithm/" class="nav-link router-link-active">
  数据结构
</a></div><div class="nav-item"><a href="/leetcode/" class="nav-link">
  Leetcode
</a></div><div class="nav-item"><a href="/leetcode-summary/" class="nav-link">
  算法题
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/algorithm/" aria-current="page" class="sidebar-link">算法相关</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端实际项目使用</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/algorithm/动态规划.html" class="sidebar-link">前端也能学算法：由浅入深讲解动态规划</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>排序</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/algorithm/由浅入深讲解贪心算法.html" class="sidebar-link">前端也能学算法：由浅入深讲解贪心算法</a></li><li><a href="/algorithm/简单复习下前端算法复杂度相关的知识.html" class="sidebar-link">简单复习下前端算法复杂度相关的知识</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>算法进阶</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/algorithm/算法进阶/ChromeV8源码看JavaScript数组.html" class="sidebar-link">前端进阶算法2：从Chrome V8源码看JavaScript数组(附赠腾讯面试题)</a></li><li><a href="/algorithm/算法进阶/DIff算法看不懂就一起来锤我.html" class="sidebar-link">DIff算法看不懂就一起来锤我</a></li><li><a href="/algorithm/算法进阶/Diff算法核心原理.html" class="sidebar-link">15张图，20分钟吃透Diff算法核心原理</a></li><li><a href="/algorithm/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6/" aria-current="page" class="sidebar-link">算法进阶</a></li><li><a href="/algorithm/算法进阶/一看就懂的队列及配套算法题.html" class="sidebar-link">前端进阶算法6：一看就懂的队列及配套算法题</a></li><li><a href="/algorithm/算法进阶/从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法.html" class="active sidebar-link">前端进阶算法3：从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法</a></li><li><a href="/algorithm/算法进阶/别再说你不懂Top-K问题了.html" class="sidebar-link">别再说你不懂Top K问题了</a></li><li><a href="/algorithm/算法进阶/去大厂面试问我算法.html" class="sidebar-link">去大厂面试问我算法，我该怎么办？</a></li><li><a href="/algorithm/算法进阶/吊打面试官之数据结构栈.html" class="sidebar-link">前端进阶算法5：吊打面试官之数据结构栈（+leetcode刷题）</a></li><li><a href="/algorithm/算法进阶/堆排序.html" class="sidebar-link">前端进阶算法：看完这篇，再也不怕堆排序、Top K、中位数问题面试了</a></li><li><a href="/algorithm/算法进阶/头条正在面的哈希表问题.html" class="sidebar-link">前端进阶算法：头条正在面的哈希表问题</a></li><li><a href="/algorithm/算法进阶/如何分析-统计算法的执行效率和资源消耗.html" class="sidebar-link">前端进阶算法1：如何分析、统计算法的执行效率和资源消耗？</a></li><li><a href="/algorithm/算法进阶/小白都可以看懂的树与二叉树.html" class="sidebar-link">前端进阶算法7：小白都可以看懂的树与二叉树</a></li><li><a href="/algorithm/算法进阶/带你快速入门前端算法.html" class="sidebar-link">10 问 10 答，带你快速入门前端算法</a></li><li><a href="/algorithm/算法进阶/常见算法题及完美题解.html" class="sidebar-link">前端进阶算法：常见算法题及完美题解</a></li><li><a href="/algorithm/算法进阶/链表原来如此简单.html" class="sidebar-link">前端进阶算法4：链表原来如此简单(+leetcode刷题）</a></li></ul></section></li><li><a href="/algorithm/贪心.html" class="sidebar-link">前端也能学算法：由浅入深讲解贪心算法</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="前端进阶算法3-从浏览器缓存淘汰策略和vue的keep-alive学习lru算法"><a href="#前端进阶算法3-从浏览器缓存淘汰策略和vue的keep-alive学习lru算法" class="header-anchor">#</a> 前端进阶算法3：从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法</h1> <p>原创 前端瓶子君 前端瓶子君 <em>2020-04-07</em></p> <h3 id="引言"><a href="#引言" class="header-anchor">#</a> 引言</h3> <p>这个标题已经很明显的告诉我们：前端需要了解 LRU 算法！</p> <p>这也是前端技能的亮点，当面试官在问到你前端开发中遇到过哪些算法，你也可以把这部分丢过去！</p> <p>本节按以下步骤切入：</p> <ul><li>由浏览器缓存策略引出 LRU 算法原理</li> <li>然后走进 <code>vue</code> 中 <code>keep-alive</code> 的应用</li> <li>接着，透过 <code>vue</code> 中 <code>keep-alive</code> 源码看 <code>LRU</code> 算法的实现</li> <li>最后，来一道 leetcode 题目，我们来实现一个 LRU 算法</li></ul> <p>按这个步骤来，完全掌握 LRU 算法，点亮前端技能，下面就开始吧👇</p> <h3 id="一、lru-缓存淘汰策略"><a href="#一、lru-缓存淘汰策略" class="header-anchor">#</a> 一、LRU 缓存淘汰策略</h3> <p><strong>缓存</strong>在计算机网络上随处可见，例如：当我们首次访问一个网页时，打开很慢，但当我们再次打开这个网页时，打开就很快。</p> <p>这就涉及缓存在浏览器上的应用：<strong>浏览器缓存</strong>。当我们打开一个网页时，例如 <code>https://github.com/sisterAn/JavaScript-Algorithms</code> ，它会在发起真正的网络请求前，查询浏览器缓存，看是否有要请求的文件，如果有，浏览器将会拦截请求，返回缓存文件，并直接结束请求，不会再去服务器上下载。如果不存在，才会去服务器请求。</p> <p>其实，浏览器中的缓存是一种在本地保存资源副本，它的大小是有限的，当我们请求数过多时，缓存空间会被用满，此时，继续进行网络请求就需要确定缓存中哪些数据被保留，哪些数据被移除，这就是<strong>浏览器缓存淘汰策略</strong>，最常见的淘汰策略有 FIFO（先进先出）、LFU（最少使用）、LRU（最近最少使用）。</p> <p>LRU （ <code>Least Recently Used</code> ：最近最少使用 ）缓存淘汰策略，故名思义，就是根据数据的历史访问记录来进行淘汰数据，其核心思想是 <strong>如果数据最近被访问过，那么将来被访问的几率也更高</strong> ，优先淘汰最近没有被访问到的数据。</p> <p>画个图帮助我们理解：</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQRb2E8Kxdfpg7KrvYvFXwGhYgLlfHCxl4Kwuic9tqqofCbpbP8qZ948UjUS6GcQ8q3JwYKg6S3Gxng/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <h3 id="二、lru-在-keep-alive-vue-上的实现"><a href="#二、lru-在-keep-alive-vue-上的实现" class="header-anchor">#</a> 二、LRU 在 keep-alive (Vue) 上的实现</h3> <h4 id="_1-keep-alive"><a href="#_1-keep-alive" class="header-anchor">#</a> 1. keep-alive</h4> <p>keep-alive 在 vue 中用于实现组件的缓存，当组件切换时不会对当前组件进行卸载。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;!-- 基本 --&gt;
&lt;keep-alive&gt;
  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;
&lt;/keep-alive&gt;
</code></pre></div><p>最常用的两个属性：<code>include</code> 、 <code>exculde</code> ，用于组件进行有条件的缓存，可以用逗号分隔字符串、正则表达式或一个数组来表示。</p> <p>在 2.5.0 版本中，<code>keep-alive</code> 新增了 <code>max</code> 属性，用于最多可以缓存多少组件实例，一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉，<strong>看，这里就应用了 LRU 算法</strong>。即在 <code>keep-alive</code> 中缓存达到 <code>max</code>，新增缓存实例会优先淘汰最近没有被访问到的实例🎉🎉🎉</p> <p>下面我们透过 vue 源码看一下具体的实现👇</p> <h3 id="_2-从-vue-源码看-keep-alive-的实现"><a href="#_2-从-vue-源码看-keep-alive-的实现" class="header-anchor">#</a> 2. 从 vue 源码看 keep-alive 的实现</h3> <div class="language- extra-class"><pre class="language-text"><code>export default {
  name: &quot;keep-alive&quot;,
  // 抽象组件属性 ,它在组件实例建立父子关系的时候会被忽略,
  // 发生在 initLifecycle 的过程中
  abstract: true,
  props: {
    // 被缓存组件
    include: patternTypes,
    // 不被缓存组件
    exclude: patternTypes,
    // 指定缓存大小
    max: [String, Number]
  },
  created() {
    // 初始化用于存储缓存的 cache 对象
    this.cache = Object.create(null);
    // 初始化用于存储VNode key值的 keys 数组
    this.keys = [];
  },
  destroyed() {
    for (const key in this.cache) {
      // 删除所有缓存
      pruneCacheEntry(this.cache, key, this.keys);
    }
  },
  mounted() {
    // 监听缓存（include）/不缓存（exclude）组件的变化
    // 在变化时，重新调整 cache
    // pruneCache：遍历 cache，
    //   如果缓存的节点名称与传入的规则没有匹配上的话，
    //   就把这个节点从缓存中移除
    this.$watch(&quot;include&quot;, val =&gt; {
      pruneCache(this, name =&gt; matches(val, name));
    });
    this.$watch(&quot;exclude&quot;, val =&gt; {
      pruneCache(this, name =&gt; !matches(val, name));
    });
  },
  render() {
    // 获取第一个子元素的 vnode
    const slot = this.$slots.default;
    const vnode: VNode = getFirstComponentChild(slot);
    const componentOptions: ?VNodeComponentOptions =
      vnode &amp;&amp; vnode.componentOptions;
    if (componentOptions) {
      // name 不在 inlcude 中或者在 exlude 中则直接返回 vnode，
      // 否则继续进行下一步
      // check pattern
      const name: ?string = getComponentName(componentOptions);
      const { include, exclude } = this;
      if (
        // not included
        (include &amp;&amp; (!name || !matches(include, name))) ||
        // excluded
        (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))
      ) {
        return vnode;
      }
      
      const { cache, keys } = this;
      // 获取键，优先获取组件的 name 字段，否则是组件的 tag
      const key: ?string =
        vnode.key == null
          ? // same constructor may get registered as
            // different local components
            // so cid alone is not enough (#3269)
            componentOptions.Ctor.cid +
            (componentOptions.tag ? `::${componentOptions.tag}` : &quot;&quot;)
          : vnode.key;
        
      // --------------------------------------------------
      // 下面就是 LRU 算法了，
      // 如果在缓存里有则调整，
      // 没有则放入（长度超过 max，则淘汰最近没有访问的）
      // --------------------------------------------------
      // 如果命中缓存，则从缓存中获取 vnode 的组件实例，
      // 并且调整 key 的顺序放入 keys 数组的末尾
      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance;
        // make current key freshest
        remove(keys, key);
        keys.push(key);
      }
      // 如果没有命中缓存,就把 vnode 放进缓存
      else {
        cache[key] = vnode;
        keys.push(key);
        // prune oldest entry
        // 如果配置了 max 并且缓存的长度超过了 this.max，还要从缓存中删除第一个
        if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }
      
      // keepAlive标记位
      vnode.data.keepAlive = true;
    }
    return vnode || (slot &amp;&amp; slot[0]);
  }
};

// 移除 key 缓存
function pruneCacheEntry (
  cache: VNodeCache,
  key: string,
  keys: Array&lt;string&gt;,
  current?: VNode
) {
  const cached = cache[key]
  if (cached &amp;&amp; (!current || cached.tag !== current.tag)) {
    cached.componentInstance.$destroy()
  }
  cache[key] = null
  remove(keys, key)
}

// remove 方法（shared/util.js）
/**
 * Remove an item from an array.
 */
export function remove (arr: Array&lt;any&gt;, item: any): Array&lt;any&gt; | void {
  if (arr.length) {
    const index = arr.indexOf(item)
    if (index &gt; -1) {
      return arr.splice(index, 1)
    }
  }
}
</code></pre></div><p>keep-alive源码路径</p> <p>在 <code>keep-alive</code> 缓存超过 <code>max</code> 时，使用的缓存淘汰算法就是 LRU 算法，它在实现的过程中用到了 <code>cache</code> 对象用于保存缓存的组件实例及 <code>key</code> 值，<code>keys</code> 数组用于保存缓存组件的 <code>key</code>，当 <code>keep-alive</code> 中渲染一个需要缓存的实例时：</p> <ul><li>判断缓存中是否已缓存了该实例，缓存了则直接获取，并调整 <code>key</code> 在 <code>keys</code> 中的位置（移除 <code>keys</code> 中 <code>key</code> ，并放入 <code>keys</code> 数组的最后一位）</li> <li>如果没有缓存，则缓存该实例，若 <code>keys</code> 的长度大于 <code>max</code> （缓存长度超过上限），则移除 <code>keys[0]</code> 缓存</li></ul> <p>下面我们来自己实现一个 LRU 算法吧⛽️⛽️⛽️</p> <h3 id="三、leetcode-lru-缓存机制"><a href="#三、leetcode-lru-缓存机制" class="header-anchor">#</a> 三、leetcode：LRU 缓存机制</h3> <p>运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作：获取数据 <code>get</code> 和写入数据 <code>put</code> 。</p> <p>获取数据 <code>get(key)</code> - 如果密钥 ( <code>key</code> ) 存在于缓存中，则获取密钥的值（总是正数），否则返回 <code>-1</code> 。写入数据 <code>put(key, value)</code> - 如果密钥不存在，则写入数据。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据，从而为新数据留出空间。</p> <p><strong>进阶:</strong></p> <p>你是否可以在 <strong>O(1)</strong> 时间复杂度内完成这两种操作？</p> <p><strong>示例:</strong></p> <div class="language- extra-class"><pre class="language-text"><code>LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回  1
cache.put(3, 3);    // 该操作会使得密钥 2 作废
cache.get(2);       // 返回 -1 (未找到)
cache.put(4, 4);    // 该操作会使得密钥 1 作废
cache.get(1);       // 返回 -1 (未找到)
cache.get(3);       // 返回  3
cache.get(4);       // 返回  4
</code></pre></div><p>前面已经介绍过了 <code>keep-alive</code> 中LRU实现源码，现在来看这道题是不是很简单😊😊😊，可以尝试自己解答一下⛽️，然后思考一下有没有什么继续优化的！欢迎提供更多的解法</p> <p>欢迎将答案提交到 https://github.com/sisterAn/JavaScript-Algorithms/issues/7 ，让更多人看到，瓶子君也会在明日放上自己的解答。</p> <h3 id="四、认识更多的前端道友-一起进阶前端开发"><a href="#四、认识更多的前端道友-一起进阶前端开发" class="header-anchor">#</a> 四、认识更多的前端道友，一起进阶前端开发</h3> <p>前端算法集训营第一期免费开营啦🎉🎉🎉，免费哟！</p> <p>在这里，你可以和志同道合的前端朋友们（600+）一起进阶前端算法，从0到1构建完整的数据结构与算法体系。</p> <p>在这里，瓶子君不仅介绍算法，还将算法与前端各个领域进行结合，包括浏览器、HTTP、V8、React、Vue源码等。</p> <p>在这里，你可以每天学习一道大厂算法题（阿里、腾讯、百度、字节等等）或 leetcode，瓶子君都会在第二天解答哟！</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">5/8/2024, 3:01:19 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/algorithm/算法进阶/一看就懂的队列及配套算法题.html" class="prev">
        前端进阶算法6：一看就懂的队列及配套算法题
      </a></span> <span class="next"><a href="/algorithm/算法进阶/别再说你不懂Top-K问题了.html">
        别再说你不懂Top K问题了
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.950eebbc.js" defer></script><script src="/assets/js/2.57da4f88.js" defer></script><script src="/assets/js/1.a76cc220.js" defer></script><script src="/assets/js/34.297b5f45.js" defer></script>
  </body>
</html>
