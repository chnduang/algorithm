<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端也能学算法：由浅入深讲解贪心算法 | duangdong的algorithm</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/logo.png">
    <link rel="manifest" href="/manifest.json">
    <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?0088ce24040b03f2947322ab31d23414";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
    <script>
  var _hmt = _hmt || [];
  _hmt.push(['_requirePlugin', 'UrlChangeTracker', {
    shouldTrackUrlChange: function (newPath, oldPath) {
      newPath = newPath.split('#')[0];
      oldPath = oldPath.split('#')[0];
      return newPath != oldPath;
    }}
  ]);
  </script>
    <meta name="description" content="前端相关知识归纳总结">
    <meta name="keywords" content="qd-blog,node,vuepress,leetcode,algorithm">
    
    <link rel="preload" href="/assets/css/0.styles.b4a844ec.css" as="style"><link rel="preload" href="/assets/js/app.950eebbc.js" as="script"><link rel="preload" href="/assets/js/2.57da4f88.js" as="script"><link rel="preload" href="/assets/js/1.a76cc220.js" as="script"><link rel="preload" href="/assets/js/27.2565321e.js" as="script"><link rel="prefetch" href="/assets/js/10.50f73657.js"><link rel="prefetch" href="/assets/js/11.0390ceee.js"><link rel="prefetch" href="/assets/js/12.f88bec36.js"><link rel="prefetch" href="/assets/js/13.963ad03b.js"><link rel="prefetch" href="/assets/js/14.512f15b9.js"><link rel="prefetch" href="/assets/js/15.a674496c.js"><link rel="prefetch" href="/assets/js/16.ed7e507f.js"><link rel="prefetch" href="/assets/js/17.de667ca5.js"><link rel="prefetch" href="/assets/js/18.b44e84af.js"><link rel="prefetch" href="/assets/js/19.5b5ad6a1.js"><link rel="prefetch" href="/assets/js/20.6800493a.js"><link rel="prefetch" href="/assets/js/21.6589052c.js"><link rel="prefetch" href="/assets/js/22.f648d829.js"><link rel="prefetch" href="/assets/js/23.b85d0d4e.js"><link rel="prefetch" href="/assets/js/24.d81147fb.js"><link rel="prefetch" href="/assets/js/25.ed5233ca.js"><link rel="prefetch" href="/assets/js/26.83f1ef57.js"><link rel="prefetch" href="/assets/js/28.e60083e4.js"><link rel="prefetch" href="/assets/js/29.49b5374e.js"><link rel="prefetch" href="/assets/js/3.13e892f5.js"><link rel="prefetch" href="/assets/js/30.9ad0e230.js"><link rel="prefetch" href="/assets/js/31.c97534c6.js"><link rel="prefetch" href="/assets/js/32.b90554dc.js"><link rel="prefetch" href="/assets/js/33.9d15b4c0.js"><link rel="prefetch" href="/assets/js/34.297b5f45.js"><link rel="prefetch" href="/assets/js/35.029c4cac.js"><link rel="prefetch" href="/assets/js/36.bc299146.js"><link rel="prefetch" href="/assets/js/37.9068edfd.js"><link rel="prefetch" href="/assets/js/38.8c781d87.js"><link rel="prefetch" href="/assets/js/39.87c06c9c.js"><link rel="prefetch" href="/assets/js/4.5bdb9365.js"><link rel="prefetch" href="/assets/js/40.b05763a5.js"><link rel="prefetch" href="/assets/js/41.447511bf.js"><link rel="prefetch" href="/assets/js/42.cef1f724.js"><link rel="prefetch" href="/assets/js/43.cae02230.js"><link rel="prefetch" href="/assets/js/44.833e4694.js"><link rel="prefetch" href="/assets/js/45.2933ab3e.js"><link rel="prefetch" href="/assets/js/46.1108fab7.js"><link rel="prefetch" href="/assets/js/47.1a5b2293.js"><link rel="prefetch" href="/assets/js/48.3f01058a.js"><link rel="prefetch" href="/assets/js/49.24929fd6.js"><link rel="prefetch" href="/assets/js/5.7c68fdb5.js"><link rel="prefetch" href="/assets/js/50.7e052a76.js"><link rel="prefetch" href="/assets/js/51.ae3eb599.js"><link rel="prefetch" href="/assets/js/52.bab65685.js"><link rel="prefetch" href="/assets/js/53.abacf47c.js"><link rel="prefetch" href="/assets/js/54.9d8ffddf.js"><link rel="prefetch" href="/assets/js/55.ac9707fe.js"><link rel="prefetch" href="/assets/js/56.9a9c42d4.js"><link rel="prefetch" href="/assets/js/57.f4d88e89.js"><link rel="prefetch" href="/assets/js/58.816a3870.js"><link rel="prefetch" href="/assets/js/59.8a6b3c7f.js"><link rel="prefetch" href="/assets/js/6.c8da7ca7.js"><link rel="prefetch" href="/assets/js/7.e4c88d0e.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.5143d2e0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b4a844ec.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">duangdong的algorithm</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/algorithm/" class="nav-link router-link-active">
  数据结构
</a></div><div class="nav-item"><a href="/leetcode/" class="nav-link">
  Leetcode
</a></div><div class="nav-item"><a href="/leetcode-summary/" class="nav-link">
  算法题
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/algorithm/" class="nav-link router-link-active">
  数据结构
</a></div><div class="nav-item"><a href="/leetcode/" class="nav-link">
  Leetcode
</a></div><div class="nav-item"><a href="/leetcode-summary/" class="nav-link">
  算法题
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/algorithm/" aria-current="page" class="sidebar-link">算法相关</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端实际项目使用</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/algorithm/动态规划.html" class="sidebar-link">前端也能学算法：由浅入深讲解动态规划</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>排序</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/algorithm/由浅入深讲解贪心算法.html" class="active sidebar-link">前端也能学算法：由浅入深讲解贪心算法</a></li><li><a href="/algorithm/简单复习下前端算法复杂度相关的知识.html" class="sidebar-link">简单复习下前端算法复杂度相关的知识</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>算法进阶</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/algorithm/贪心.html" class="sidebar-link">前端也能学算法：由浅入深讲解贪心算法</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="前端也能学算法-由浅入深讲解贪心算法"><a href="#前端也能学算法-由浅入深讲解贪心算法" class="header-anchor">#</a> 前端也能学算法：由浅入深讲解贪心算法</h2> <blockquote><p><a href="https://mp.weixin.qq.com/s/7_pnOiPsvIceytJaeN8iNA" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/7_pnOiPsvIceytJaeN8iNA<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>贪心算法是一种很常见的算法思想，而且很好理解，因为它符合人们一般的思维习惯。下面我们由浅入深的来讲讲贪心算法。</p> <h2 id="找零问题"><a href="#找零问题" class="header-anchor">#</a> 找零问题</h2> <p>我们先来看一个比较简单的问题：</p> <blockquote><p>假设你是一个商店老板，你需要给顾客找零n元钱，你手上有的钱的面值为：100元，50元，20元，5元，1元。请问如何找零使得所需要的钱币数量最少？</p> <p>例子：你需要找零126元，则所需钱币数量最少的方案为100元1张，20元1张，5元1张，1元1张。</p></blockquote> <p>这个问题在生活中很常见，买东西的时候经常会遇到，那我们一般是怎么思考的呢？假设我们需要找零126元，我们先看看能找的最大面值是多少，我们发现126比100大，那肯定可以找一张100块，然后剩下26元，再看26能匹配的最大面值是多少，发现是20，那找一张20的，还剩6块，同样的思路，找一张5块的和1块的。这其实就是贪心算法的思想，每次都很贪心的去找最大的匹配那个值，然后再找次大的。这个算法代码也很好写：</p> <div class="language- extra-class"><pre class="language-text"><code>const allMoney = [100, 50, 20, 5, 1];  // 表示我们手上有的面值function changeMoney(n, allMoney) {  const length = allMoney.length;  const result = [];    // 存储结果的数组，每项表示对应面值的张数  for(let i = 0; i &lt; length; i++) {    if(n &gt;= allMoney[i]) {      // 如果需要找的钱比面值大，那就可以找，除一下看看能找几张      result[i] = parseInt(n / allMoney[i]);      n = n - result[i] * allMoney[i];   // 更新剩下需要找的钱    } else {      // 否则不能找      result[i] = 0;    }  }
  return result;}
const result = changeMoney(126, allMoney);console.log(result);   // [1, 0, 1, 1, 1]
</code></pre></div><h2 id="贪心算法"><a href="#贪心算法" class="header-anchor">#</a> 贪心算法</h2> <p>上面的找零问题就是贪心算法，每次都去贪最大面值的，发现贪不了了，再去贪次大的。从概念上讲，贪心算法是：</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/8mYHUg4p3qtjRcWDbCDBT4skmiaG1S67gCn2X2ibrRlWoibm2UIwFpmhEVejaMxqTorL1yOPRRMS0PicJXibIqwVfnA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p>从上面的定义可以看出，并不是所有问题都可以用贪心算法来求解的，因为它每次拿到的只是局部最优解，局部最优解组合起来并不一定是全局最优解。下面我们来看一个这样的例子：</p> <h2 id="背包问题"><a href="#背包问题" class="header-anchor">#</a> 背包问题</h2> <p>背包问题也是一个很经典的算法问题，题目如下：</p> <blockquote><p>有一个小偷，他进到了一个店里要偷东西，店里有很多东西，每个东西的价值是v，每个东西的重量是w。但是小偷只有一个背包，他背包总共能承受的重量是W。请问怎么拿东西能让他拿到的价值最大？</p></blockquote> <p>其实背包问题细分下来又可以分成两个问题：0-1背包和分数背包。</p> <blockquote><p><strong>0-1背包</strong>：指的是对于某个商品来说，你要么不拿，要么全拿走，不能只拿一半或者只拿三分之二。可以将商品理解成金砖，你要么整块拿走，要么不拿，不能拿半块。</p></blockquote> <blockquote><p><strong>分数背包</strong>：分数背包就是跟0-1背包相反的，你可以只拿一部分，可以拿一半，也可以拿三分之二。可以将商品理解成金砂，可以只拿一部分。</p></blockquote> <p>下面来看个例子：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>这个问题用我们平时的思维也很好想，要拿到总价值最大，那我们就贪呗，就拿最贵的，即价值除以重量的数最大的。但是每次都拿最贵的，是不是最后总价值最大呢？我们先假设上面的例子是0-1背包，最贵的是v1，然后是v2，v3。我们先拿v1, 背包还剩40，拿到总价值是60，然后拿v2，背包还剩20，拿到总价值是160。然后就拿不下了，因为v3的重量是30，我们背包只剩20了，装不下了。但是这个显然不是全局最优解，因为我们明显可以看出，如果我们拿v2，v3，背包刚好装满，总价值是220，这才是最优解。<strong>所以0-1背包问题不能用贪心算法。</strong></p> <p>但是分数背包可以用贪心，因为我们总是可以拿最贵的。我们先拿了v1, v2，发现v3装不下了，那就不装完了嘛，装三分之二就行了。下面我们用贪心来实现一个分数背包：</p> <div class="language- extra-class"><pre class="language-text"><code>const products = [  {id:1, v: 60, w: 10},   {id:2, v: 100, w: 20},   {id:3, v: 120, w: 30}];    // 新建一个数组表示商品列表，每个商品加个id用于标识
function backpack(W, products) {  const sortedProducts = products.sort((product1, product2) =&gt; {    const price1 = product1.v / product1.w;    const price2 = product2.v / product2.w;    if(price1 &gt; price2) {      return -1;    } else if(price1 &lt; price2) {      return 1;    }
    return 0;  });  // 先对商品按照价值从大到小排序
  const result = []; // 新建数组接收结果  let allValue = 0;  // 拿到的总价值  const length = sortedProducts.length;
  for(let i = 0; i &lt; length; i++) {    const sortedProduct = sortedProducts[i];    if(W &gt;= sortedProduct.w) {      // 整个拿完      result.push({        id: sortedProduct.id,        take: 1,     // 拿的数量      });      W = W - sortedProduct.w;      allValue = allValue + sortedProduct.v;    } else if(W &gt; 0) {      // 只能拿一部分      result.push({        id: sortedProduct.id,        take: W / sortedProduct.w,           });      allValue = allValue + sortedProduct.v * (W / sortedProduct.w);      W = 0; // 装满了    } else {      // 不能拿了      result.push({        id: sortedProduct.id,        take: 0,           });    }  }
  return {result: result, allValue: allValue};}
// 测试一下const result = backpack(50, products);console.log(result);
</code></pre></div><p>运行结果：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <h3 id="_0-1背包"><a href="#_0-1背包" class="header-anchor">#</a> 0-1背包</h3> <p>前面讲过0-1背包不能用贪心求解，我们这里还是讲讲他怎么来求解吧。要解这个问题需要用到动态规划的思想，关于动态规划的思想，可以看看我这篇文章[1]，如果你只想看看贪心算法，可以跳过这一部分。假设我们背包放了n个商品，W是我们背包的总容量，我们这时拥有的总价值是$D(n, W)$。我们考虑最后一步，</p> <blockquote><p>假如我们不放最后一个商品，则总价值为$D(n-1, W)$</p></blockquote> <blockquote><p>假设我们放了最后一个商品，则总价值为最后一个商品加上前面已经放了的价值，表示为$v_n + D(n-1, W-w_n)$，这时候需要满足的条件是$ W &gt;= w_n$，即最后一个要放得下。</p></blockquote> <p>我们要求的最大解其实就是上述两个方案的最大值，表示如下：</p> <p>D(n, W) = max(D(n-1, W), v_n + D(n-1, W-w_n))</p> <h3 id="递归解法"><a href="#递归解法" class="header-anchor">#</a> 递归解法</h3> <p>有了递推公式，我们就可以用递归解法了：</p> <div class="language- extra-class"><pre class="language-text"><code>const products = [  {id:1, v: 60, w: 10},   {id:2, v: 100, w: 20},     {id:3, v: 120, w: 30}];    // 新建一个数组表示商品列表，每个商品加个id用于标识
function backpack01(n, W, products) {  if(n &lt; 0 || W &lt;= 0) {    return 0;  }
  const noLast = backpack01(n-1, W, products);  // 不放最后一个
  let getLast = 0;  if(W &gt;= products[n].w){  // 如果最后一个放得下    getLast = products[n].v + backpack01(n-1, W-products[n].w, products);  }
  const result = Math.max(noLast, getLast);
  return result;}
// 测试一下const result = backpack01(products.length-1, 50, products);console.log(result);   // 220
</code></pre></div><h3 id="动态规划"><a href="#动态规划" class="header-anchor">#</a> 动态规划</h3> <p>递归的复杂度很高，我们用动态规划重写一下：</p> <div class="language- extra-class"><pre class="language-text"><code>const products = [  {id:1, v: 60, w: 10},   {id:2, v: 100, w: 20},     {id:3, v: 120, w: 30}];    // 新建一个数组表示商品列表，每个商品加个id用于标识
function backpack01(W, products) {  const d = [];      // 初始化一个数组放计算中间值，其实为二维数组，后面填充里面的数组  const length = products.length;
  // i表示行，为商品个数，数字为 0 -- (length - 1)  // j表示列，为背包容量，数字为 0 -- W  for(let i = 0; i &lt; length; i++){    d.push([]);    for(let j = 0; j &lt;= W; j++) {      if(j === 0) {        // 背包容量为0        d[i][j] = 0;      } else if(i === 0) {        if(j &gt;= products[i].w) {          // 可以放下第一个商品          d[i][j] = products[i].v;        } else {          d[i][j] = 0;        }      } else {        const noLast = d[i-1][j];
        let getLast = 0;        if(j &gt;= products[i].w) {          getLast = products[i].v + d[i-1][j - products[i].w];        }
        if(noLast &gt; getLast) {          d[i][j] = noLast;        } else {          d[i][j] = getLast;        }      }    }  }
  console.log(d);  return d[length-1][W];}
// 测试一下const result = backpack01(50, products);console.log(result);   // 220
</code></pre></div><h3 id="回溯最优解"><a href="#回溯最优解" class="header-anchor">#</a> 回溯最优解</h3> <p>为了能够输出最优解，我们需要将每个最后放入的商品记录下来，然后从最后往前回溯，将前面的代码改造如下：</p> <div class="language- extra-class"><pre class="language-text"><code>const products = [  {id:1, v: 60, w: 10},   {id:2, v: 100, w: 20},     {id:3, v: 120, w: 30}];    // 新建一个数组表示商品列表，每个商品加个id用于标识
function backpack01(W, products) {  const d = [];      // 初始化一个数组放计算中间值，其实为二维数组，后面填充里面的数组  const res = [];    // 记录每次放入的最后一个商品, 同样为二维数组  const length = products.length;
  // i表示行，为商品个数，数字为 0 -- (length - 1)  // j表示列，为背包容量，数字为 0 -- W  for(let i = 0; i &lt; length; i++){    d.push([]);    res.push([]);    for(let j = 0; j &lt;= W; j++) {      if(j === 0) {        // 背包容量为0        d[i][j] = 0;        res[i][j] = null;        } else if(i === 0) {        if(j &gt;= products[i].w) {          // 可以放下第一个商品          d[i][j] = products[i].v;          res[i][j] = products[i];        } else {          d[i][j] = 0;          res[i][j] = null;        }      } else {        const noLast = d[i-1][j];
        let getLast = 0;        if(j &gt;= products[i].w) {          getLast = products[i].v + d[i-1][j - products[i].w];        }
        if(noLast &gt; getLast) {          d[i][j] = noLast;        } else {          d[i][j] = getLast;          res[i][j] = products[i];   // 记录最后一个商品        }      }    }  }
  // 回溯res, 得到最优解  let tempW = W;  let tempI = length - 1;  const bestSol = [];  while (tempW &gt; 0 &amp;&amp; tempI &gt;= 0) {    const last = res[tempI][tempW];    bestSol.push(last);    tempW = tempW - last.w;    tempI = tempI - 1;  }
  console.log(d);  console.log(bestSol);  return {    totalValue: d[length-1][W],    solution: bestSol  }}
// 测试一下const result = backpack01(50, products);console.log(result);   // 220
</code></pre></div><p>上面代码的输出：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <h2 id="数字拼接问题"><a href="#数字拼接问题" class="header-anchor">#</a> 数字拼接问题</h2> <p>再来看一个贪心算法的问题，加深下理解，这个问题如下：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>这个问题看起来也不难，我们有时候也会遇到类似的问题，我们可以很直观的想到一个解法：看哪个数字的第一个数字大，把他排前面，比如32和94，把第一位是9的94放前面，得到9432，肯定比32放前面的3294大。这其实就是按照字符串大小来排序嘛，字符大的排前面，但是这种解法正确吗？我们再来看两个数字，假如我们有728和7286，按照字符序，7286排前面，得到7286728，但是这个值没有728放前面的7287286大。说明单纯的字符序是搞不定这个的，对于两个数字a,b，如果他们的长度一样，那按照字符序就没问题，如果他们长度不一样，这个解法就不一定对了，那怎么办呢？其实也简单，我们看看a+b和b+a拼成的数字，哪个大就行了。</p> <div class="language- extra-class"><pre class="language-text"><code>假设a = 728b = 7286字符串：a + b = &quot;7287286&quot;字符串：b + a = &quot;7286728&quot;比较下这两个字符串, a + b比较大，a放前面就行了, 反之放到后面
</code></pre></div><p>上述算法就是一个贪心，这里贪的是什么的？贪的是<code>a + b</code>的值，要大的那个。在实现的时候，可以自己写个冒泡，也可以直接用数组的sort方法:</p> <div class="language- extra-class"><pre class="language-text"><code>const nums = [32, 94, 128, 1286, 6, 71];
function getBigNum(nums) {  nums.sort((a, b) =&gt; {    const ab = `${a}${b}`;    const ba = `${b}${a}`;
    if(ab &gt; ba) {      return -1;   // ab大，a放前面    } else if (ab &lt; ba) {      return 1;      }
    return 0;  });
  return nums;}
const res = getBigNum(nums);console.log(res);    // [94, 71, 6, 32, 1286, 128]
</code></pre></div><h2 id="活动选择问题"><a href="#活动选择问题" class="header-anchor">#</a> 活动选择问题</h2> <p>活动选择问题稍微难一点，也可以用贪心，但是需要贪的东西没前面的题目那么直观，我们先来看看题目：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>这个问题应该这么思考：为了能尽量多的安排活动，我们在安排一个活动时，应该尽量给后面的活动多留时间，这样后面有机会可以安排更多的活动。换句话说就是，应该把结束时间最早的活动安排在第一个，再剩下的时间里面继续安排结束时间早的活动。这里的贪心其实贪的就是结束时间早的，这个结论其实可以用数学来证明的：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>下面来实现下代码：</p> <div class="language- extra-class"><pre class="language-text"><code>const activities = [  {start: 1, end: 4},  {start: 3, end: 5},  {start: 0, end: 6},  {start: 5, end: 7},  {start: 3, end: 9},  {start: 5, end: 9},  {start: 6, end: 10},  {start: 8, end: 11},  {start: 8, end: 12},  {start: 2, end: 14},  {start: 12, end: 16},];
function chooseActivity(activities) {  // 先按照结束时间从小到大排序  activities.sort((act1, act2) =&gt; {    if(act1.end &lt; act2.end) {      return -1;    } else if(act1.end &gt; act2.end) {      return 1;    }
    return 0;  });
  const res = [];  // 接收结果的数组  let lastEnd = 0; // 记录最后一个活动的结束时间
  for(let i = 0; i &lt; activities.length; i++){    const act = activities[i];    if(act.start &gt;= lastEnd) {      res.push(act);      lastEnd = act.end    }  }
  return res;}
// 测试一下const result = chooseActivity(activities);console.log(result);
</code></pre></div><p>上面代码的运行结果如下：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>贪心算法的重点就在一个贪字，要找到贪的对象，然后不断的贪，最后把目标贪完，输出最优解。要注意的是，每次贪的时候其实拿到的都只是局部最优解，局部最优解不一定组成全局最优解，比如0-1背包，对于这种问题是不能用贪心的，要用其他方法求解。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">5/8/2024, 3:01:19 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/algorithm/排序/排序.html" class="prev">
        排序
      </a></span> <span class="next"><a href="/algorithm/简单复习下前端算法复杂度相关的知识.html">
        简单复习下前端算法复杂度相关的知识
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.950eebbc.js" defer></script><script src="/assets/js/2.57da4f88.js" defer></script><script src="/assets/js/1.a76cc220.js" defer></script><script src="/assets/js/27.2565321e.js" defer></script>
  </body>
</html>
