<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端进阶算法：常见算法题及完美题解 | duangdong的algorithm</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/logo.png">
    <link rel="manifest" href="/manifest.json">
    <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?0088ce24040b03f2947322ab31d23414";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
    <script>
  var _hmt = _hmt || [];
  _hmt.push(['_requirePlugin', 'UrlChangeTracker', {
    shouldTrackUrlChange: function (newPath, oldPath) {
      newPath = newPath.split('#')[0];
      oldPath = oldPath.split('#')[0];
      return newPath != oldPath;
    }}
  ]);
  </script>
    <meta name="description" content="前端相关知识归纳总结">
    <meta name="keywords" content="qd-blog,node,vuepress,leetcode,algorithm">
    
    <link rel="preload" href="/assets/css/0.styles.b4a844ec.css" as="style"><link rel="preload" href="/assets/js/app.950eebbc.js" as="script"><link rel="preload" href="/assets/js/2.57da4f88.js" as="script"><link rel="preload" href="/assets/js/1.a76cc220.js" as="script"><link rel="preload" href="/assets/js/49.24929fd6.js" as="script"><link rel="prefetch" href="/assets/js/10.50f73657.js"><link rel="prefetch" href="/assets/js/11.0390ceee.js"><link rel="prefetch" href="/assets/js/12.f88bec36.js"><link rel="prefetch" href="/assets/js/13.963ad03b.js"><link rel="prefetch" href="/assets/js/14.512f15b9.js"><link rel="prefetch" href="/assets/js/15.a674496c.js"><link rel="prefetch" href="/assets/js/16.ed7e507f.js"><link rel="prefetch" href="/assets/js/17.de667ca5.js"><link rel="prefetch" href="/assets/js/18.b44e84af.js"><link rel="prefetch" href="/assets/js/19.5b5ad6a1.js"><link rel="prefetch" href="/assets/js/20.6800493a.js"><link rel="prefetch" href="/assets/js/21.6589052c.js"><link rel="prefetch" href="/assets/js/22.f648d829.js"><link rel="prefetch" href="/assets/js/23.b85d0d4e.js"><link rel="prefetch" href="/assets/js/24.d81147fb.js"><link rel="prefetch" href="/assets/js/25.ed5233ca.js"><link rel="prefetch" href="/assets/js/26.83f1ef57.js"><link rel="prefetch" href="/assets/js/27.2565321e.js"><link rel="prefetch" href="/assets/js/28.e60083e4.js"><link rel="prefetch" href="/assets/js/29.49b5374e.js"><link rel="prefetch" href="/assets/js/3.13e892f5.js"><link rel="prefetch" href="/assets/js/30.9ad0e230.js"><link rel="prefetch" href="/assets/js/31.c97534c6.js"><link rel="prefetch" href="/assets/js/32.b90554dc.js"><link rel="prefetch" href="/assets/js/33.9d15b4c0.js"><link rel="prefetch" href="/assets/js/34.297b5f45.js"><link rel="prefetch" href="/assets/js/35.029c4cac.js"><link rel="prefetch" href="/assets/js/36.bc299146.js"><link rel="prefetch" href="/assets/js/37.9068edfd.js"><link rel="prefetch" href="/assets/js/38.8c781d87.js"><link rel="prefetch" href="/assets/js/39.87c06c9c.js"><link rel="prefetch" href="/assets/js/4.5bdb9365.js"><link rel="prefetch" href="/assets/js/40.b05763a5.js"><link rel="prefetch" href="/assets/js/41.447511bf.js"><link rel="prefetch" href="/assets/js/42.cef1f724.js"><link rel="prefetch" href="/assets/js/43.cae02230.js"><link rel="prefetch" href="/assets/js/44.833e4694.js"><link rel="prefetch" href="/assets/js/45.2933ab3e.js"><link rel="prefetch" href="/assets/js/46.1108fab7.js"><link rel="prefetch" href="/assets/js/47.1a5b2293.js"><link rel="prefetch" href="/assets/js/48.3f01058a.js"><link rel="prefetch" href="/assets/js/5.7c68fdb5.js"><link rel="prefetch" href="/assets/js/50.7e052a76.js"><link rel="prefetch" href="/assets/js/51.ae3eb599.js"><link rel="prefetch" href="/assets/js/52.bab65685.js"><link rel="prefetch" href="/assets/js/53.abacf47c.js"><link rel="prefetch" href="/assets/js/54.9d8ffddf.js"><link rel="prefetch" href="/assets/js/55.ac9707fe.js"><link rel="prefetch" href="/assets/js/56.9a9c42d4.js"><link rel="prefetch" href="/assets/js/57.f4d88e89.js"><link rel="prefetch" href="/assets/js/58.816a3870.js"><link rel="prefetch" href="/assets/js/59.8a6b3c7f.js"><link rel="prefetch" href="/assets/js/6.c8da7ca7.js"><link rel="prefetch" href="/assets/js/7.e4c88d0e.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.5143d2e0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b4a844ec.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">duangdong的algorithm</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/algorithm/" class="nav-link">
  数据结构
</a></div><div class="nav-item"><a href="/leetcode/" class="nav-link">
  Leetcode
</a></div><div class="nav-item"><a href="/leetcode-summary/" class="nav-link router-link-active">
  算法题
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/algorithm/" class="nav-link">
  数据结构
</a></div><div class="nav-item"><a href="/leetcode/" class="nav-link">
  Leetcode
</a></div><div class="nav-item"><a href="/leetcode-summary/" class="nav-link router-link-active">
  算法题
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/leetcode-summary/" aria-current="page" class="sidebar-link">leetcode</a></li><li><a href="/leetcode-summary/esay算法题解.html" class="sidebar-link">LeetCode 热题 HOT 100题解 (easy级别)</a></li><li><a href="/leetcode-summary/三角形周长.html" class="sidebar-link">976三角形周长</a></li><li><a href="/leetcode-summary/常见算法题及完美题解.html" class="active sidebar-link">前端进阶算法：常见算法题及完美题解</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="前端进阶算法-常见算法题及完美题解"><a href="#前端进阶算法-常见算法题及完美题解" class="header-anchor">#</a> 前端进阶算法：常见算法题及完美题解</h2> <blockquote><p><a href="https://mp.weixin.qq.com/s/m_NqYrvWj008IIj2-46keQ" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/m_NqYrvWj008IIj2-46keQ<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h3 id="引言"><a href="#引言" class="header-anchor">#</a> 引言</h3> <p>瓶子君又来啦，她带着前端算法来了👏👏👏</p> <p>大厂面试越来越难，对算法的要求也越来越多，当面试官问到一个算法题，给出一份完美答案能大大提高面试官的好感度，本系列就是致力于打造一套适用于前端的算法。</p> <p><strong>往期精彩系列</strong></p> <ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247484391&amp;idx=1&amp;sn=fd828d06827160b94c69cf4c9e37f545&amp;chksm=faec873fcd9b0e2936ef8b22d082b130605f5ee64c3999ba32121ee0e4e18b6676c44d77060c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">视频面试超高频在线编程题，搞懂这些足以应对大部分公司<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247484417&amp;idx=1&amp;sn=c08cd285e412053dc2c2f1336752c5c9&amp;chksm=faec80d9cd9b09cf266f62dbc5a1b26f5c9f897f6509ed379a20a8333a005b2d8701f6b9bb37&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">前端进阶算法5：全方位解读前端用到的栈结构（+leetcode刷题）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247484298&amp;idx=1&amp;sn=846c8c4117fa0eb5f9a7e66c54b7ae5a&amp;chksm=faec8752cd9b0e44326a3b532ec3e5f57498c83642211c68017dd212f1ddeca53b45b44fe42e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">10 问 10 答，带你快速入门前端算法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247484292&amp;idx=1&amp;sn=c2dfcccab0ed82267061340f969d5de2&amp;chksm=faec875ccd9b0e4a4b1b015785bd439c9ec37ca6882e9b18f66c523e03110e29f1b6d4c57f62&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">前端进阶算法4：链表原来如此简单(+leetcode刷题）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247484265&amp;idx=1&amp;sn=7feafe63a80ce6371a1b6834884a6d05&amp;chksm=faec87b1cd9b0ea7ea773e24341918cefa1df7ccbc2c12c0fee679fcf62d2603f86351f732d1&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">前端进阶算法3：从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247484249&amp;idx=1&amp;sn=0352d8071caac441ff1c5af3260fe484&amp;chksm=faec8781cd9b0e97bfab3b48f51fc9172b2409378f890de8017d5cd2c62bb004ee58fc8d522c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">瓶子君前端算法集训营第一期开营啦，免费哟<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247484213&amp;idx=1&amp;sn=6b7b9cd11b7a151b1b5396c918d7692f&amp;chksm=faec87edcd9b0efb118b006b13b3df234aa3c8a5aa5bcd168cdf07ee3990fee28a5f039baa0f&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">前端进阶算法2：从Chrome  V8源码看JavaScript数组(附赠腾讯面试题)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&amp;mid=2247484204&amp;idx=1&amp;sn=3433b9191b67ac9b09452b0d6e3a0639&amp;chksm=faec87f4cd9b0ee213f03f451069f4c5fd352cf0c573d043c1819760ef1085a4457af99605a8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">前端进阶算法1：如何分析、统计算法的执行效率和资源消耗？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <p><strong>以及题目：</strong></p> <ul><li><strong>图解leetcode88：合并两个有序数组</strong>[8]</li> <li><strong>字节&amp;leetcode1：两数之和</strong>[9]</li> <li><strong>腾讯：数组扁平化、去重、排序</strong>[10]</li> <li><strong>leetcode349：给定两个数组，编写一个函数来计算它们的交集</strong>[11]</li> <li><strong>leetcode146：设计和实现一个LRU（最近最少使用）缓存机制</strong>[12]</li> <li><strong>阿里算法题：编写一个函数计算多个数组的交集</strong>[13]</li> <li><strong>leetcode21：合并两个有序链表</strong>[14]</li> <li><strong>有赞&amp;leetcode141：判断一个单链表是否有环</strong>[15]</li> <li><strong>图解leetcode206：反转链表</strong>[16]</li> <li><strong>leetcode876：求链表的中间结点</strong>[17]</li> <li><strong>leetcode19：删除链表倒数第 n 个结点</strong>[18]</li> <li><strong>图解字节&amp;leetcode160：编写一个程序，找到两个单链表相交的起始节点</strong>[19]</li> <li><strong>图解字节&amp;leetcode151：翻转字符串里的单词</strong>[20]</li> <li><strong>图解leetcode14：最长公共前缀</strong>[21]</li> <li><strong>百度：实现一个函数，判断输入是不是回文字符串</strong>[22]</li> <li><strong>字节&amp;Leetcode3：无重复字符的最长子串</strong>[23]</li> <li><strong>字节&amp;leetcode155：最小栈（包含getMin函数的栈）</strong>[24]</li> <li><strong>图解腾讯&amp;leetcode20：有效的括号</strong>[25]</li> <li><strong>leetcode1047：删除字符串中的所有相邻重复项</strong>[26]</li></ul> <p>本节是第四周的总结与回顾，下面开始进入正题吧！👇👇👇</p> <h3 id="一、百度-实现一个函数-判断输入是不是回文字符串"><a href="#一、百度-实现一个函数-判断输入是不是回文字符串" class="header-anchor">#</a> 一、百度：实现一个函数，判断输入是不是回文字符串</h3> <h4 id="_1-解法一-使用api"><a href="#_1-解法一-使用api" class="header-anchor">#</a> 1. 解法一：使用API</h4> <div class="language- extra-class"><pre class="language-text"><code>function isPlalindrome(input) {
  if (typeof input !== 'string') return false;
  return input.split('').reverse().join('') === input;
}
</code></pre></div><h4 id="_2-解法二-不使用api"><a href="#_2-解法二-不使用api" class="header-anchor">#</a> 2. 解法二：不使用API</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">isPlalindrome</span><span class="token punctuation">(</span><span class="token parameter">input</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> input <span class="token operator">!==</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> input<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!==</span> input<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>
      i <span class="token operator">++</span>
      j <span class="token operator">--</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_3-更多题解"><a href="#_3-更多题解" class="header-anchor">#</a> 3. 更多题解</h4> <p>详见 <strong>百度：实现一个函数，判断输入是不是回文字符串</strong>[27]</p> <h3 id="二、字节-leetcode3-无重复字符的最长子串"><a href="#二、字节-leetcode3-无重复字符的最长子串" class="header-anchor">#</a> 二、字节&amp;Leetcode3：无重复字符的最长子串</h3> <h4 id="_1-题目"><a href="#_1-题目" class="header-anchor">#</a> 1. 题目</h4> <p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p> <p><strong>示例 1:</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入: &quot;abcabcbb&quot;
输出: 3 
解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。
</code></pre></div><p><strong>示例 2:</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入: &quot;bbbbb&quot;
输出: 1
解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。
</code></pre></div><p><strong>示例 3:</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入: &quot;pwwkew&quot;
输出: 3
解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。
</code></pre></div><h4 id="_2-解法"><a href="#_2-解法" class="header-anchor">#</a> 2. 解法</h4> <h5 id="解法一-维护数组"><a href="#解法一-维护数组" class="header-anchor">#</a> 解法一：维护数组</h5> <p><strong>解题思路：</strong> 使用一个数组来维护滑动窗口</p> <p>遍历字符串，判断字符是否在滑动窗口数组里</p> <ul><li>不在则 <code>push</code> 进数组</li> <li>在则删除滑动窗口数组里相同字符及相同字符前的字符，然后将当前字符 <code>push</code> 进数组</li> <li>然后将 <code>max</code> 更新为当前最长子串的长度</li></ul> <p>遍历完，返回 <code>max</code> 即可</p> <p><strong>画图帮助理解一下：</strong></p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQw4BiaO1joZ4nQECWOFon2PSQwbWtBx5L7QMT9icZQzNNghcgw50zia1SdnspK7opwyt11JPXTr4iakw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p><strong>代码实现：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>var lengthOfLongestSubstring = function(s) {
    let arr = [], max = 0
    for(let i = 0; i &lt; s.length; i++) {
        let index = arr.indexOf(s[i])
        if(index !== -1) {
            arr.splice(0, index+1);
        }
        arr.push(s.charAt(i))
        max = Math.max(arr.length, max) 
    }
    return max
};
</code></pre></div><p><strong>时间复杂度：O(n2)， 其中 <code>arr.indexOf()</code> 时间复杂度为 O(n) ，<code>arr.splice(0, index+1)</code> 的时间复杂度也为 O(n)</strong></p> <p><strong>空间复杂度：O(n)</strong></p> <h5 id="解法二-维护下标"><a href="#解法二-维护下标" class="header-anchor">#</a> 解法二：维护下标</h5> <p><strong>解题思路：</strong> 使用下标来维护滑动窗口</p> <p><strong>代码实现：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>var lengthOfLongestSubstring = function(s) {
    let index = 0, max = 0
    for(let i = 0, j = 0; j &lt; s.length; j++) {
        index = s.substring(i, j).indexOf(s[j]) 
        if(index !== -1) { 
            i = i + index + 1 
        } 
        max = Math.max(max, j - i + 1) 
    }
    return max
};
</code></pre></div><p><strong>时间复杂度：O(n2)</strong></p> <p><strong>空间复杂度：O(n)</strong></p> <h5 id="解法三-优化的map"><a href="#解法三-优化的map" class="header-anchor">#</a> 解法三：优化的Map</h5> <p><strong>解题思路：</strong></p> <p>使用 <code>map</code> 来存储当前已经遍历过的字符，<code>key</code> 为字符，<code>value</code> 为下标</p> <p>使用 <code>i</code> 来标记无重复子串开始下标，<code>j</code> 为当前遍历字符下标</p> <p>遍历字符串，判断当前字符是否已经在 <code>map</code> 中存在，存在则更新无重复子串开始下标 <code>i</code> 为相同字符的下一位置，此时从 <code>i</code> 到 <code>j</code> 为最新的无重复子串，更新 <code>max</code> ，将当前字符与下标放入 <code>map</code> 中</p> <p>最后，返回 <code>max</code> 即可</p> <p><strong>代码实现：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>var lengthOfLongestSubstring = function(s) {
    let map = new Map(), max = 0
    for(let i = 0, j = 0; j &lt; s.length; j++) {
        if(map.has(s[j])) {
            i = Math.max(map.get(s[j]) + 1, i)
        }
        max = Math.max(max, j - i + 1)
        map.set(s[j], j)
    }
    return max
};
</code></pre></div><p><strong>时间复杂度：O(n)</strong></p> <p><strong>空间复杂度：O(n)</strong></p> <h4 id="_3-更多题解-2"><a href="#_3-更多题解-2" class="header-anchor">#</a> 3. 更多题解</h4> <p>详见 <strong>字节&amp;Leetcode3：无重复字符的最长子串</strong>[28]</p> <h3 id="三、文章-全方位解读栈结构"><a href="#三、文章-全方位解读栈结构" class="header-anchor">#</a> 三、文章：全方位解读栈结构</h3> <h4 id="_1-数据结构栈"><a href="#_1-数据结构栈" class="header-anchor">#</a> 1. 数据结构栈</h4> <p>栈是一种遵从后进先出 (LIFO / Last In First Out) 原则的有序集合，它的结构类似如下：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p><strong>代码实现</strong></p> <div class="language- extra-class"><pre class="language-text"><code>function Stack() {
  let items = []
  this.push = function(e) { 
    items.push(e) 
  }
  this.pop = function() { 
    return items.pop() 
  }
  this.isEmpty = function() { 
    return items.length === 0 
  }
  this.size = function() { 
    return items.length 
  }
  this.clear = function() { 
    items = [] 
  }
}
</code></pre></div><p><strong>查找：从栈头开始查找，时间复杂度为 O(n)</strong></p> <p><strong>插入或删除：进栈与出栈的时间复杂度为 O(1)</strong></p> <h4 id="_2-面试-调用栈"><a href="#_2-面试-调用栈" class="header-anchor">#</a> 2. 面试：调用栈</h4> <blockquote><p>调用栈是 JavaScript 用来管理函数执行上下文的一种数据结构，它记录了当前函数执行的位置，哪个函数正在被执行。如果我们执行一个函数，就会为函数创建执行上下文并放入栈顶。如果我们从函数返回，就将它的执行上下文从栈顶弹出。也可以说调用栈是用来管理这种执行上下文的栈，或称执行上下文栈（执行栈）。</p></blockquote> <h4 id="_3-面试-栈空间与堆空间"><a href="#_3-面试-栈空间与堆空间" class="header-anchor">#</a> 3. 面试：栈空间与堆空间</h4> <p>JavaScript 中的内存空间主要分为三种类型：</p> <ul><li>代码空间：主要用来存放可执行代码</li> <li>栈空间：调用栈的存储空间就是栈空间。</li> <li>堆空间</li></ul> <p>代码空间主要用来存放可执行代码的。栈空间及堆空间主要用来存放数据的。接下来我们主要介绍栈空间及堆空间。</p> <p>当调用栈中执行完成一个执行上下文时，需要进行垃圾回收该上下文以及相关数据空间，存放在栈空间上的数据通过 ESP 指针来回收，存放在堆空间的数据通过副垃圾回收器（新生代）与主垃圾回收器（老生代）来回收。</p> <h4 id="_4-详情"><a href="#_4-详情" class="header-anchor">#</a> 4. 详情</h4> <p>详细请看 <strong>前端进阶算法5：全方位解读前端用到的栈结构（+leetcode刷题）</strong>[29]</p> <h3 id="四、字节-leetcode155-最小栈-包含getmin函数的栈"><a href="#四、字节-leetcode155-最小栈-包含getmin函数的栈" class="header-anchor">#</a> 四、字节&amp;leetcode155：最小栈（包含getMin函数的栈）</h3> <h4 id="_1-题目-2"><a href="#_1-题目-2" class="header-anchor">#</a> 1. 题目</h4> <p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p> <ul><li><code>push(x)</code> —— 将元素 x 推入栈中。</li> <li><code>pop()</code> —— 删除栈顶的元素。</li> <li><code>top()</code> —— 获取栈顶元素。</li> <li><code>getMin()</code> —— 检索栈中的最小元素。</li></ul> <p><strong>示例:</strong></p> <div class="language- extra-class"><pre class="language-text"><code>MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --&gt; 返回 -3.
minStack.pop();
minStack.top();      --&gt; 返回 0.
minStack.getMin();   --&gt; 返回 -2.
</code></pre></div><h4 id="_2-解法-2"><a href="#_2-解法-2" class="header-anchor">#</a> 2. 解法</h4> <p>在常数时间内检索到最小元素的栈，即仅需保证 <code>getMin</code> 的时间复杂度为 O(1) 即可</p> <div class="language- extra-class"><pre class="language-text"><code>var MinStack = function() {
    this.items = []
    this.min = null
};

// 进栈
MinStack.prototype.push = function(x) {
    if(!this.items.length) this.min = x 
    this.min = Math.min(x, this.min)
    this.items.push(x) 
};

// 出栈
MinStack.prototype.pop = function() {
    let num = this.items.pop() 
    this.min = Math.min(...this.items)
    return num
};

// 获取栈顶元素
MinStack.prototype.top = function() {
    if(!this.items.length) return null
    return this.items[this.items.length -1] 
};

// 检索栈中的最小元素
MinStack.prototype.getMin = function() {
    return this.min
};
</code></pre></div><p><strong>时间复杂度：进栈O(1)，出栈O(n)，获取栈顶元素O(1)，获取最小元素O(1)</strong></p> <p><strong>空间复杂度：O(n)</strong></p> <h4 id="_3-更多题解-3"><a href="#_3-更多题解-3" class="header-anchor">#</a> 3. 更多题解</h4> <p>详见 <strong>字节&amp;leetcode155：最小栈（包含getMin函数的栈）</strong>[30]</p> <h3 id="五、图解腾讯-leetcode20-有效的括号"><a href="#五、图解腾讯-leetcode20-有效的括号" class="header-anchor">#</a> 五、图解腾讯&amp;leetcode20：有效的括号</h3> <h4 id="_1-题目-3"><a href="#_1-题目-3" class="header-anchor">#</a> 1. 题目</h4> <p>给定一个只包括 <code>'('</code> ，<code>')'</code> ，<code>'{'</code> ，<code>'}'</code> ，<code>'['</code> ，<code>']'</code> 的字符串，判断字符串是否有效。</p> <p>有效字符串需满足：</p> <ul><li>左括号必须用相同类型的右括号闭合。</li> <li>左括号必须以正确的顺序闭合。</li></ul> <p>注意空字符串可被认为是有效字符串。</p> <p><strong>示例 1:</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入: &quot;()&quot;
输出: true
</code></pre></div><p><strong>示例 2:</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入: &quot;()[]{}&quot;
输出: true
</code></pre></div><p><strong>示例 3:</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入: &quot;(]&quot;
输出: false
</code></pre></div><p><strong>示例 4:</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入: &quot;([)]&quot;
输出: false
</code></pre></div><p><strong>示例 5:</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入: &quot;{[]}&quot;
输出: true
</code></pre></div><h4 id="_2-解法-利用栈结构"><a href="#_2-解法-利用栈结构" class="header-anchor">#</a> 2. 解法：利用栈结构</h4> <p><strong>解题思路：</strong> 将字符串中的字符依次入栈，遍历字符依次判断：</p> <ul><li>首先判断该元素是否是 <code>{</code> 、 <code>(</code> 、 <code>[</code> ，直接入栈</li> <li>否则该字符为 <code>}</code> 、 <code>)</code> 、 <code>]</code> 中的一种，如果该字符串有效，则该元素应该与栈顶匹配，例如栈中元素有 <code>({</code>， 如果继续遍历到的元素为 <code>)</code>, 那么当前元素序列为 <code>({)</code> 是不可能有效的，所以此时与栈顶元素匹配失败，则直接返回 <code>false</code> ，字符串无效</li></ul> <p>当遍历完成时，所有已匹配的字符都已匹配出栈，如果此时栈为空，则字符串有效，如果栈不为空，说明字符串中还有未匹配的字符，字符串无效</p> <p><strong>画图帮助理解一下：</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p><strong>代码实现：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>var isValid = function(s) {
    let map = {
        '{': '}',
        '(': ')',
        '[': ']'
    }
    let stack = []
    for(let i = 0; i &lt; s.length ; i++) {
        if(map[s[i]]) {
            stack.push(s[i])
        } else if(s[i] !== map[stack.pop()]){
            return false
        }
    }
    return stack.length === 0
};
</code></pre></div><p><strong>时间复杂度：O(n)</strong></p> <p><strong>空间复杂度：O(n)</strong></p> <h4 id="_3-更多题解-4"><a href="#_3-更多题解-4" class="header-anchor">#</a> 3. 更多题解</h4> <p>详见 <strong>图解腾讯&amp;leetcode20：有效的括号</strong>[31]</p> <h3 id="六、leetcode1047-删除字符串中的所有相邻重复项"><a href="#六、leetcode1047-删除字符串中的所有相邻重复项" class="header-anchor">#</a> 六、leetcode1047：删除字符串中的所有相邻重复项</h3> <h4 id="_1-题目-4"><a href="#_1-题目-4" class="header-anchor">#</a> 1. 题目</h4> <p>给出由小写字母组成的字符串 <code>S</code> ，<strong>重复项删除操作</strong> 会选择两个相邻且相同的字母，并删除它们。</p> <p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p> <p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p> <p><strong>示例：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入：&quot;abbaca&quot;
输出：&quot;ca&quot;
解释：
例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。
</code></pre></div><p><strong>提示：</strong></p> <ol><li><code>&lt;= S.length &lt;= 20000</code></li> <li><code>S</code> 仅由小写英文字母组成。</li></ol> <h4 id="_2-解法-利用栈"><a href="#_2-解法-利用栈" class="header-anchor">#</a> 2. 解法：利用栈</h4> <p><strong>解题思路：</strong> 遍历字符串，依次入栈，入栈时判断与栈头元素是否一致，如果一致，即这两个元素相同相邻，则需要将栈头元素出栈，并且当前元素也无需入栈</p> <p><strong>解题步骤：</strong> 遍历字符串，取出栈头字符，判断当前字符与栈头字符是否一致</p> <ul><li>不一致，栈头字符进栈，当前字符进栈</li> <li>一致，即栈头字符与当前字符相同相邻，都不需要进栈，直接进入下次遍历即可</li></ul> <p>遍历完成后，返回栈中字符串</p> <p><strong>代码实现：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>var removeDuplicates = function(S) {
    let stack = []
    for(c of S) {
        let prev = stack.pop()
        if(prev !== c) {
            stack.push(prev)
            stack.push(c)
        }
    }
    return stack.join('')
};
</code></pre></div><p><strong>时间复杂度：O(n)</strong></p> <p><strong>空间复杂度：O(n)</strong></p> <h4 id="_3-更多题解-5"><a href="#_3-更多题解-5" class="header-anchor">#</a> 3. 更多题解</h4> <p>详见 <strong>leetcode1047：删除字符串中的所有相邻重复项</strong>[32]</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">5/8/2024, 3:01:19 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/leetcode-summary/三角形周长.html" class="prev">
        976三角形周长
      </a></span> <!----></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.950eebbc.js" defer></script><script src="/assets/js/2.57da4f88.js" defer></script><script src="/assets/js/1.a76cc220.js" defer></script><script src="/assets/js/49.24929fd6.js" defer></script>
  </body>
</html>
