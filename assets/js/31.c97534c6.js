(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{323:function(e,n,d){"use strict";d.r(n);var t=d(4),l=Object(t.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"_15张图-20分钟吃透diff算法核心原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_15张图-20分钟吃透diff算法核心原理"}},[e._v("#")]),e._v(" 15张图，20分钟吃透Diff算法核心原理")]),e._v(" "),n("blockquote",[n("p",[n("a",{attrs:{href:"https://mp.weixin.qq.com/s/ItHi1Vj6DPxtn8DjqJyCLw",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://mp.weixin.qq.com/s/ItHi1Vj6DPxtn8DjqJyCLw"),n("OutboundLink")],1)])]),e._v(" "),n("h2",{attrs:{id:"前言"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),n("p",[e._v("大家好，我是林三心，在日常面试中，"),n("code",[e._v("Diff算法")]),e._v("都是绕不过去的一道坎，"),n("strong",[e._v("用最通俗的话，讲最难的知识点")]),e._v("一直是我写文章的宗旨，今天我就用通俗的方式来讲解一下"),n("code",[e._v("Diff算法")]),e._v("吧？Lets Go")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdhLrBiatSxv9I8lK30ickrqtorqZ5G95cu521dKCicuIcoR6iahZIricvDz75LgNhvkUDIIjHcJtUO0lcQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),e._v("image.png")]),e._v(" "),n("h2",{attrs:{id:"什么是虚拟dom"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是虚拟dom"}},[e._v("#")]),e._v(" 什么是虚拟DOM")]),e._v(" "),n("p",[e._v("讲"),n("code",[e._v("Diff算法")]),e._v("前，我先给大家讲一讲什么是"),n("code",[e._v("虚拟DOM")]),e._v("吧。这有利于后面大家对"),n("code",[e._v("Diff算法")]),e._v("的理解加深。")]),e._v(" "),n("p",[n("code",[e._v("虚拟DOM")]),e._v("是一个"),n("code",[e._v("对象")]),e._v("，一个什么样的对象呢？"),n("strong",[e._v("一个用来表示真实DOM的对象")]),e._v("，要记住这句话。我举个例子，请看以下"),n("code",[e._v("真实DOM")]),e._v("：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<ul id="list">\n    <li class="item">哈哈</li>\n    <li class="item">呵呵</li>\n    <li class="item">嘿嘿</li>\n</ul>\n')])])]),n("p",[e._v("对应的"),n("code",[e._v("虚拟DOM")]),e._v("为：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let oldVDOM = { // 旧虚拟DOM\n        tagName: 'ul', // 标签名\n        props: { // 标签属性\n            id: 'list'\n        },\n        children: [ // 标签子节点\n            {\n                tagName: 'li', props: { class: 'item' }, children: ['哈哈']\n            },\n            {\n                tagName: 'li', props: { class: 'item' }, children: ['呵呵']\n            },\n            {\n                tagName: 'li', props: { class: 'item' }, children: ['嘿嘿']\n            },\n        ]\n    }\n")])])]),n("p",[e._v("这时候，我修改一个"),n("code",[e._v("li标签")]),e._v("的文本：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<ul id="list">\n    <li class="item">哈哈</li>\n    <li class="item">呵呵</li>\n    <li class="item">林三心哈哈哈哈哈</li> // 修改\n</ul>\n')])])]),n("p",[e._v("这时候生成的"),n("code",[e._v("新虚拟DOM")]),e._v("为：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let newVDOM = { // 新虚拟DOM\n        tagName: 'ul', // 标签名\n        props: { // 标签属性\n            id: 'list'\n        },\n        children: [ // 标签子节点\n            {\n                tagName: 'li', props: { class: 'item' }, children: ['哈哈']\n            },\n            {\n                tagName: 'li', props: { class: 'item' }, children: ['呵呵']\n            },\n            {\n                tagName: 'li', props: { class: 'item' }, children: ['林三心哈哈哈哈哈']\n            },\n        ]\n    }\n")])])]),n("p",[e._v("这就是咱们平常说的"),n("code",[e._v("新旧两个虚拟DOM")]),e._v("，这个时候的"),n("code",[e._v("新虚拟DOM")]),e._v("是数据的最新状态，那么我们直接拿"),n("code",[e._v("新虚拟DOM")]),e._v("去渲染成"),n("code",[e._v("真实DOM")]),e._v("的话，效率真的会比直接操作真实DOM高吗？那肯定是不会的，看下图：")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdhLrBiatSxv9I8lK30ickrqtoJqniarIBeTbcicrOfkdia62RjFS6nlYzFb9u5cl90MgTwwWuNcmgEh11g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),e._v("截屏2021-08-07 下午10.24.17.png")]),e._v(" "),n("p",[e._v("由上图，一看便知，肯定是第2种方式比较快，因为第1种方式中间还夹着一个"),n("code",[e._v("虚拟DOM")]),e._v("的步骤，所以"),n("strong",[e._v("虚拟DOM比真实DOM快")]),e._v("这句话其实是错的，或者说是不严谨的。那正确的说法是什么呢？"),n("strong",[e._v("虚拟DOM算法操作真实DOM，性能高于直接操作真实DOM")]),e._v("，"),n("code",[e._v("虚拟DOM")]),e._v("和"),n("code",[e._v("虚拟DOM算法")]),e._v("是两种概念。"),n("code",[e._v("虚拟DOM算法 = 虚拟DOM + Diff算法")])]),e._v(" "),n("p",[n("img",{attrs:{src:"http://mmbiz.qpic.cn/mmbiz_png/jQmwTIFl1V0dLQzNJW15CVaCoNjposvTpccciaj05o5nPiaqfLRRfTQiaYFYPN41Etrrqt8jPOWukPmJWt3lYxwuA/0?wx_fmt=png",alt:"全栈修仙之路"}})]),e._v(" "),n("p",[n("strong",[e._v("全栈修仙之路")])]),e._v(" "),n("p",[e._v("专注分享 TS、Vue3、前端架构和源码解析等技术干货。")]),e._v(" "),n("p",[e._v("132篇原创内容")]),e._v(" "),n("p",[e._v("公众号")]),e._v(" "),n("h2",{attrs:{id:"什么是diff算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是diff算法"}},[e._v("#")]),e._v(" 什么是Diff算法")]),e._v(" "),n("p",[e._v("上面咱们说了"),n("code",[e._v("虚拟DOM")]),e._v("，也知道了只有"),n("code",[e._v("虚拟DOM + Diff算法")]),e._v("才能真正的提高性能，那讲完"),n("code",[e._v("虚拟DOM")]),e._v("，我们再来讲讲"),n("code",[e._v("Diff算法")]),e._v("吧，还是上面的例子(这张图被压缩的有点小，大家可以打开看，比较清晰)：")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdhLrBiatSxv9I8lK30ickrqtoWXgD7FvHpiassHBqU2PsZagOniaVOVoSp63das2yZQZwibKULQs3peakQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),n("p",[e._v("上图中，其实只有一个li标签修改了文本，其他都是不变的，所以没必要所有的节点都要更新，只更新这个li标签就行，Diff算法就是查出这个li标签的算法。")]),e._v(" "),n("p",[e._v("总结："),n("strong",[e._v("Diff算法是一种对比算法")]),e._v("。对比两者是"),n("code",[e._v("旧虚拟DOM和新虚拟DOM")]),e._v("，对比出是哪个"),n("code",[e._v("虚拟节点")]),e._v("更改了，找出这个"),n("code",[e._v("虚拟节点")]),e._v("，并只更新这个虚拟节点所对应的"),n("code",[e._v("真实节点")]),e._v("，而不用更新其他数据没发生改变的节点，实现"),n("code",[e._v("精准")]),e._v("地更新真实DOM，进而"),n("code",[e._v("提高效率")]),e._v("。")]),e._v(" "),n("p",[n("code",[e._v("使用虚拟DOM算法的损耗计算")]),e._v("：总损耗 = 虚拟DOM增删改+（与Diff算法效率有关）真实DOM差异增删改+（较少的节点）排版与重绘")]),e._v(" "),n("p",[n("code",[e._v("直接操作真实DOM的损耗计算")]),e._v("：总损耗 = 真实DOM完全增删改+（可能较多的节点）排版与重绘")]),e._v(" "),n("h2",{attrs:{id:"diff算法的原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#diff算法的原理"}},[e._v("#")]),e._v(" Diff算法的原理")]),e._v(" "),n("h3",{attrs:{id:"diff同层对比"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#diff同层对比"}},[e._v("#")]),e._v(" Diff同层对比")]),e._v(" "),n("p",[e._v("新旧虚拟DOM对比的时候，Diff算法比较只会在同层级进行, 不会跨层级比较。所以Diff算法是:"),n("code",[e._v("广度优先算法")]),e._v("。 时间复杂度:"),n("code",[e._v("O(n)")])]),e._v(" "),n("p",[n("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdhLrBiatSxv9I8lK30ickrqtoNkDiaiaSibhyicI9sGtRW2sakb5mJzTrfjGjUN6slJTXZU194yqgGzWo7A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),n("h3",{attrs:{id:"diff对比流程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#diff对比流程"}},[e._v("#")]),e._v(" Diff对比流程")]),e._v(" "),n("p",[e._v("当数据改变时，会触发"),n("code",[e._v("setter")]),e._v("，并且通过"),n("code",[e._v("Dep.notify")]),e._v("去通知所有"),n("code",[e._v("订阅者Watcher")]),e._v("，订阅者们就会调用"),n("code",[e._v("patch方法")]),e._v("，给真实DOM打补丁，更新相应的视图。对于这一步不太了解的可以看一下我之前写Vue源码系列")]),e._v(" "),n("p",[n("code",[e._v("newVnode和oldVnode")]),e._v("：同层的新旧虚拟节点"),n("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdhLrBiatSxv9I8lK30ickrqtoEnKXtB5y1oY93PyhGuyI3F0C88N47nm5OribFqHzgtB3zEkJIKrMwog/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),n("h3",{attrs:{id:"patch方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#patch方法"}},[e._v("#")]),e._v(" patch方法")]),e._v(" "),n("p",[e._v("这个方法作用就是，对比当前同层的虚拟节点是否为同一种类型的标签"),n("code",[e._v("(同一类型的标准，下面会讲)")]),e._v("：")]),e._v(" "),n("ul",[n("li",[e._v("是：继续执行"),n("code",[e._v("patchVnode方法")]),e._v("进行深层比对")]),e._v(" "),n("li",[e._v("否：没必要比对了，直接整个节点替换成"),n("code",[e._v("新虚拟节点")])])]),e._v(" "),n("p",[e._v("来看看"),n("code",[e._v("patch")]),e._v("的核心原理代码")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function patch(oldVnode, newVnode) {\n  // 比较是否为一个类型的节点\n  if (sameVnode(oldVnode, newVnode)) {\n    // 是：继续进行深层比较\n    patchVnode(oldVnode, newVnode)\n  } else {\n    // 否\n    const oldEl = oldVnode.el // 旧虚拟节点的真实DOM节点\n    const parentEle = api.parentNode(oldEl) // 获取父节点\n    createEle(newVnode) // 创建新虚拟节点对应的真实DOM节点\n    if (parentEle !== null) {\n      api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) // 将新元素添加进父元素\n      api.removeChild(parentEle, oldVnode.el)  // 移除以前的旧元素节点\n      // 设置null，释放内存\n      oldVnode = null\n    }\n  }\n\n  return newVnode\n}\n")])])]),n("h3",{attrs:{id:"samevnode方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#samevnode方法"}},[e._v("#")]),e._v(" sameVnode方法")]),e._v(" "),n("p",[e._v("patch关键的一步就是"),n("code",[e._v("sameVnode方法判断是否为同一类型节点")]),e._v("，那问题来了，怎么才算是同一类型节点呢？这个"),n("code",[e._v("类型")]),e._v("的标准是什么呢？")]),e._v(" "),n("p",[e._v("咱们来看看sameVnode方法的核心原理代码，就一目了然了")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function sameVnode(oldVnode, newVnode) {\n  return (\n    oldVnode.key === newVnode.key && // key值是否一样\n    oldVnode.tagName === newVnode.tagName && // 标签名是否一样\n    oldVnode.isComment === newVnode.isComment && // 是否都为注释节点\n    isDef(oldVnode.data) === isDef(newVnode.data) && // 是否都定义了data\n    sameInputType(oldVnode, newVnode) // 当标签为input时，type必须是否相同\n  )\n}\n")])])]),n("h3",{attrs:{id:"patchvnode方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#patchvnode方法"}},[e._v("#")]),e._v(" patchVnode方法")]),e._v(" "),n("p",[e._v("这个函数做了以下事情：")]),e._v(" "),n("ul",[n("li",[e._v("找到对应的"),n("code",[e._v("真实DOM")]),e._v("，称为"),n("code",[e._v("el")])]),e._v(" "),n("li",[e._v("判断"),n("code",[e._v("newVnode")]),e._v("和"),n("code",[e._v("oldVnode")]),e._v("是否指向同一个对象，如果是，那么直接"),n("code",[e._v("return")])]),e._v(" "),n("li",[e._v("如果他们都有文本节点并且不相等，那么将"),n("code",[e._v("el")]),e._v("的文本节点设置为"),n("code",[e._v("newVnode")]),e._v("的文本节点。")]),e._v(" "),n("li",[e._v("如果"),n("code",[e._v("oldVnode")]),e._v("有子节点而"),n("code",[e._v("newVnode")]),e._v("没有，则删除"),n("code",[e._v("el")]),e._v("的子节点")]),e._v(" "),n("li",[e._v("如果"),n("code",[e._v("oldVnode")]),e._v("没有子节点而"),n("code",[e._v("newVnode")]),e._v("有，则将"),n("code",[e._v("newVnode")]),e._v("的子节点真实化之后添加到"),n("code",[e._v("el")])]),e._v(" "),n("li",[e._v("如果两者都有子节点，则执行"),n("code",[e._v("updateChildren")]),e._v("函数比较子节点，这一步很重要")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function patchVnode(oldVnode, newVnode) {\n  const el = newVnode.el = oldVnode.el // 获取真实DOM对象\n  // 获取新旧虚拟节点的子节点数组\n  const oldCh = oldVnode.children, newCh = newVnode.children\n  // 如果新旧虚拟节点是同一个对象，则终止\n  if (oldVnode === newVnode) return\n  // 如果新旧虚拟节点是文本节点，且文本不一样\n  if (oldVnode.text !== null && newVnode.text !== null && oldVnode.text !== newVnode.text) {\n    // 则直接将真实DOM中文本更新为新虚拟节点的文本\n    api.setTextContent(el, newVnode.text)\n  } else {\n    // 否则\n\n    if (oldCh && newCh && oldCh !== newCh) {\n      // 新旧虚拟节点都有子节点，且子节点不一样\n\n      // 对比子节点，并更新\n      updateChildren(el, oldCh, newCh)\n    } else if (newCh) {\n      // 新虚拟节点有子节点，旧虚拟节点没有\n\n      // 创建新虚拟节点的子节点，并更新到真实DOM上去\n      createEle(newVnode)\n    } else if (oldCh) {\n      // 旧虚拟节点有子节点，新虚拟节点没有\n\n      //直接删除真实DOM里对应的子节点\n      api.removeChild(el)\n    }\n  }\n}\n")])])]),n("p",[e._v("其他几个点都很好理解，我们详细来讲一下"),n("code",[e._v("updateChildren")])]),e._v(" "),n("h3",{attrs:{id:"updatechildren方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#updatechildren方法"}},[e._v("#")]),e._v(" updateChildren方法")]),e._v(" "),n("p",[e._v("这是"),n("code",[e._v("patchVnode")]),e._v("里最重要的一个方法，新旧虚拟节点的子节点对比，就是发生在"),n("code",[e._v("updateChildren方法")]),e._v("中，接下来就结合一些图来讲，让大家更好理解吧")]),e._v(" "),n("p",[e._v("是怎么样一个对比方法呢？就是"),n("code",[e._v("首尾指针法")]),e._v("，新的子节点集合和旧的子节点集合，各有首尾两个指针，举个例子：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<ul>\n    <li>a</li>\n    <li>b</li>\n    <li>c</li>\n</ul>\n\n修改数据后\n\n<ul>\n    <li>b</li>\n    <li>c</li>\n    <li>e</li>\n    <li>a</li>\n</ul>\n")])])]),n("p",[e._v("那么新旧两个子节点集合以及其首尾指针为：")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdhLrBiatSxv9I8lK30ickrqtoia1qlNPJNT2M4J4HeHC2qXTMIkI4w0YcOxZy0oceX1Sw09dtPDrPdsw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),n("p",[e._v("然后会进行互相进行比较，总共有五种比较情况：")]),e._v(" "),n("ul",[n("li",[e._v("1、"),n("code",[e._v("oldS 和 newS")]),e._v("使用"),n("code",[e._v("sameVnode方法")]),e._v("进行比较，"),n("code",[e._v("sameVnode(oldS, newS)")])]),e._v(" "),n("li",[e._v("2、"),n("code",[e._v("oldS 和 newE")]),e._v("使用"),n("code",[e._v("sameVnode方法")]),e._v("进行比较，"),n("code",[e._v("sameVnode(oldS, newE)")])]),e._v(" "),n("li",[e._v("3、"),n("code",[e._v("oldE 和 newS")]),e._v("使用"),n("code",[e._v("sameVnode方法")]),e._v("进行比较，"),n("code",[e._v("sameVnode(oldE, newS)")])]),e._v(" "),n("li",[e._v("4、"),n("code",[e._v("oldE 和 newE")]),e._v("使用"),n("code",[e._v("sameVnode方法")]),e._v("进行比较，"),n("code",[e._v("sameVnode(oldE, newE)")])]),e._v(" "),n("li",[e._v("5、如果以上逻辑都匹配不到，再把所有旧子节点的 "),n("code",[e._v("key")]),e._v(" 做一个映射到旧节点下标的 "),n("code",[e._v("key -> index")]),e._v(" 表，然后用新 "),n("code",[e._v("vnode")]),e._v(" 的 "),n("code",[e._v("key")]),e._v(" 去找出在旧节点中可以复用的位置。")])]),e._v(" "),n("p",[n("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdhLrBiatSxv9I8lK30ickrqtoRpXCauQHJf4N0icibGMZAHgZtsEZSxHeAsHjAR9TMwxFAFic7PLcA2OUg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),n("p",[n("strong",[e._v("接下来就以上面代码为例，分析一下比较的过程")])]),e._v(" "),n("p",[e._v("分析之前，请大家记住一点，最终的渲染结果都要以newVDOM为准，这也解释了为什么之后的节点移动需要移动到newVDOM所对应的位置")]),e._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),n("ul",[n("li",[e._v("第一步")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("oldS = a, oldE = c\nnewS = b, newE = a\n")])])]),n("p",[e._v("比较结果："),n("code",[e._v("oldS 和 newE")]),e._v(" 相等，需要把"),n("code",[e._v("节点a")]),e._v("移动到"),n("code",[e._v("newE")]),e._v("所对应的位置，也就是末尾，同时"),n("code",[e._v("oldS++")]),e._v("，"),n("code",[e._v("newE--")])]),e._v(" "),n("p",[n("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdhLrBiatSxv9I8lK30ickrqtoNKRTCjnqN29GULBtbpFVXx3iaQNElckQy8rXlEAn39PWAX3ZwU67liaA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),n("ul",[n("li",[e._v("第二步")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("oldS = b, oldE = c\nnewS = b, newE = e\n")])])]),n("p",[e._v("比较结果："),n("code",[e._v("oldS 和 newS")]),e._v("相等，需要把"),n("code",[e._v("节点b")]),e._v("移动到"),n("code",[e._v("newS")]),e._v("所对应的位置，同时"),n("code",[e._v("oldS++")]),e._v(","),n("code",[e._v("newS++")])]),e._v(" "),n("p",[n("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdhLrBiatSxv9I8lK30ickrqtoHtvtdezJNOVtaZrCgicHMTdurYlbrFBOWfRU7vwDxRt5Z1o6Mptehmg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),n("ul",[n("li",[e._v("第三步")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("oldS = c, oldE = c\nnewS = c, newE = e\n")])])]),n("p",[e._v("比较结果："),n("code",[e._v("oldS、oldE 和 newS")]),e._v("相等，需要把"),n("code",[e._v("节点c")]),e._v("移动到"),n("code",[e._v("newS")]),e._v("所对应的位置，同时"),n("code",[e._v("oldS++")]),e._v(","),n("code",[e._v("oldE--")]),e._v(","),n("code",[e._v("newS++")])]),e._v(" "),n("p",[n("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdhLrBiatSxv9I8lK30ickrqtoI3CSxNmvJm0kebWTN9SZMdwk0FgMncDxrFACBzrAreWLoqeFpuhkQA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),n("ul",[n("li",[e._v("第四步 "),n("code",[e._v("oldS > oldE")]),e._v("，则"),n("code",[e._v("oldCh")]),e._v("先遍历完成了，而"),n("code",[e._v("newCh")]),e._v("还没遍历完，说明"),n("code",[e._v("newCh比oldCh多")]),e._v("，所以需要将多出来的节点，插入到真实DOM上对应的位置上")])]),e._v(" "),n("p",[n("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdhLrBiatSxv9I8lK30ickrqtoxvY0CYibQkdfAPfFIicoIpKzib7DRGd2QW8alWR6IDdt4ic2FGic8ibxctbA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),n("ul",[n("li",[e._v("思考题 我在这里给大家留一个思考题哈。上面的例子是"),n("code",[e._v("newCh比oldCh多")]),e._v("，假如相反，是"),n("code",[e._v("oldCh比newCh多")]),e._v("的话，那就是"),n("code",[e._v("newCh")]),e._v("先走完循环，然后"),n("code",[e._v("oldCh")]),e._v("会有多出的节点，结果会在真实DOM里进行删除这些旧节点。大家可以自己思考一下，模拟一下这个过程，像我一样，画图模拟，才能巩固上面的知识。")])]),e._v(" "),n("p",[e._v("附上"),n("code",[e._v("updateChildren")]),e._v("的核心原理代码")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function updateChildren(parentElm, oldCh, newCh) {\n  let oldStartIdx = 0, newStartIdx = 0\n  let oldEndIdx = oldCh.length - 1\n  let oldStartVnode = oldCh[0]\n  let oldEndVnode = oldCh[oldEndIdx]\n  let newEndIdx = newCh.length - 1\n  let newStartVnode = newCh[0]\n  let newEndVnode = newCh[newEndIdx]\n  let oldKeyToIdx\n  let idxInOld\n  let elmToMove\n  let before\n  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n    if (oldStartVnode == null) {\n      oldStartVnode = oldCh[++oldStartIdx]\n    } else if (oldEndVnode == null) {\n      oldEndVnode = oldCh[--oldEndIdx]\n    } else if (newStartVnode == null) {\n      newStartVnode = newCh[++newStartIdx]\n    } else if (newEndVnode == null) {\n      newEndVnode = newCh[--newEndIdx]\n    } else if (sameVnode(oldStartVnode, newStartVnode)) {\n      patchVnode(oldStartVnode, newStartVnode)\n      oldStartVnode = oldCh[++oldStartIdx]\n      newStartVnode = newCh[++newStartIdx]\n    } else if (sameVnode(oldEndVnode, newEndVnode)) {\n      patchVnode(oldEndVnode, newEndVnode)\n      oldEndVnode = oldCh[--oldEndIdx]\n      newEndVnode = newCh[--newEndIdx]\n    } else if (sameVnode(oldStartVnode, newEndVnode)) {\n      patchVnode(oldStartVnode, newEndVnode)\n      api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el))\n      oldStartVnode = oldCh[++oldStartIdx]\n      newEndVnode = newCh[--newEndIdx]\n    } else if (sameVnode(oldEndVnode, newStartVnode)) {\n      patchVnode(oldEndVnode, newStartVnode)\n      api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el)\n      oldEndVnode = oldCh[--oldEndIdx]\n      newStartVnode = newCh[++newStartIdx]\n    } else {\n      // 使用key时的比较\n      if (oldKeyToIdx === undefined) {\n        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 有key生成index表\n      }\n      idxInOld = oldKeyToIdx[newStartVnode.key]\n      if (!idxInOld) {\n        api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)\n        newStartVnode = newCh[++newStartIdx]\n      }\n      else {\n        elmToMove = oldCh[idxInOld]\n        if (elmToMove.sel !== newStartVnode.sel) {\n          api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)\n        } else {\n          patchVnode(elmToMove, newStartVnode)\n          oldCh[idxInOld] = null\n          api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el)\n        }\n        newStartVnode = newCh[++newStartIdx]\n      }\n    }\n  }\n  if (oldStartIdx > oldEndIdx) {\n    before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].el\n    addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx)\n  } else if (newStartIdx > newEndIdx) {\n    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)\n  }\n}\n")])])]),n("h2",{attrs:{id:"用index做key"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#用index做key"}},[e._v("#")]),e._v(" 用index做key")]),e._v(" "),n("p",[e._v("平常v-for循环渲染的时候，为什么不建议用index作为循环项的key呢？")]),e._v(" "),n("p",[e._v("我们举个例子，左边是初始数据，然后我在数据前插入一个新数据，变成右边的列表")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<ul>                      <ul>\n    <li key="0">a</li>        <li key="0">林三心</li>\n    <li key="1">b</li>        <li key="1">a</li>\n    <li key="2">c</li>        <li key="2">b</li>\n                              <li key="3">c</li>\n</ul>                     </ul>\n')])])]),n("p",[e._v("按理说，最理想的结果是：只插入一个li标签新节点，其他都不动，确保操作DOM效率最高。但是我们这里用了index来当key的话，真的会实现我们的理想结果吗？废话不多说，实践一下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<ul>\n   <li v-for="(item, index) in list" :key="index">{{ item.title }}</li>\n</ul>\n<button @click="add">增加</button>\n\nlist: [\n        { title: "a", id: "100" },\n        { title: "b", id: "101" },\n        { title: "c", id: "102" },\n      ]\n      \nadd() {\n      this.list.unshift({ title: "林三心", id: "99" });\n    }\n')])])]),n("p",[e._v("点击按钮我们可以看到，并不是我们预想的结果，而是所有li标签都更新了")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_gif/TZL4BdZpLdhLrBiatSxv9I8lK30ickrqto9sx27EvoPibHicmhBdW0OvsZAmbxg8Uj4nSFmv01qhyIB3zr1xViay1YQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1",alt:"图片"}})]),e._v(" "),n("p",[e._v("为什么会这样呢？还是通过图来解释")]),e._v(" "),n("p",[e._v("按理说，"),n("code",[e._v("a，b，c")]),e._v("三个li标签都是复用之前的，因为他们三个根本没改变，改变的只是前面新增了一个"),n("code",[e._v("林三心")])]),e._v(" "),n("p",[n("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdhLrBiatSxv9I8lK30ickrqtoS5sM0dt8jyWbEbn8YfFebFQhJkDptY9WYIhP8ichibqvjP1EBkUg2k9A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),n("p",[e._v("但是我们前面说了，在进行子节点的 "),n("code",[e._v("diff算法")]),e._v(" 过程中，会进行 旧首节点和新首节点的"),n("code",[e._v("sameNode")]),e._v("对比，这一步命中了逻辑，因为现在"),n("code",[e._v("新旧两次首部节点")]),e._v(" 的 "),n("code",[e._v("key")]),e._v(" 都是 "),n("code",[e._v("0")]),e._v("了，同理，key为1和2的也是命中了逻辑，导致"),n("code",[e._v("相同key的节点")]),e._v("会去进行"),n("code",[e._v("patchVnode")]),e._v("更新文本，而原本就有的"),n("code",[e._v("c节点")]),e._v("，却因为之前没有key为4的节点，而被当做了新节点，所以很搞笑，使用index做key，最后新增的居然是本来就已有的c节点。所以前三个都进行"),n("code",[e._v("patchVnode")]),e._v("更新文本，最后一个进行了"),n("code",[e._v("新增")]),e._v("，那就解释了为什么所有li标签都更新了。")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdhLrBiatSxv9I8lK30ickrqtoiaFatJlztMacib49ae341ZEMmbECmncPMwmw9oXPXXictE0Rlh7mt5s7Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),n("p",[e._v("那我们可以怎么解决呢？其实我们只要使用一个独一无二的值来当做key就行了")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<ul>\n   <li v-for="item in list" :key="item.id">{{ item.title }}</li>\n</ul>\n')])])]),n("p",[e._v("现在再来看看效果")]),e._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),n("p",[e._v("为什么用了id来当做key就实现了我们的理想效果呢，因为这么做的话，"),n("code",[e._v("a，b，c节点")]),e._v("的"),n("code",[e._v("key")]),e._v("就会是永远不变的，更新前后key都是一样的，并且又由于"),n("code",[e._v("a，b，c节点")]),e._v("的内容本来就没变，所以就算是进行了"),n("code",[e._v("patchVnode")]),e._v("，也不会执行里面复杂的更新操作，节省了性能，而林三心节点，由于更新前没有他的key所对应的节点，所以他被当做新的节点，增加到真实DOM上去了。")]),e._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})])])}),[],!1,null,null,null);n.default=l.exports}}]);