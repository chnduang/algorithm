(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{328:function(e,t,a){"use strict";a.r(t);var r=a(4),n=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"去大厂面试问我算法-我该怎么办"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#去大厂面试问我算法-我该怎么办"}},[e._v("#")]),e._v(" 去大厂面试问我算法，我该怎么办？")]),e._v(" "),t("p",[e._v("原创 前端瓶子君 前端瓶子君 "),t("em",[e._v("2020-04-18")])]),e._v(" "),t("p",[e._v("收录于话题#前端进阶算法14个")]),e._v(" "),t("h3",{attrs:{id:"引言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引言"}},[e._v("#")]),e._v(" 引言")]),e._v(" "),t("p",[e._v("现在大厂面试几乎都会问到算法，回答不上来会让你在面试官前大打折扣。前端怎么进阶算法喃？")]),e._v(" "),t("p",[e._v("本周是瓶子君前端进阶算法的第三周🎉🎉🎉，这里，会带你 从 0 到 1 构建完整的前端数据结构与算法体系。")]),e._v(" "),t("p",[e._v("本周已经不单是简单的链表操作（一般链表的问题可以考虑使用快慢指针），开始涉及五大常用算法策略、二叉树、Trie树、队列等，这里仅作为入门，后面会详细介绍，发散思维，你会发现面试中的算法、开发中的算法真的很 easy。")]),e._v(" "),t("p",[t("strong",[e._v("往期精彩系列")])]),e._v(" "),t("ul",[t("li",[t("strong",[t("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&mid=2247484298&idx=1&sn=846c8c4117fa0eb5f9a7e66c54b7ae5a&chksm=faec8752cd9b0e44326a3b532ec3e5f57498c83642211c68017dd212f1ddeca53b45b44fe42e&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("10问10答，带你快速入门前端算法"),t("OutboundLink")],1)])]),e._v(" "),t("li",[t("strong",[t("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&mid=2247484292&idx=1&sn=c2dfcccab0ed82267061340f969d5de2&chksm=faec875ccd9b0e4a4b1b015785bd439c9ec37ca6882e9b18f66c523e03110e29f1b6d4c57f62&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("前端进阶算法4：链表原来如此简单(+leetcode刷题）"),t("OutboundLink")],1)])]),e._v(" "),t("li",[t("strong",[t("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&mid=2247484265&idx=1&sn=7feafe63a80ce6371a1b6834884a6d05&chksm=faec87b1cd9b0ea7ea773e24341918cefa1df7ccbc2c12c0fee679fcf62d2603f86351f732d1&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("前端进阶算法3：从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法"),t("OutboundLink")],1)])]),e._v(" "),t("li",[t("strong",[t("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&mid=2247484249&idx=1&sn=0352d8071caac441ff1c5af3260fe484&chksm=faec8781cd9b0e97bfab3b48f51fc9172b2409378f890de8017d5cd2c62bb004ee58fc8d522c&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("瓶子君前端算法集训营第一期开营啦，免费哟"),t("OutboundLink")],1)])]),e._v(" "),t("li",[t("strong",[t("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&mid=2247484213&idx=1&sn=6b7b9cd11b7a151b1b5396c918d7692f&chksm=faec87edcd9b0efb118b006b13b3df234aa3c8a5aa5bcd168cdf07ee3990fee28a5f039baa0f&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("前端进阶算法2：从Chrome V8源码看JavaScript数组(附赠腾讯面试题)"),t("OutboundLink")],1)])]),e._v(" "),t("li",[e._v("**"),t("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&mid=2247484204&idx=1&sn=3433b9191b67ac9b09452b0d6e3a0639&chksm=faec87f4cd9b0ee213f03f451069f4c5fd352cf0c573d043c1819760ef1085a4457af99605a8&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("前端进阶算法1：如何分析、统计算法的执行效率和资源消耗？"),t("OutboundLink")],1),e._v("\n**")])]),e._v(" "),t("p",[t("strong",[e._v("以及题目（群内每日一题，瓶子君第二天解答）：")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("图解leetcode88：合并两个有序数组")]),e._v("[1]")]),e._v(" "),t("li",[t("strong",[e._v("字节&leetcode1：两数之和")]),e._v("[2]")]),e._v(" "),t("li",[t("strong",[e._v("腾讯：数组扁平化、去重、排序")]),e._v("[3]")]),e._v(" "),t("li",[t("strong",[e._v("leetcode349：给定两个数组，编写一个函数来计算它们的交集")]),e._v("[4]")]),e._v(" "),t("li",[t("strong",[e._v("leetcode146：设计和实现一个LRU（最近最少使用）缓存机制")]),e._v("[5]")]),e._v(" "),t("li",[t("strong",[e._v("阿里算法题：编写一个函数计算多个数组的交集")]),e._v("[6]")]),e._v(" "),t("li",[t("strong",[e._v("leetcode21：合并两个有序链表")]),e._v("[7]")]),e._v(" "),t("li",[t("strong",[e._v("有赞&leetcode141：判断一个单链表是否有环")]),e._v("[8]")]),e._v(" "),t("li",[t("strong",[e._v("图解leetcode206：反转链表")]),e._v("[9]")]),e._v(" "),t("li",[t("strong",[e._v("leetcode876：求链表的中间结点")]),e._v("[10]")]),e._v(" "),t("li",[t("strong",[e._v("leetcode19：删除链表倒数第 n 个结点")]),e._v("[11]")]),e._v(" "),t("li",[t("strong",[e._v("图解字节&leetcode160：编写一个程序，找到两个单链表相交的起始节点")]),e._v("[12]")]),e._v(" "),t("li",[t("strong",[e._v("图解字节&leetcode151：翻转字符串里的单词")]),e._v("[13]")]),e._v(" "),t("li",[t("strong",[e._v("图解leetcode14：最长公共前缀")]),e._v("[14]")])]),e._v(" "),t("p",[e._v("因微信公众号不支持外链，点击底部「阅读原文」，查看整个系列！")]),e._v(" "),t("p",[e._v("本节是第三周的总结与回顾，下面开始进入正题吧！👇👇👇")]),e._v(" "),t("h3",{attrs:{id:"一、图解字节-leetcode14-最长公共前缀"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、图解字节-leetcode14-最长公共前缀"}},[e._v("#")]),e._v(" 一、图解字节&leetcode14：最长公共前缀")]),e._v(" "),t("h4",{attrs:{id:"_1-题目"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-题目"}},[e._v("#")]),e._v(" 1. 题目")]),e._v(" "),t("p",[e._v("编写一个函数来查找字符串数组中的最长公共前缀。")]),e._v(" "),t("p",[e._v("如果不存在公共前缀，返回空字符串 "),t("code",[e._v('""')]),e._v("。")]),e._v(" "),t("p",[t("strong",[e._v("示例 1:")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('输入: ["flower","flow","flight"]\n输出: "fl"\n')])])]),t("p",[t("strong",[e._v("示例 2:")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('输入: ["dog","racecar","car"]\n输出: ""\n解释: 输入不存在公共前缀。\n')])])]),t("h4",{attrs:{id:"_2-答案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-答案"}},[e._v("#")]),e._v(" 2. 答案")]),e._v(" "),t("h5",{attrs:{id:"解法一-逐个比较"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解法一-逐个比较"}},[e._v("#")]),e._v(" 解法一：逐个比较")]),e._v(" "),t("p",[t("strong",[e._v("解题思路：")]),e._v(" 从前往后一次比较字符串，获取公共前缀")]),e._v(" "),t("p",[t("strong",[e._v("画图帮助理解一下：")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQITfA6ULXFLqnvsoooBlLjzL8FaNwBnXoV96MCZhWOELZSFfyQxWg0sYTlSW9YcLibQhBzYAndq1g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQITfA6ULXFLqnvsoooBlLjZ5CY50SOrt5gD553EX9cfcu16wgBmicw68uKvib0VvZiaq6I6xx5V0TSg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQITfA6ULXFLqnvsoooBlLjOlGB6Lxc2VNXL6QK7TQ9HeG6sLDE7GVZwvqNibWpOefHowNsv74zz6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),t("p",[t("strong",[e._v("代码实现：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('var longestCommonPrefix = function(strs) {\n    if (strs === null || strs.length === 0) return "";\n    let prevs = strs[0]\n    for(let i = 1; i < strs.length; i++) {\n        let j = 0\n        for(; j < prevs.length && j < strs[i].length; j++) {\n            if(prevs.charAt(j) !== strs[i].charAt(j)) break\n        }\n        prevs = prevs.substring(0, j)\n        if(prevs === "") return ""\n    }\n    return prevs\n};\n')])])]),t("p",[t("strong",[e._v("时间复杂度：O(s)，s 是所有字符串中字符数量的总和")])]),e._v(" "),t("p",[t("strong",[e._v("空间复杂度：O(1)")])]),e._v(" "),t("h5",{attrs:{id:"解法二-仅需最大、最小字符串的最长公共前缀"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解法二-仅需最大、最小字符串的最长公共前缀"}},[e._v("#")]),e._v(" 解法二：仅需最大、最小字符串的最长公共前缀")]),e._v(" "),t("p",[t("strong",[e._v("解题思路：")]),e._v(" 获取数组中的最大值及最小值字符串，最小字符串与最大字符串的最长公共前缀也为其他字符串的公共前缀，即为字符串数组的最长公共前缀")]),e._v(" "),t("p",[e._v("例如 "),t("code",[e._v("abc")]),e._v(" 、 "),t("code",[e._v("abcd")]),e._v(" 、"),t("code",[e._v("ab")]),e._v(" 、"),t("code",[e._v("ac")]),e._v(" ，最小 "),t("code",[e._v("ab")]),e._v(" 与最大 "),t("code",[e._v("ac")]),e._v(" 的最长公共前缀一定也是 "),t("code",[e._v("abc")]),e._v(" 、  "),t("code",[e._v("abcd")]),e._v(" 的公共前缀")]),e._v(" "),t("p",[t("strong",[e._v("画图帮助理解一下：")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQITfA6ULXFLqnvsoooBlLj2CWebGpwueEcEXzVABHic05wqrjtyHTFguQ2qWRO4F9S0ksia1YfY3hg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),t("p",[t("strong",[e._v("代码实现：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('var longestCommonPrefix = function(strs) {\n    if (strs === null || strs.length === 0) return "";\n    if(strs.length === 1) return strs[0]\n    let min = 0, max = 0\n    for(let i = 1; i < strs.length; i++) {\n        if(strs[min] > strs[i]) min = i\n        if(strs[max] < strs[i]) max = i\n    }\n    for(let j = 0; j < strs[min].length; j++) {\n        if(strs[min].charAt(j) !== strs[max].charAt(j)) {\n            return strs[min].substring(0, j)\n        }\n    }\n    return strs[min]\n};\n')])])]),t("p",[t("strong",[e._v("时间复杂度：O(n+m)，n是数组的长度， m 是字符串数组中最短字符的长度")])]),e._v(" "),t("p",[t("strong",[e._v("空间复杂度：O(1)")])]),e._v(" "),t("h5",{attrs:{id:"解法三-分治策略-归并思想"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解法三-分治策略-归并思想"}},[e._v("#")]),e._v(" 解法三：分治策略 归并思想")]),e._v(" "),t("p",[e._v("分治，顾名思义，就是分而治之，将一个复杂的问题，分成两个或多个相似的子问题，在把子问题分成更小的子问题，直到更小的子问题可以简单求解，求解子问题，则原问题的解则为子问题解的合并。")]),e._v(" "),t("p",[e._v("这道题就是一个典型的分治策略问题：")]),e._v(" "),t("ul",[t("li",[e._v("问题：求多个字符串的最长公共前缀")]),e._v(" "),t("li",[e._v("分解成多个相似的子问题：求两个字符串的最长公共前缀")]),e._v(" "),t("li",[e._v("子问题可以简单求解：两个字符串的最长公共前缀求解很简单")]),e._v(" "),t("li",[e._v("原问题的解为子问题解的合并：多个字符串的最长公共前缀为两两字符串的最长公共前缀的最长公共前缀，我们可以归并比较两最长公共前缀字符串的最长公共前缀，知道最后归并比较成一个，则为字符串数组的最长公共前缀："),t("code",[e._v("LCP(S1, S2, ..., Sn) = LCP(LCP(S1, Sk), LCP(Sk+1, Sn))")])])]),e._v(" "),t("p",[t("strong",[e._v("画图帮助理解一下：")])]),e._v(" "),t("p",[e._v("以 "),t("code",[e._v("abc")]),e._v(" 、 "),t("code",[e._v("abcd")]),e._v(" 、"),t("code",[e._v("ab")]),e._v(" 、"),t("code",[e._v("ac")]),e._v(" 为例：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQITfA6ULXFLqnvsoooBlLj7yIOibdzzqSvbiaqaZt5FHTSicLAX2uVEckEAXtgpr3S0WGunE1EmMqjg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),t("p",[t("strong",[e._v("代码实现：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('var longestCommonPrefix = function(strs) {\n    if (strs === null || strs.length === 0) return "";\n    return lCPrefixRec(strs)\n};\n\n// 若分裂后的两个数组长度不为 1，则继续分裂\n// 直到分裂后的数组长度都为 1，\n// 然后比较获取最长公共前缀\nfunction lCPrefixRec(arr) {\n  let length = arr.length\n  if(length === 1) {\n    return arr[0]\n  }\n  let mid = Math.floor(length / 2),\n      left = arr.slice(0, mid),\n      right = arr.slice(mid, length)\n  return lCPrefixTwo(lCPrefixRec(left), lCPrefixRec(right))\n}\n\n// 求 str1 与 str2 的最长公共前缀\nfunction lCPrefixTwo(str1, str2) {\n    let j = 0\n    for(; j < str1.length && j < str2.length; j++) {\n        if(str1.charAt(j) !== str2.charAt(j)) {\n            break\n        }\n    }\n    return str1.substring(0, j)\n}\n')])])]),t("p",[t("strong",[e._v("时间复杂度：O(s)，s 是所有字符串中字符数量的总和")])]),e._v(" "),t("p",[t("strong",[e._v("空间复杂度：O(m*logn)，n是数组的长度，m为字符串数组中最长字符的长度")])]),e._v(" "),t("h5",{attrs:{id:"解法四-trie-树-字典树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解法四-trie-树-字典树"}},[e._v("#")]),e._v(" 解法四：Trie 树（字典树）")]),e._v(" "),t("p",[e._v("Trie 树，也称为字典树或前缀树，顾名思义，它是用来处理字符串匹配问题的数据结构，以及用来解决集合中查找固定前缀字符串的数据结构。")]),e._v(" "),t("p",[t("strong",[e._v("解题思路：")]),e._v(" 构建一个 Trie 树，字符串数组的最长公共序列就为从根节点开始遍历树，直到：")]),e._v(" "),t("ul",[t("li",[e._v("遍历节点存在超过一个子节点的节点")]),e._v(" "),t("li",[e._v("或遍历节点为一个字符串的结束字符")])]),e._v(" "),t("p",[e._v("为止，走过的字符为字符串数组的最长公共前缀")]),e._v(" "),t("p",[t("strong",[e._v("画图帮助理解一下：")])]),e._v(" "),t("p",[e._v("构建一个 Trie 树，以 "),t("code",[e._v("abc")]),e._v(" 、 "),t("code",[e._v("abcd")]),e._v(" 、"),t("code",[e._v("ab")]),e._v(" 、"),t("code",[e._v("ac")]),e._v(" 为例：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQITfA6ULXFLqnvsoooBlLjfkjZ7tEol0phdqWVU24KTUoQFf2cxG2WaP8oMy8Y1psX4jawiaKUDsg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),t("p",[t("strong",[e._v("代码实现：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('var longestCommonPrefix = function(strs) {\n    if (strs === null || strs.length === 0) return "";\n    // 初始化 Trie 树\n    let trie = new Trie()\n    // 构建 Trie 树\n    for(let i = 0; i < strs.length; i++) {\n        if(!trie.insert(strs[i])) return ""\n    }\n    // 返回最长公共前缀\n    return trie.searchLongestPrefix()\n};\n// Trie 树\nvar Trie = function() {\n    this.root = new TrieNode()\n};\nvar TrieNode = function() {\n    // next 放入当前节点的子节点\n    this.next = {};\n    // 当前是否是结束节点\n    this.isEnd = false;\n};\nTrie.prototype.insert = function(word) {\n    if (!word) return false\n    let node = this.root\n    for (let i = 0; i < word.length; i++) {\n        if (!node.next[word[i]]) {\n            node.next[word[i]] = new TrieNode()\n        }\n        node = node.next[word[i]]\n    }\n    node.isEnd = true\n    return true\n};\nTrie.prototype.searchLongestPrefix = function() {\n    let node = this.root\n    let prevs = \'\'\n    while(node.next) {\n        let keys = Object.keys(node.next)\n        if(keys.length !== 1) break\n        if(node.next[keys[0]].isEnd) {\n            prevs += keys[0]\n            break\n        }\n        prevs += keys[0]\n        node = node.next[keys[0]]\n    }\n    return prevs\n}\n')])])]),t("p",[t("strong",[e._v("时间复杂度：O(s+m)，s 是所有字符串中字符数量的总和，m为字符串数组中最长字符的长度，构建 Trie 树需要 O(s) ，最长公共前缀查询操作的复杂度为 O(m)")])]),e._v(" "),t("p",[t("strong",[e._v("空间复杂度：O(s)，用于构建 Trie 树")])]),e._v(" "),t("p",[t("strong",[e._v("leetcode")]),e._v("[15]")]),e._v(" "),t("h4",{attrs:{id:"_3-更多解法请看-图解字节-leetcode14-最长公共前缀-16"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-更多解法请看-图解字节-leetcode14-最长公共前缀-16"}},[e._v("#")]),e._v(" 3. 更多解法请看 图解字节&leetcode14：最长公共前缀[16]")]),e._v(" "),t("h3",{attrs:{id:"二、图解字节-leetcode151-翻转字符串里的单词"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、图解字节-leetcode151-翻转字符串里的单词"}},[e._v("#")]),e._v(" 二、图解字节&leetcode151：翻转字符串里的单词")]),e._v(" "),t("h4",{attrs:{id:"_1-题目-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-题目-2"}},[e._v("#")]),e._v(" 1. 题目")]),e._v(" "),t("p",[e._v("给定一个字符串，逐个翻转字符串中的每个单词。")]),e._v(" "),t("p",[t("strong",[e._v("示例 1：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('输入: "the sky is blue"\n输出: "blue is sky the"\n')])])]),t("p",[t("strong",[e._v("示例 2：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('输入: "  hello world!  "\n输出: "world! hello"\n解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n')])])]),t("p",[t("strong",[e._v("示例 3：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('输入: "a good   example"\n输出: "example good a"\n解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n')])])]),t("p",[t("strong",[e._v("说明：")])]),e._v(" "),t("ul",[t("li",[e._v("无空格字符构成一个单词。")]),e._v(" "),t("li",[e._v("输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。")]),e._v(" "),t("li",[e._v("如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。")])]),e._v(" "),t("h4",{attrs:{id:"_2-答案-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-答案-2"}},[e._v("#")]),e._v(" 2. 答案")]),e._v(" "),t("h5",{attrs:{id:"解法一-正则-js-api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解法一-正则-js-api"}},[e._v("#")]),e._v(" 解法一：正则 + JS API")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var reverseWords = function(s) {\n    return s.trim().replace(/\\s+/g, ' ').split(' ').reverse().join(' ')\n};\n")])])]),t("h5",{attrs:{id:"解法二-双端队列-不使用-api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解法二-双端队列-不使用-api"}},[e._v("#")]),e._v(" 解法二：双端队列（不使用 API）")]),e._v(" "),t("p",[e._v("双端队列，故名思义就是两端都可以进队的队列")]),e._v(" "),t("p",[t("strong",[e._v("解题思路：")])]),e._v(" "),t("ul",[t("li",[e._v("首先去除字符串左右空格")]),e._v(" "),t("li",[e._v("逐个读取字符串中的每个单词，依次放入双端队列的对头")]),e._v(" "),t("li",[e._v("再将队列转换成字符串输出（已空格为分隔符）")])]),e._v(" "),t("p",[t("strong",[e._v("画图理解：")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQITfA6ULXFLqnvsoooBlLjDibmANDVfdicXAR7l4UrvPfBLwcicNXTZMv9Dxm4swhmicBSsLrPv1NtXg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQITfA6ULXFLqnvsoooBlLjUnBJ3TKV33rKWAacib7LXS4icQ8dE4rPNa8AacKrxK24eW9bic0icnwxBg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQITfA6ULXFLqnvsoooBlLjjibo0fdz6UMibbrZ8oupBBQWRZwNibsfqNnOQOF2uA3NBmdu4FzWuN5SA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),t("p",[t("strong",[e._v("代码实现：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var reverseWords = function(s) {\n    let left = 0\n    let right = s.length - 1\n    let queue = []\n    let word = ''\n    while (s.charAt(left) === ' ') left ++\n    while (s.charAt(right) === ' ') right --\n    while (left <= right) {\n        let char = s.charAt(left)\n        if (char === ' ' && word) {\n            queue.unshift(word)\n            word = ''\n        } else if (char !== ' '){\n            word += char\n        }\n        left++\n    }\n    queue.unshift(word)\n    return queue.join(' ')\n};\n")])])]),t("p",[t("strong",[e._v("leetcode")]),e._v("[17]")]),e._v(" "),t("h4",{attrs:{id:"_3-更多解法请看-图解字节-leetcode151-翻转字符串里的单词-18"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-更多解法请看-图解字节-leetcode151-翻转字符串里的单词-18"}},[e._v("#")]),e._v(" 3. 更多解法请看 图解字节&leetcode151：翻转字符串里的单词[18]")]),e._v(" "),t("h3",{attrs:{id:"三、图解字节-leetcode160-编写一个程序-找到两个单链表相交的起始节点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、图解字节-leetcode160-编写一个程序-找到两个单链表相交的起始节点"}},[e._v("#")]),e._v(" 三、图解字节&leetcode160：编写一个程序，找到两个单链表相交的起始节点")]),e._v(" "),t("h4",{attrs:{id:"_1-题目-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-题目-3"}},[e._v("#")]),e._v(" 1. 题目")]),e._v(" "),t("p",[e._v("编写一个程序，找到两个单链表相交的起始节点。")]),e._v(" "),t("p",[e._v("如下面的两个链表：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQITfA6ULXFLqnvsoooBlLjFGibiaAt794fhicoYwtJMjODpGTDghiadSnXroXp3ibggD1zAFFRIRTtKwQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),t("p",[e._v("在节点 c1 开始相交。")]),e._v(" "),t("p",[t("strong",[e._v("示例 1：")])]),e._v(" "),t("p",[t("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n输出：Reference of the node with value = 8\n输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n")])])]),t("p",[t("strong",[e._v("示例 2：")])]),e._v(" "),t("p",[t("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Reference of the node with value = 2\n输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n")])])]),t("p",[t("strong",[e._v("示例 3：")])]),e._v(" "),t("p",[t("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n解释：这两个链表不相交，因此返回 null。\n")])])]),t("p",[t("strong",[e._v("注意：")])]),e._v(" "),t("ul",[t("li",[e._v("如果两个链表没有交点，返回 null.")]),e._v(" "),t("li",[e._v("在返回结果后，两个链表仍须保持原有的结构。")]),e._v(" "),t("li",[e._v("可假定整个链表结构中没有循环。")]),e._v(" "),t("li",[e._v("程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。")])]),e._v(" "),t("h4",{attrs:{id:"_2-答案-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-答案-3"}},[e._v("#")]),e._v(" 2. 答案")]),e._v(" "),t("h5",{attrs:{id:"解法一-标记法-简单但空间复杂度为o-n-不符合-仅做参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解法一-标记法-简单但空间复杂度为o-n-不符合-仅做参考"}},[e._v("#")]),e._v(" 解法一：标记法(简单但空间复杂度为O(n)，不符合，仅做参考)")]),e._v(" "),t("p",[t("strong",[e._v("解题思路：")]),e._v(" 两次遍历，先遍历一个链表，给链表中的每个节点都增加一个标志位，然后遍历另外一个链表，遍历到第一个已被标志过的节点为两链表相交的起始节点。")]),e._v(" "),t("p",[e._v("若遍历完都没有发现已被标志过的节点，则两链表不相交，返回 "),t("code",[e._v("null")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var getIntersectionNode = function(headA, headB) {\n    while(headA) {\n        headA.flag = true\n        headA = headA.next\n    }\n    while(headB) {\n        if (headB.flag) return headB\n        headB = headB.next\n    }\n    return null\n};\n")])])]),t("p",[t("strong",[e._v("时间复杂度：O(n)")])]),e._v(" "),t("p",[t("strong",[e._v("空间复杂度：O(n)")])]),e._v(" "),t("h5",{attrs:{id:"解法二-双指针法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解法二-双指针法"}},[e._v("#")]),e._v(" 解法二：双指针法")]),e._v(" "),t("p",[t("strong",[e._v("解题思路：")]),e._v(" 如果 A、B 两链表相交，则 A 、B 自相交点往后的链表是一致的。")]),e._v(" "),t("p",[t("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),t("p",[e._v("我们可以尝试消除 A、B 链表的长度差，同步遍历上图中的方框里的节点，判断是否有相同节点，若有相同则是两链表相交，返回第一个相同节点 即可。否则返回 "),t("code",[e._v("null")]),e._v(" ，两链表不相交。")]),e._v(" "),t("p",[t("strong",[e._v("解题步骤：")])]),e._v(" "),t("ul",[t("li",[e._v("同步遍历 A、B 链表 "),t("code",[e._v("pA")]),e._v(" 、 "),t("code",[e._v("pB")]),e._v(" ，直到遍历完其中一个链表（短链表），如上图，设A为长链表")]),e._v(" "),t("li",[e._v("那么此时 A、B 两遍表的长度差就为 "),t("code",[e._v("pA")]),e._v(" 到链尾的长度，此时可以把 "),t("code",[e._v("pB")]),e._v(" 指向长链表的表头 "),t("code",[e._v("headA")]),e._v(" ，继续同步遍历，直到遍历完长链表")]),e._v(" "),t("li",[e._v("此时，"),t("code",[e._v("headA")]),e._v(" 到 "),t("code",[e._v("pB")]),e._v(" 的长度就为两链表的长度差，"),t("code",[e._v("pB")]),e._v(" 到链表的长度与 "),t("code",[e._v("headB")]),e._v(" 到链尾的长度一致")]),e._v(" "),t("li",[e._v("此时，可将 "),t("code",[e._v("pA")]),e._v(" 指向 "),t("code",[e._v("headB")]),e._v(" ，然后同步遍历 "),t("code",[e._v("pB")]),e._v(" 及 "),t("code",[e._v("pA")]),e._v(" ，直到有相交节点，返回相交节点，否则返回 "),t("code",[e._v("null")])])]),e._v(" "),t("p",[t("strong",[e._v("画图帮助理解：")])]),e._v(" "),t("p",[t("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),t("p",[t("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var getIntersectionNode = function(headA, headB) {\n    // 清除高度差\n    let pA = headA, pB = headB\n    while(pA || pB) {\n        if(pA === pB) return pA\n        pA = pA === null ? headB : pA.next\n        pB = pB === null ? headA : pB.next\n    }\n    return null\n};\n")])])]),t("p",[t("strong",[e._v("时间复杂度：O(n)")])]),e._v(" "),t("p",[t("strong",[e._v("空间复杂度：O(1)")])]),e._v(" "),t("p",[t("strong",[e._v("leetcode")]),e._v("[19]")]),e._v(" "),t("h4",{attrs:{id:"_3-更多解法请看-图解字节-leetcode160-编写一个程序-找到两个单链表相交的起始节点-20"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-更多解法请看-图解字节-leetcode160-编写一个程序-找到两个单链表相交的起始节点-20"}},[e._v("#")]),e._v(" 3. 更多解法请看 图解字节&leetcode160：编写一个程序，找到两个单链表相交的起始节点[20]")]),e._v(" "),t("h3",{attrs:{id:"四、leetcode19-删除链表倒数第-n-个结点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四、leetcode19-删除链表倒数第-n-个结点"}},[e._v("#")]),e._v(" 四、leetcode19：删除链表倒数第 n 个结点")]),e._v(" "),t("h4",{attrs:{id:"_1-题目-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-题目-4"}},[e._v("#")]),e._v(" 1. 题目")]),e._v(" "),t("p",[e._v("给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。")]),e._v(" "),t("p",[t("strong",[e._v("示例：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("给定一个链表: 1->2->3->4->5, 和 n = 2.\n当删除了倒数第二个节点后，链表变为 1->2->3->5.\n")])])]),t("p",[t("strong",[e._v("说明：")])]),e._v(" "),t("p",[e._v("给定的 n 保证是有效的。")]),e._v(" "),t("p",[t("strong",[e._v("进阶：")])]),e._v(" "),t("p",[e._v("你能尝试使用一趟扫描实现吗？")]),e._v(" "),t("h4",{attrs:{id:"_2-解法-快慢指针"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-解法-快慢指针"}},[e._v("#")]),e._v(" 2. 解法：快慢指针")]),e._v(" "),t("p",[t("strong",[e._v("解题思路：")]),e._v(" 需要删除链表中的倒数第 "),t("code",[e._v("n")]),e._v(" 个节点，我们需要知道的就是倒数第 "),t("code",[e._v("n+1")]),e._v(" 个节点，然后删除删除倒数第 "),t("code",[e._v("n+1")]),e._v(" 节点的后继节点即可")]),e._v(" "),t("p",[t("strong",[e._v("步骤：")])]),e._v(" "),t("p",[e._v("使用 2 个指针：")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("fast")]),e._v(" 快指针提前走 "),t("code",[e._v("n+1")]),e._v(" 步")]),e._v(" "),t("li",[t("code",[e._v("slow")]),e._v(" 指针指向当前距离 "),t("code",[e._v("fast")]),e._v(" 倒数第 "),t("code",[e._v("n")]),e._v(" 个节点， 初始为 "),t("code",[e._v("head")])])]),e._v(" "),t("p",[e._v("然后， "),t("code",[e._v("fast")]),e._v(" 、 "),t("code",[e._v("slow")]),e._v(" 同步向前走，直到 "),t("code",[e._v("fast.next")]),e._v(" 为 "),t("code",[e._v("null")])]),e._v(" "),t("p",[e._v("此时，"),t("code",[e._v("fast")]),e._v(" 为最后一个节点，"),t("code",[e._v("slow")]),e._v(" 就是倒数第 "),t("code",[e._v("n+1")]),e._v(" 个节点，此时问题就变更为删除链表中的 "),t("code",[e._v("slow")]),e._v(" 的后继节点")]),e._v(" "),t("p",[e._v("但存在一个问题，当链表长度为 "),t("code",[e._v("n")]),e._v(" 时，"),t("code",[e._v("fast")]),e._v(" 是前进不到 "),t("code",[e._v("n+1")]),e._v(" 个节点位置的，所以此时有两种解决思路：")]),e._v(" "),t("ul",[t("li",[e._v("创建一个头节点 "),t("code",[e._v("preHead")]),e._v(" ，设置 "),t("code",[e._v("preHead.next = head")]),e._v(" ，这样就可以解决以上问题，删除倒数第 "),t("code",[e._v("n")]),e._v(" 个节点后，返回的 "),t("code",[e._v("preHead.next")]),e._v(" 即可")]),e._v(" "),t("li",[e._v("另外一种是，"),t("code",[e._v("fast")]),e._v(" 快指针提前走 "),t("code",[e._v("n")]),e._v(" 步后，判断 "),t("code",[e._v("fast.next")]),e._v(" 是否为 "),t("code",[e._v("null")]),e._v(" ，即 "),t("code",[e._v("fast")]),e._v("是否是最后一个节点，如果是，则 "),t("code",[e._v("head")]),e._v(" 为倒数第 "),t("code",[e._v("n")]),e._v(" 个节点，此时问题可以简化为删除头节点；如果不是， "),t("code",[e._v("fast = fast.next")]),e._v(" ，"),t("code",[e._v("fast")]),e._v(" 再前进一步，"),t("code",[e._v("slow")]),e._v(" 为倒数第 "),t("code",[e._v("n+1")]),e._v(" 个节点，也解决了以上问题。")])]),e._v(" "),t("h5",{attrs:{id:"解决方案一-添加-prehead-节点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决方案一-添加-prehead-节点"}},[e._v("#")]),e._v(" 解决方案一：添加 "),t("code",[e._v("preHead")]),e._v(" 节点")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var removeNthFromEnd = function(head, n) {\n    let preHead = new ListNode(0)\n    preHead.next = head\n    let fast = preHead, slow = preHead\n    // 快先走 n+1 步\n    while(n--) {\n        fast = fast.next\n    }\n    // fast、slow 一起前进\n    while(fast && fast.next) {\n        fast = fast.next\n        slow = slow.next\n    }\n    slow.next = slow.next.next\n    return preHead.next\n};\n")])])]),t("h5",{attrs:{id:"解决方案二-单独处理倒数第-n-节点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决方案二-单独处理倒数第-n-节点"}},[e._v("#")]),e._v(" 解决方案二：单独处理倒数第 "),t("code",[e._v("n")]),e._v(" 节点")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var removeNthFromEnd = function(head, n) {\n    let fast = head, slow = head\n    // 快先走 n 步\n    while(--n) {\n        fast = fast.next\n    }\n    if(!fast.next) return head.next\n    fast = fast.next\n    // fast、slow 一起前进\n    while(fast && fast.next) {\n        fast = fast.next\n        slow = slow.next\n    }\n    slow.next = slow.next.next\n    return head\n};\n")])])]),t("p",[t("strong",[e._v("时间复杂度：O(n)")])]),e._v(" "),t("p",[t("strong",[e._v("空间复杂度：O(1)")])]),e._v(" "),t("p",[t("strong",[e._v("leetcode")]),e._v("[21]")]),e._v(" "),t("h4",{attrs:{id:"_3-更多解法请看-leetcode19-删除链表倒数第-n-个结点-22"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-更多解法请看-leetcode19-删除链表倒数第-n-个结点-22"}},[e._v("#")]),e._v(" 3. 更多解法请看 leetcode19：删除链表倒数第 n 个结点[22]")]),e._v(" "),t("h3",{attrs:{id:"五、leetcode876-求链表的中间结点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#五、leetcode876-求链表的中间结点"}},[e._v("#")]),e._v(" 五、leetcode876：求链表的中间结点")]),e._v(" "),t("h4",{attrs:{id:"_1-题目-5"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-题目-5"}},[e._v("#")]),e._v(" 1. 题目")]),e._v(" "),t("p",[e._v("给定一个带有头结点 "),t("code",[e._v("head")]),e._v(" 的非空单链表，返回链表的中间结点。")]),e._v(" "),t("p",[e._v("如果有两个中间结点，则返回第二个中间结点。")]),e._v(" "),t("p",[t("strong",[e._v("示例 1：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("输入：[1,2,3,4,5]\n输出：此列表中的结点 3 (序列化形式：[3,4,5])\n返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。\n\n注意，我们返回了一个 ListNode 类型的对象 ans，这样：\nans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.\n")])])]),t("p",[t("strong",[e._v("示例 2：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("输入：[1,2,3,4,5,6]\n输出：此列表中的结点 4 (序列化形式：[4,5,6])\n\n由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。\n")])])]),t("p",[t("strong",[e._v("提示：")])]),e._v(" "),t("p",[e._v("给定链表的结点数介于 1 和 100 之间。")]),e._v(" "),t("h4",{attrs:{id:"_2-解法-快慢指针-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-解法-快慢指针-2"}},[e._v("#")]),e._v(" 2. 解法：快慢指针")]),e._v(" "),t("p",[t("strong",[e._v("解题思路：")]),e._v(" 快指针一次走两步，慢指针一次走一步，当快指针走到终点时，慢指针刚好走到中间")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var middleNode = function(head) {\n    let fast = head, slow = head\n    while(fast && fast.next) {\n        slow = slow.next\n        fast = fast.next.next\n    }\n    return slow\n};\n")])])]),t("p",[t("strong",[e._v("时间复杂度：O(n)")])]),e._v(" "),t("p",[t("strong",[e._v("空间复杂度：O(1)")])]),e._v(" "),t("p",[t("strong",[e._v("leetcode")]),e._v("[23]")]),e._v(" "),t("h4",{attrs:{id:"_3-更多解法请看-leetcode876-求链表的中间结点-24"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-更多解法请看-leetcode876-求链表的中间结点-24"}},[e._v("#")]),e._v(" 3. 更多解法请看 leetcode876：求链表的中间结点[24]")]),e._v(" "),t("h3",{attrs:{id:"六、图解leetcode206-反转链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#六、图解leetcode206-反转链表"}},[e._v("#")]),e._v(" 六、图解leetcode206：反转链表")]),e._v(" "),t("h4",{attrs:{id:"_1-题目-6"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-题目-6"}},[e._v("#")]),e._v(" 1. 题目")]),e._v(" "),t("p",[t("strong",[e._v("示例:")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("输入: 1->2->3->4->5->NULL\n输出: 5->4->3->2->1->NULL\n")])])]),t("p",[e._v("**进阶:**你可以迭代或递归地反转链表。你能否用两种方法解决这道题？")]),e._v(" "),t("h4",{attrs:{id:"_2-答案-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-答案-4"}},[e._v("#")]),e._v(" 2. 答案")]),e._v(" "),t("h5",{attrs:{id:"解法一-迭代法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解法一-迭代法"}},[e._v("#")]),e._v(" 解法一：迭代法")]),e._v(" "),t("p",[t("strong",[e._v("解题思路：")]),e._v(" 将单链表中的每个节点的后继指针指向它的前驱节点即可")]),e._v(" "),t("p",[t("strong",[e._v("画图实现：")]),e._v(" 画图帮助理解一下")]),e._v(" "),t("p",[t("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),t("p",[t("strong",[e._v("确定边界条件：")]),e._v(" 当链表为 "),t("code",[e._v("null")]),e._v(" 或链表中仅有一个节点时，不需要反转")]),e._v(" "),t("p",[t("strong",[e._v("代码实现：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var reverseList = function(head) {\n    if(!head || !head.next) return head\n    var prev = null, curr = head\n    while(curr) {\n        // 用于临时存储 curr 后继节点\n        var next = curr.next\n        // 反转 curr 的后继指针\n        curr.next = prev\n        // 变更prev、curr \n        // 待反转节点指向下一个节点 \n        prev = curr\n        curr = next\n    }\n    head = prev\n    return head\n};\n")])])]),t("p",[t("strong",[e._v("时间复杂度：O(n)")])]),e._v(" "),t("p",[t("strong",[e._v("空间复杂度：O(1)")])]),e._v(" "),t("h5",{attrs:{id:"解法二-尾递归法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解法二-尾递归法"}},[e._v("#")]),e._v(" 解法二：尾递归法")]),e._v(" "),t("p",[t("strong",[e._v("解题思路：")]),e._v(" 从头节点开始，递归反转它的每一个节点，直到 "),t("code",[e._v("null")]),e._v(" ，思路和解法一类似")]),e._v(" "),t("p",[t("strong",[e._v("代码实现：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var reverseList = function(head) {\n    if(!head || !head.next) return head\n    head = reverse(null, head)\n    return head\n};\n\nvar reverse = function(prev, curr) {\n    if(!curr) return prev\n    var next = curr.next\n    curr.next = prev\n    return reverse(curr, next)\n};\n")])])]),t("p",[t("strong",[e._v("时间复杂度：O(n)")])]),e._v(" "),t("p",[t("strong",[e._v("空间复杂度：O(n)")])]),e._v(" "),t("h5",{attrs:{id:"解法三-递归法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解法三-递归法"}},[e._v("#")]),e._v(" 解法三：递归法")]),e._v(" "),t("p",[t("strong",[e._v("解题思路：")]),e._v(" 不断递归反转当前节点 "),t("code",[e._v("head")]),e._v(" 的后继节点 "),t("code",[e._v("next")])]),e._v(" "),t("p",[t("strong",[e._v("画图实现：")]),e._v(" 画图帮助理解一下")]),e._v(" "),t("p",[t("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),t("p",[t("strong",[e._v("代码实现：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var reverseList = function(head) {\n    if(!head || !head.next) return head\n    var next = head.next\n    // 递归反转\n    var reverseHead = reverseList(next)\n    // 变更指针\n    next.next = head\n    head.next = null\n    return reverseHead\n};\n")])])]),t("p",[t("strong",[e._v("时间复杂度：O(n)")])]),e._v(" "),t("p",[t("strong",[e._v("空间复杂度：O(n)")])]),e._v(" "),t("p",[t("strong",[e._v("leetcode")]),e._v("[25]")]),e._v(" "),t("h4",{attrs:{id:"_3-更多解法请看-leetcode206-反转链表-26"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-更多解法请看-leetcode206-反转链表-26"}},[e._v("#")]),e._v(" 3. 更多解法请看 leetcode206：反转链表[26]")]),e._v(" "),t("h3",{attrs:{id:"七、前端算法集训营第一期免费加入啦"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#七、前端算法集训营第一期免费加入啦"}},[e._v("#")]),e._v(" 七、前端算法集训营第一期免费加入啦")]),e._v(" "),t("p",[e._v("快来加入我们吧，在这里从0到1构建完整的数据结构与算法体系！")]),e._v(" "),t("p",[e._v("在这里，瓶子君不仅介绍算法，还将算法与前端各个领域进行结合，包括浏览器、HTTP、V8、React、Vue源码等。")]),e._v(" "),t("p",[e._v("在这里，你可以每天学习一道大厂算法题（阿里、腾讯、百度、字节等等）或 leetcode，瓶子君都会在第二天解答哟！")])])}),[],!1,null,null,null);t.default=n.exports}}]);