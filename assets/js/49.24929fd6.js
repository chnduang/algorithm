(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{343:function(t,e,a){"use strict";a.r(e);var s=a(4),n=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"前端进阶算法-常见算法题及完美题解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前端进阶算法-常见算法题及完美题解"}},[t._v("#")]),t._v(" 前端进阶算法：常见算法题及完美题解")]),t._v(" "),e("blockquote",[e("p",[e("a",{attrs:{href:"https://mp.weixin.qq.com/s/m_NqYrvWj008IIj2-46keQ",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://mp.weixin.qq.com/s/m_NqYrvWj008IIj2-46keQ"),e("OutboundLink")],1)])]),t._v(" "),e("h3",{attrs:{id:"引言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#引言"}},[t._v("#")]),t._v(" 引言")]),t._v(" "),e("p",[t._v("瓶子君又来啦，她带着前端算法来了👏👏👏")]),t._v(" "),e("p",[t._v("大厂面试越来越难，对算法的要求也越来越多，当面试官问到一个算法题，给出一份完美答案能大大提高面试官的好感度，本系列就是致力于打造一套适用于前端的算法。")]),t._v(" "),e("p",[e("strong",[t._v("往期精彩系列")])]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&mid=2247484391&idx=1&sn=fd828d06827160b94c69cf4c9e37f545&chksm=faec873fcd9b0e2936ef8b22d082b130605f5ee64c3999ba32121ee0e4e18b6676c44d77060c&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[t._v("视频面试超高频在线编程题，搞懂这些足以应对大部分公司"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&mid=2247484417&idx=1&sn=c08cd285e412053dc2c2f1336752c5c9&chksm=faec80d9cd9b09cf266f62dbc5a1b26f5c9f897f6509ed379a20a8333a005b2d8701f6b9bb37&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[t._v("前端进阶算法5：全方位解读前端用到的栈结构（+leetcode刷题）"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&mid=2247484298&idx=1&sn=846c8c4117fa0eb5f9a7e66c54b7ae5a&chksm=faec8752cd9b0e44326a3b532ec3e5f57498c83642211c68017dd212f1ddeca53b45b44fe42e&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[t._v("10 问 10 答，带你快速入门前端算法"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&mid=2247484292&idx=1&sn=c2dfcccab0ed82267061340f969d5de2&chksm=faec875ccd9b0e4a4b1b015785bd439c9ec37ca6882e9b18f66c523e03110e29f1b6d4c57f62&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[t._v("前端进阶算法4：链表原来如此简单(+leetcode刷题）"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&mid=2247484265&idx=1&sn=7feafe63a80ce6371a1b6834884a6d05&chksm=faec87b1cd9b0ea7ea773e24341918cefa1df7ccbc2c12c0fee679fcf62d2603f86351f732d1&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[t._v("前端进阶算法3：从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&mid=2247484249&idx=1&sn=0352d8071caac441ff1c5af3260fe484&chksm=faec8781cd9b0e97bfab3b48f51fc9172b2409378f890de8017d5cd2c62bb004ee58fc8d522c&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[t._v("瓶子君前端算法集训营第一期开营啦，免费哟"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&mid=2247484213&idx=1&sn=6b7b9cd11b7a151b1b5396c918d7692f&chksm=faec87edcd9b0efb118b006b13b3df234aa3c8a5aa5bcd168cdf07ee3990fee28a5f039baa0f&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[t._v("前端进阶算法2：从Chrome  V8源码看JavaScript数组(附赠腾讯面试题)"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&mid=2247484204&idx=1&sn=3433b9191b67ac9b09452b0d6e3a0639&chksm=faec87f4cd9b0ee213f03f451069f4c5fd352cf0c573d043c1819760ef1085a4457af99605a8&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[t._v("前端进阶算法1：如何分析、统计算法的执行效率和资源消耗？"),e("OutboundLink")],1)])]),t._v(" "),e("p",[e("strong",[t._v("以及题目：")])]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("图解leetcode88：合并两个有序数组")]),t._v("[8]")]),t._v(" "),e("li",[e("strong",[t._v("字节&leetcode1：两数之和")]),t._v("[9]")]),t._v(" "),e("li",[e("strong",[t._v("腾讯：数组扁平化、去重、排序")]),t._v("[10]")]),t._v(" "),e("li",[e("strong",[t._v("leetcode349：给定两个数组，编写一个函数来计算它们的交集")]),t._v("[11]")]),t._v(" "),e("li",[e("strong",[t._v("leetcode146：设计和实现一个LRU（最近最少使用）缓存机制")]),t._v("[12]")]),t._v(" "),e("li",[e("strong",[t._v("阿里算法题：编写一个函数计算多个数组的交集")]),t._v("[13]")]),t._v(" "),e("li",[e("strong",[t._v("leetcode21：合并两个有序链表")]),t._v("[14]")]),t._v(" "),e("li",[e("strong",[t._v("有赞&leetcode141：判断一个单链表是否有环")]),t._v("[15]")]),t._v(" "),e("li",[e("strong",[t._v("图解leetcode206：反转链表")]),t._v("[16]")]),t._v(" "),e("li",[e("strong",[t._v("leetcode876：求链表的中间结点")]),t._v("[17]")]),t._v(" "),e("li",[e("strong",[t._v("leetcode19：删除链表倒数第 n 个结点")]),t._v("[18]")]),t._v(" "),e("li",[e("strong",[t._v("图解字节&leetcode160：编写一个程序，找到两个单链表相交的起始节点")]),t._v("[19]")]),t._v(" "),e("li",[e("strong",[t._v("图解字节&leetcode151：翻转字符串里的单词")]),t._v("[20]")]),t._v(" "),e("li",[e("strong",[t._v("图解leetcode14：最长公共前缀")]),t._v("[21]")]),t._v(" "),e("li",[e("strong",[t._v("百度：实现一个函数，判断输入是不是回文字符串")]),t._v("[22]")]),t._v(" "),e("li",[e("strong",[t._v("字节&Leetcode3：无重复字符的最长子串")]),t._v("[23]")]),t._v(" "),e("li",[e("strong",[t._v("字节&leetcode155：最小栈（包含getMin函数的栈）")]),t._v("[24]")]),t._v(" "),e("li",[e("strong",[t._v("图解腾讯&leetcode20：有效的括号")]),t._v("[25]")]),t._v(" "),e("li",[e("strong",[t._v("leetcode1047：删除字符串中的所有相邻重复项")]),t._v("[26]")])]),t._v(" "),e("p",[t._v("本节是第四周的总结与回顾，下面开始进入正题吧！👇👇👇")]),t._v(" "),e("h3",{attrs:{id:"一、百度-实现一个函数-判断输入是不是回文字符串"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、百度-实现一个函数-判断输入是不是回文字符串"}},[t._v("#")]),t._v(" 一、百度：实现一个函数，判断输入是不是回文字符串")]),t._v(" "),e("h4",{attrs:{id:"_1-解法一-使用api"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-解法一-使用api"}},[t._v("#")]),t._v(" 1. 解法一：使用API")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function isPlalindrome(input) {\n  if (typeof input !== 'string') return false;\n  return input.split('').reverse().join('') === input;\n}\n")])])]),e("h4",{attrs:{id:"_2-解法二-不使用api"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-解法二-不使用api"}},[t._v("#")]),t._v(" 2. 解法二：不使用API")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("isPlalindrome")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("input")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" input "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!==")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'string'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" i "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" j "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" input"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" j"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("input"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("charAt")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!==")]),t._v(" input"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("charAt")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("j"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v("\n      i "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("\n      j "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("h4",{attrs:{id:"_3-更多题解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-更多题解"}},[t._v("#")]),t._v(" 3. 更多题解")]),t._v(" "),e("p",[t._v("详见 "),e("strong",[t._v("百度：实现一个函数，判断输入是不是回文字符串")]),t._v("[27]")]),t._v(" "),e("h3",{attrs:{id:"二、字节-leetcode3-无重复字符的最长子串"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、字节-leetcode3-无重复字符的最长子串"}},[t._v("#")]),t._v(" 二、字节&Leetcode3：无重复字符的最长子串")]),t._v(" "),e("h4",{attrs:{id:"_1-题目"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-题目"}},[t._v("#")]),t._v(" 1. 题目")]),t._v(" "),e("p",[t._v("给定一个字符串，请你找出其中不含有重复字符的 "),e("strong",[t._v("最长子串")]),t._v(" 的长度。")]),t._v(" "),e("p",[e("strong",[t._v("示例 1:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('输入: "abcabcbb"\n输出: 3 \n解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。\n')])])]),e("p",[e("strong",[t._v("示例 2:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('输入: "bbbbb"\n输出: 1\n解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。\n')])])]),e("p",[e("strong",[t._v("示例 3:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('输入: "pwwkew"\n输出: 3\n解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。\n')])])]),e("h4",{attrs:{id:"_2-解法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-解法"}},[t._v("#")]),t._v(" 2. 解法")]),t._v(" "),e("h5",{attrs:{id:"解法一-维护数组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解法一-维护数组"}},[t._v("#")]),t._v(" 解法一：维护数组")]),t._v(" "),e("p",[e("strong",[t._v("解题思路：")]),t._v(" 使用一个数组来维护滑动窗口")]),t._v(" "),e("p",[t._v("遍历字符串，判断字符是否在滑动窗口数组里")]),t._v(" "),e("ul",[e("li",[t._v("不在则 "),e("code",[t._v("push")]),t._v(" 进数组")]),t._v(" "),e("li",[t._v("在则删除滑动窗口数组里相同字符及相同字符前的字符，然后将当前字符 "),e("code",[t._v("push")]),t._v(" 进数组")]),t._v(" "),e("li",[t._v("然后将 "),e("code",[t._v("max")]),t._v(" 更新为当前最长子串的长度")])]),t._v(" "),e("p",[t._v("遍历完，返回 "),e("code",[t._v("max")]),t._v(" 即可")]),t._v(" "),e("p",[e("strong",[t._v("画图帮助理解一下：")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQw4BiaO1joZ4nQECWOFon2PSQwbWtBx5L7QMT9icZQzNNghcgw50zia1SdnspK7opwyt11JPXTr4iakw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),t._v(" "),e("p",[e("strong",[t._v("代码实现：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var lengthOfLongestSubstring = function(s) {\n    let arr = [], max = 0\n    for(let i = 0; i < s.length; i++) {\n        let index = arr.indexOf(s[i])\n        if(index !== -1) {\n            arr.splice(0, index+1);\n        }\n        arr.push(s.charAt(i))\n        max = Math.max(arr.length, max) \n    }\n    return max\n};\n")])])]),e("p",[e("strong",[t._v("时间复杂度：O(n2)， 其中 "),e("code",[t._v("arr.indexOf()")]),t._v(" 时间复杂度为 O(n) ，"),e("code",[t._v("arr.splice(0, index+1)")]),t._v(" 的时间复杂度也为 O(n)")])]),t._v(" "),e("p",[e("strong",[t._v("空间复杂度：O(n)")])]),t._v(" "),e("h5",{attrs:{id:"解法二-维护下标"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解法二-维护下标"}},[t._v("#")]),t._v(" 解法二：维护下标")]),t._v(" "),e("p",[e("strong",[t._v("解题思路：")]),t._v(" 使用下标来维护滑动窗口")]),t._v(" "),e("p",[e("strong",[t._v("代码实现：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var lengthOfLongestSubstring = function(s) {\n    let index = 0, max = 0\n    for(let i = 0, j = 0; j < s.length; j++) {\n        index = s.substring(i, j).indexOf(s[j]) \n        if(index !== -1) { \n            i = i + index + 1 \n        } \n        max = Math.max(max, j - i + 1) \n    }\n    return max\n};\n")])])]),e("p",[e("strong",[t._v("时间复杂度：O(n2)")])]),t._v(" "),e("p",[e("strong",[t._v("空间复杂度：O(n)")])]),t._v(" "),e("h5",{attrs:{id:"解法三-优化的map"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解法三-优化的map"}},[t._v("#")]),t._v(" 解法三：优化的Map")]),t._v(" "),e("p",[e("strong",[t._v("解题思路：")])]),t._v(" "),e("p",[t._v("使用 "),e("code",[t._v("map")]),t._v(" 来存储当前已经遍历过的字符，"),e("code",[t._v("key")]),t._v(" 为字符，"),e("code",[t._v("value")]),t._v(" 为下标")]),t._v(" "),e("p",[t._v("使用 "),e("code",[t._v("i")]),t._v(" 来标记无重复子串开始下标，"),e("code",[t._v("j")]),t._v(" 为当前遍历字符下标")]),t._v(" "),e("p",[t._v("遍历字符串，判断当前字符是否已经在 "),e("code",[t._v("map")]),t._v(" 中存在，存在则更新无重复子串开始下标 "),e("code",[t._v("i")]),t._v(" 为相同字符的下一位置，此时从 "),e("code",[t._v("i")]),t._v(" 到 "),e("code",[t._v("j")]),t._v(" 为最新的无重复子串，更新 "),e("code",[t._v("max")]),t._v(" ，将当前字符与下标放入 "),e("code",[t._v("map")]),t._v(" 中")]),t._v(" "),e("p",[t._v("最后，返回 "),e("code",[t._v("max")]),t._v(" 即可")]),t._v(" "),e("p",[e("strong",[t._v("代码实现：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var lengthOfLongestSubstring = function(s) {\n    let map = new Map(), max = 0\n    for(let i = 0, j = 0; j < s.length; j++) {\n        if(map.has(s[j])) {\n            i = Math.max(map.get(s[j]) + 1, i)\n        }\n        max = Math.max(max, j - i + 1)\n        map.set(s[j], j)\n    }\n    return max\n};\n")])])]),e("p",[e("strong",[t._v("时间复杂度：O(n)")])]),t._v(" "),e("p",[e("strong",[t._v("空间复杂度：O(n)")])]),t._v(" "),e("h4",{attrs:{id:"_3-更多题解-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-更多题解-2"}},[t._v("#")]),t._v(" 3. 更多题解")]),t._v(" "),e("p",[t._v("详见 "),e("strong",[t._v("字节&Leetcode3：无重复字符的最长子串")]),t._v("[28]")]),t._v(" "),e("h3",{attrs:{id:"三、文章-全方位解读栈结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、文章-全方位解读栈结构"}},[t._v("#")]),t._v(" 三、文章：全方位解读栈结构")]),t._v(" "),e("h4",{attrs:{id:"_1-数据结构栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-数据结构栈"}},[t._v("#")]),t._v(" 1. 数据结构栈")]),t._v(" "),e("p",[t._v("栈是一种遵从后进先出 (LIFO / Last In First Out) 原则的有序集合，它的结构类似如下：")]),t._v(" "),e("p",[e("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),t._v(" "),e("p",[e("strong",[t._v("代码实现")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function Stack() {\n  let items = []\n  this.push = function(e) { \n    items.push(e) \n  }\n  this.pop = function() { \n    return items.pop() \n  }\n  this.isEmpty = function() { \n    return items.length === 0 \n  }\n  this.size = function() { \n    return items.length \n  }\n  this.clear = function() { \n    items = [] \n  }\n}\n")])])]),e("p",[e("strong",[t._v("查找：从栈头开始查找，时间复杂度为 O(n)")])]),t._v(" "),e("p",[e("strong",[t._v("插入或删除：进栈与出栈的时间复杂度为 O(1)")])]),t._v(" "),e("h4",{attrs:{id:"_2-面试-调用栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-面试-调用栈"}},[t._v("#")]),t._v(" 2. 面试：调用栈")]),t._v(" "),e("blockquote",[e("p",[t._v("调用栈是 JavaScript 用来管理函数执行上下文的一种数据结构，它记录了当前函数执行的位置，哪个函数正在被执行。如果我们执行一个函数，就会为函数创建执行上下文并放入栈顶。如果我们从函数返回，就将它的执行上下文从栈顶弹出。也可以说调用栈是用来管理这种执行上下文的栈，或称执行上下文栈（执行栈）。")])]),t._v(" "),e("h4",{attrs:{id:"_3-面试-栈空间与堆空间"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-面试-栈空间与堆空间"}},[t._v("#")]),t._v(" 3. 面试：栈空间与堆空间")]),t._v(" "),e("p",[t._v("JavaScript 中的内存空间主要分为三种类型：")]),t._v(" "),e("ul",[e("li",[t._v("代码空间：主要用来存放可执行代码")]),t._v(" "),e("li",[t._v("栈空间：调用栈的存储空间就是栈空间。")]),t._v(" "),e("li",[t._v("堆空间")])]),t._v(" "),e("p",[t._v("代码空间主要用来存放可执行代码的。栈空间及堆空间主要用来存放数据的。接下来我们主要介绍栈空间及堆空间。")]),t._v(" "),e("p",[t._v("当调用栈中执行完成一个执行上下文时，需要进行垃圾回收该上下文以及相关数据空间，存放在栈空间上的数据通过 ESP 指针来回收，存放在堆空间的数据通过副垃圾回收器（新生代）与主垃圾回收器（老生代）来回收。")]),t._v(" "),e("h4",{attrs:{id:"_4-详情"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-详情"}},[t._v("#")]),t._v(" 4. 详情")]),t._v(" "),e("p",[t._v("详细请看 "),e("strong",[t._v("前端进阶算法5：全方位解读前端用到的栈结构（+leetcode刷题）")]),t._v("[29]")]),t._v(" "),e("h3",{attrs:{id:"四、字节-leetcode155-最小栈-包含getmin函数的栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四、字节-leetcode155-最小栈-包含getmin函数的栈"}},[t._v("#")]),t._v(" 四、字节&leetcode155：最小栈（包含getMin函数的栈）")]),t._v(" "),e("h4",{attrs:{id:"_1-题目-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-题目-2"}},[t._v("#")]),t._v(" 1. 题目")]),t._v(" "),e("p",[t._v("设计一个支持 "),e("code",[t._v("push")]),t._v(" ，"),e("code",[t._v("pop")]),t._v(" ，"),e("code",[t._v("top")]),t._v(" 操作，并能在常数时间内检索到最小元素的栈。")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("push(x)")]),t._v(" —— 将元素 x 推入栈中。")]),t._v(" "),e("li",[e("code",[t._v("pop()")]),t._v(" —— 删除栈顶的元素。")]),t._v(" "),e("li",[e("code",[t._v("top()")]),t._v(" —— 获取栈顶元素。")]),t._v(" "),e("li",[e("code",[t._v("getMin()")]),t._v(" —— 检索栈中的最小元素。")])]),t._v(" "),e("p",[e("strong",[t._v("示例:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("MinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   --\x3e 返回 -3.\nminStack.pop();\nminStack.top();      --\x3e 返回 0.\nminStack.getMin();   --\x3e 返回 -2.\n")])])]),e("h4",{attrs:{id:"_2-解法-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-解法-2"}},[t._v("#")]),t._v(" 2. 解法")]),t._v(" "),e("p",[t._v("在常数时间内检索到最小元素的栈，即仅需保证 "),e("code",[t._v("getMin")]),t._v(" 的时间复杂度为 O(1) 即可")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var MinStack = function() {\n    this.items = []\n    this.min = null\n};\n\n// 进栈\nMinStack.prototype.push = function(x) {\n    if(!this.items.length) this.min = x \n    this.min = Math.min(x, this.min)\n    this.items.push(x) \n};\n\n// 出栈\nMinStack.prototype.pop = function() {\n    let num = this.items.pop() \n    this.min = Math.min(...this.items)\n    return num\n};\n\n// 获取栈顶元素\nMinStack.prototype.top = function() {\n    if(!this.items.length) return null\n    return this.items[this.items.length -1] \n};\n\n// 检索栈中的最小元素\nMinStack.prototype.getMin = function() {\n    return this.min\n};\n")])])]),e("p",[e("strong",[t._v("时间复杂度：进栈O(1)，出栈O(n)，获取栈顶元素O(1)，获取最小元素O(1)")])]),t._v(" "),e("p",[e("strong",[t._v("空间复杂度：O(n)")])]),t._v(" "),e("h4",{attrs:{id:"_3-更多题解-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-更多题解-3"}},[t._v("#")]),t._v(" 3. 更多题解")]),t._v(" "),e("p",[t._v("详见 "),e("strong",[t._v("字节&leetcode155：最小栈（包含getMin函数的栈）")]),t._v("[30]")]),t._v(" "),e("h3",{attrs:{id:"五、图解腾讯-leetcode20-有效的括号"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#五、图解腾讯-leetcode20-有效的括号"}},[t._v("#")]),t._v(" 五、图解腾讯&leetcode20：有效的括号")]),t._v(" "),e("h4",{attrs:{id:"_1-题目-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-题目-3"}},[t._v("#")]),t._v(" 1. 题目")]),t._v(" "),e("p",[t._v("给定一个只包括 "),e("code",[t._v("'('")]),t._v(" ，"),e("code",[t._v("')'")]),t._v(" ，"),e("code",[t._v("'{'")]),t._v(" ，"),e("code",[t._v("'}'")]),t._v(" ，"),e("code",[t._v("'['")]),t._v(" ，"),e("code",[t._v("']'")]),t._v(" 的字符串，判断字符串是否有效。")]),t._v(" "),e("p",[t._v("有效字符串需满足：")]),t._v(" "),e("ul",[e("li",[t._v("左括号必须用相同类型的右括号闭合。")]),t._v(" "),e("li",[t._v("左括号必须以正确的顺序闭合。")])]),t._v(" "),e("p",[t._v("注意空字符串可被认为是有效字符串。")]),t._v(" "),e("p",[e("strong",[t._v("示例 1:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('输入: "()"\n输出: true\n')])])]),e("p",[e("strong",[t._v("示例 2:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('输入: "()[]{}"\n输出: true\n')])])]),e("p",[e("strong",[t._v("示例 3:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('输入: "(]"\n输出: false\n')])])]),e("p",[e("strong",[t._v("示例 4:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('输入: "([)]"\n输出: false\n')])])]),e("p",[e("strong",[t._v("示例 5:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('输入: "{[]}"\n输出: true\n')])])]),e("h4",{attrs:{id:"_2-解法-利用栈结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-解法-利用栈结构"}},[t._v("#")]),t._v(" 2. 解法：利用栈结构")]),t._v(" "),e("p",[e("strong",[t._v("解题思路：")]),t._v(" 将字符串中的字符依次入栈，遍历字符依次判断：")]),t._v(" "),e("ul",[e("li",[t._v("首先判断该元素是否是 "),e("code",[t._v("{")]),t._v(" 、 "),e("code",[t._v("(")]),t._v(" 、 "),e("code",[t._v("[")]),t._v(" ，直接入栈")]),t._v(" "),e("li",[t._v("否则该字符为 "),e("code",[t._v("}")]),t._v(" 、 "),e("code",[t._v(")")]),t._v(" 、 "),e("code",[t._v("]")]),t._v(" 中的一种，如果该字符串有效，则该元素应该与栈顶匹配，例如栈中元素有 "),e("code",[t._v("({")]),t._v("， 如果继续遍历到的元素为 "),e("code",[t._v(")")]),t._v(", 那么当前元素序列为 "),e("code",[t._v("({)")]),t._v(" 是不可能有效的，所以此时与栈顶元素匹配失败，则直接返回 "),e("code",[t._v("false")]),t._v(" ，字符串无效")])]),t._v(" "),e("p",[t._v("当遍历完成时，所有已匹配的字符都已匹配出栈，如果此时栈为空，则字符串有效，如果栈不为空，说明字符串中还有未匹配的字符，字符串无效")]),t._v(" "),e("p",[e("strong",[t._v("画图帮助理解一下：")])]),t._v(" "),e("p",[e("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),t._v(" "),e("p",[e("strong",[t._v("代码实现：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var isValid = function(s) {\n    let map = {\n        '{': '}',\n        '(': ')',\n        '[': ']'\n    }\n    let stack = []\n    for(let i = 0; i < s.length ; i++) {\n        if(map[s[i]]) {\n            stack.push(s[i])\n        } else if(s[i] !== map[stack.pop()]){\n            return false\n        }\n    }\n    return stack.length === 0\n};\n")])])]),e("p",[e("strong",[t._v("时间复杂度：O(n)")])]),t._v(" "),e("p",[e("strong",[t._v("空间复杂度：O(n)")])]),t._v(" "),e("h4",{attrs:{id:"_3-更多题解-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-更多题解-4"}},[t._v("#")]),t._v(" 3. 更多题解")]),t._v(" "),e("p",[t._v("详见 "),e("strong",[t._v("图解腾讯&leetcode20：有效的括号")]),t._v("[31]")]),t._v(" "),e("h3",{attrs:{id:"六、leetcode1047-删除字符串中的所有相邻重复项"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#六、leetcode1047-删除字符串中的所有相邻重复项"}},[t._v("#")]),t._v(" 六、leetcode1047：删除字符串中的所有相邻重复项")]),t._v(" "),e("h4",{attrs:{id:"_1-题目-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-题目-4"}},[t._v("#")]),t._v(" 1. 题目")]),t._v(" "),e("p",[t._v("给出由小写字母组成的字符串 "),e("code",[t._v("S")]),t._v(" ，"),e("strong",[t._v("重复项删除操作")]),t._v(" 会选择两个相邻且相同的字母，并删除它们。")]),t._v(" "),e("p",[t._v("在 S 上反复执行重复项删除操作，直到无法继续删除。")]),t._v(" "),e("p",[t._v("在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。")]),t._v(" "),e("p",[e("strong",[t._v("示例：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('输入："abbaca"\n输出："ca"\n解释：\n例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。\n')])])]),e("p",[e("strong",[t._v("提示：")])]),t._v(" "),e("ol",[e("li",[e("code",[t._v("<= S.length <= 20000")])]),t._v(" "),e("li",[e("code",[t._v("S")]),t._v(" 仅由小写英文字母组成。")])]),t._v(" "),e("h4",{attrs:{id:"_2-解法-利用栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-解法-利用栈"}},[t._v("#")]),t._v(" 2. 解法：利用栈")]),t._v(" "),e("p",[e("strong",[t._v("解题思路：")]),t._v(" 遍历字符串，依次入栈，入栈时判断与栈头元素是否一致，如果一致，即这两个元素相同相邻，则需要将栈头元素出栈，并且当前元素也无需入栈")]),t._v(" "),e("p",[e("strong",[t._v("解题步骤：")]),t._v(" 遍历字符串，取出栈头字符，判断当前字符与栈头字符是否一致")]),t._v(" "),e("ul",[e("li",[t._v("不一致，栈头字符进栈，当前字符进栈")]),t._v(" "),e("li",[t._v("一致，即栈头字符与当前字符相同相邻，都不需要进栈，直接进入下次遍历即可")])]),t._v(" "),e("p",[t._v("遍历完成后，返回栈中字符串")]),t._v(" "),e("p",[e("strong",[t._v("代码实现：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var removeDuplicates = function(S) {\n    let stack = []\n    for(c of S) {\n        let prev = stack.pop()\n        if(prev !== c) {\n            stack.push(prev)\n            stack.push(c)\n        }\n    }\n    return stack.join('')\n};\n")])])]),e("p",[e("strong",[t._v("时间复杂度：O(n)")])]),t._v(" "),e("p",[e("strong",[t._v("空间复杂度：O(n)")])]),t._v(" "),e("h4",{attrs:{id:"_3-更多题解-5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-更多题解-5"}},[t._v("#")]),t._v(" 3. 更多题解")]),t._v(" "),e("p",[t._v("详见 "),e("strong",[t._v("leetcode1047：删除字符串中的所有相邻重复项")]),t._v("[32]")])])}),[],!1,null,null,null);e.default=n.exports}}]);