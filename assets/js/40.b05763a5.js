(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{332:function(n,v,_){"use strict";_.r(v);var t=_(4),a=Object(t.a)({},(function(){var n=this,v=n._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[v("h1",{attrs:{id:"前端进阶算法1-如何分析、统计算法的执行效率和资源消耗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#前端进阶算法1-如何分析、统计算法的执行效率和资源消耗"}},[n._v("#")]),n._v(" 前端进阶算法1：如何分析、统计算法的执行效率和资源消耗？")]),n._v(" "),v("p",[n._v("原创 前端瓶子君 前端瓶子君 "),v("em",[n._v("2020-03-31")])]),n._v(" "),v("h3",{attrs:{id:"简介"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[n._v("#")]),n._v(" 简介")]),n._v(" "),v("p",[n._v("前端还要学算法？必须学，而且必须狠狠地学。现在去大厂面试，数据结构与算法已经是标配，要是不会的话，那基本与大厂无缘了。")]),n._v(" "),v("p",[n._v("作为一名前端，虽然在平常开发中很少写算法，但当我们需要深入前端框架、开发语言、开源库时，懂算法将大大提高我们看源码的能力。例如 react 的 diff 算法、webpack 中利用 tree-shaking 优化、v8 中的调用栈、消息队列等，这些就大量使用了算法，看懂了就能更好的了解它们的性能，更高效的解决问题，进阶到更高 Level，赚更多钱。")]),n._v(" "),v("p",[n._v("现在市面上的算法资料很多，但针对前端的算法资料少之又少，所以，这里我整理了一份适用于前端的数据结构与算法系列，希望能帮助你从0到1构建完整的数据结构与算法体系。")]),n._v(" "),v("p",[n._v("本系列预估一共有40多篇，本篇是第一篇。想要更多更快的学习本系列，可以关注公众号「前端瓶子君」或点击原文查看。")]),n._v(" "),v("h3",{attrs:{id:"一、为什么引入复杂度分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、为什么引入复杂度分析"}},[n._v("#")]),n._v(" 一、为什么引入复杂度分析")]),n._v(" "),v("p",[n._v("我们知道，好的数据结构与算法能够大大缩短代码的执行时间与存储空间，那么我们如何去衡量它喃？本节就主要介绍算法性能的衡量指标—复杂度分析。")]),n._v(" "),v("p",[n._v("判断一段代码执行的效率最简单最直观的方式就是把它放在机器上执行一遍，自然就会得到算法的执行时间与占用内存大小。那么为什么还要引入复杂度分析喃？")]),n._v(" "),v("p",[n._v("这主要是因为，通过机器上运行代码来统计算法的性能，有很大的局限性，它容易受测试环境、数据规模影响：")]),n._v(" "),v("ul",[v("li",[n._v("统计结果易受测试环境影响：不同系统、处理器的机器测试结果可能出现很大的不同")]),n._v(" "),v("li",[n._v("统计结果易受数据本身、数据规模影响：不同的数据、不同长度的数据都可能对测试结果产生巨大的影响")])]),n._v(" "),v("p",[n._v("而这些都不是我们想要看到的。我们需要的是不受外在因素影响的、大致的估计算法执行效率的方法。这就是使用复杂度分析的原因。")]),n._v(" "),v("h3",{attrs:{id:"二、如何表示复杂度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二、如何表示复杂度"}},[n._v("#")]),n._v(" 二、如何表示复杂度")]),n._v(" "),v("p",[n._v("如何表示算法复杂度，具体来讲就是代码执行的时间、执行消耗的存储空间。例如：")]),n._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[n._v("function cal(n) {\n    let sum = 0; // 1 unit_time\n    let i = 0; // 1 unit_time\n    for(; i <= n; i++) { // n unit_time\n        sum += i; // n unit_time\n    }\n    return sum\n}\n")])])]),v("p",[n._v("从 CPU 的角度看，每段代码不过是读写数据或操作数据，尽管每次操作 CPU 执行的个数、执行的时间都不同，但我们粗咯把每次执行的时间都一致，称为 "),v("code",[n._v("unit_time")]),n._v(" 。")]),n._v(" "),v("p",[n._v("所以上述代码总共执行 "),v("code",[n._v("(2n+2)*unit_time")]),n._v(" 时间，即："),v("code",[n._v("T(n)=(2n+2)*unit_time")]),n._v(" ，所以，我们可以写成：")]),n._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[n._v("T(n) = O(f(n))\n")])])]),v("p",[n._v("其中：")]),n._v(" "),v("ul",[v("li",[n._v("n：表示数据规模的大小")]),n._v(" "),v("li",[n._v("f(n)：表示每行代码执行的次数总和")]),n._v(" "),v("li",[n._v("O：表示代码的执行时间 T(n) 与 f(n) 表达式成正比")])]),n._v(" "),v("p",[n._v("当 n 很大时，例如 10000，甚至更大，"),v("code",[n._v("T(n) = O(f(n))")]),n._v(" 可以表示为 "),v("code",[n._v("T(n) = O(n)")]),n._v(" 。")]),n._v(" "),v("p",[n._v("这就是"),v("strong",[n._v("大 O 时间复杂度表示法")]),n._v("。"),v("strong",[n._v("大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势")]),n._v("，所以，也叫作"),v("strong",[n._v("渐进时间复杂度（asymptotic time complexity）")]),n._v("，简称"),v("strong",[n._v("时间复杂度")]),n._v("。")]),n._v(" "),v("h3",{attrs:{id:"三、时间复杂度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三、时间复杂度"}},[n._v("#")]),n._v(" 三、时间复杂度")]),n._v(" "),v("p",[n._v("当 n 无限大时，时间复杂度 "),v("code",[n._v("T(n)")]),n._v(" 受 n 的最高数量级影响最大，与"),v("code",[n._v("f(n)")]),n._v(" 中的常量、低阶、系数关系就不那么大了。所以我们分析代码的时间复杂度时，仅仅关注代码执行次数最多的那段就可以了。")]),n._v(" "),v("p",[n._v("看一个例子：")]),n._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[n._v("function fun1(n) {\n    let sum = 0,i = 0;\n    for(; i <= n; i++) {\n        sum += i;\n    }\n    return sum\n}\nfunction fun2(n) {\n    let sum = 0, sum1 = 0, i = 0, j = 0;\n    for(; i <= n; i++) { // 循环1\n        sum += i;\n    }\n    for(i = 0; i <= n; i++) { // 循环2\n        for(j = 0; j <= n; j++) {\n            sum += i * j;\n        }\n    }\n    return sum\n}\nfunction fun3(n) {\n    let sum = 0, i = 0;\n    for(; i <= n; i++) {\n        sum += fun(i);\n    }\n    return sum\n}\n")])])]),v("p",[v("code",[n._v("fun1")]),n._v(" 中第1行都是常量，对 n 的影响不大，所以总的时间复杂度要看第2、3行的循环，即时间复杂度为："),v("code",[n._v("O(n)")]),n._v(" 。")]),n._v(" "),v("p",[v("code",[n._v("fun2")]),n._v(" 中循环1的时间复杂度为 O(n) ，循环2的时间复杂度为 O(n2)，当 n 趋于无穷大时，总体的时间复杂度要趋于 O(n2) ，即上面代码的时间复杂度是 O(n2)。")]),n._v(" "),v("p",[v("code",[n._v("fun3")]),n._v(" 的时间复杂度是 "),v("code",[n._v("O(n * T(fun)) = O(n*n)")]),n._v(" ，即 O(n2) 。")]),n._v(" "),v("p",[v("strong",[n._v("所以：T(c+n)=O(n)，T(m+n)=O(max(m, n))，T(n) = T1(n) T2(m) = O(nm)，其中 c 为常量")])]),n._v(" "),v("h5",{attrs:{id:"常见复杂度-按数量阶递增"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常见复杂度-按数量阶递增"}},[n._v("#")]),n._v(" 常见复杂度（按数量阶递增）")]),n._v(" "),v("p",[v("strong",[n._v("多项式量级：")])]),n._v(" "),v("ul",[v("li",[n._v("常量阶：O(1)：当算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)")]),n._v(" "),v("li",[n._v("对数阶：O(logn): 简单介绍一下")])]),n._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[n._v("let i=1;\nwhile (i <= n)  {\n  i = i * 2;\n}\n")])])]),v("ul",[v("li",[n._v("每次循环 "),v("code",[n._v("i")]),n._v(" 都乘以 "),v("code",[n._v("2")]),n._v(" ，直至 "),v("code",[n._v("i > n")]),n._v(" ，即执行过程是：20、21、22、…、2k、…、2x、 n 所以总执行次数 x ，可以写成 2x = n ，则时间复杂度为 O(log2n) 。这里是 "),v("code",[n._v("2")]),n._v(" ，也可以是其他常量 "),v("code",[n._v("k")]),n._v(" ，时间复杂度也是：O(log3n) = O(log32 * log2n) = O(log2n)")]),n._v(" "),v("li",[n._v("线性阶：O(n)")]),n._v(" "),v("li",[n._v("线性对数阶：O(nlogn)")]),n._v(" "),v("li",[n._v("平方阶、立方阶、….、k次方阶：O(n2)、O(n3)、…、O(nk)")])]),n._v(" "),v("p",[v("strong",[n._v("非多项式量阶：")])]),n._v(" "),v("ul",[v("li",[n._v("指数阶：O(2n)")]),n._v(" "),v("li",[n._v("阶乘阶：O(n!)")])]),n._v(" "),v("h3",{attrs:{id:"四、空间复杂度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四、空间复杂度"}},[n._v("#")]),n._v(" 四、空间复杂度")]),n._v(" "),v("p",[n._v("时间复杂度表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度表示算法的存储空间与数据规模之间的增长关系。例如：")]),n._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[n._v("function fun(n) {\n    let a = [];\n    for (let i = 0; i < n; i++) {\n        a.push(i);\n    }\n    return a;\n}\n")])])]),v("p",[n._v("以上代码我们可以清晰的看出代码执行的空间为 O(1+n) = O(n)，即为 i 及数组 a 占用的储存空间。")]),n._v(" "),v("p",[n._v("所以，空间复杂度分析比时间复杂度分析要简单很多。")]),n._v(" "),v("h3",{attrs:{id:"五、平均时间复杂度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#五、平均时间复杂度"}},[n._v("#")]),n._v(" 五、平均时间复杂度")]),n._v(" "),v("p",[n._v("时间复杂度受数据本身影响，还分为：")]),n._v(" "),v("ul",[v("li",[n._v("最好时间复杂度：在最理想的情况下，执行这段代码的时间复杂度")]),n._v(" "),v("li",[n._v("最坏时间复杂度：在最糟糕的情况下，执行这段代码的时间复杂度")]),n._v(" "),v("li",[n._v("平均时间复杂度：所有情况下，求一个平均值，可以省略掉系数、低阶、常量")])]),n._v(" "),v("h3",{attrs:{id:"六、参考资料"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#六、参考资料"}},[n._v("#")]),n._v(" 六、参考资料")]),n._v(" "),v("p",[n._v("极客时间的数据结构与算法之美")]),n._v(" "),v("p",[n._v("学习JavaScript数据结构与算法")]),n._v(" "),v("h3",{attrs:{id:"七、认识更多的前端道友-一起进阶前端开发"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#七、认识更多的前端道友-一起进阶前端开发"}},[n._v("#")]),n._v(" 七、认识更多的前端道友，一起进阶前端开发")]),n._v(" "),v("p",[n._v("前端算法集训营第一期免费开营啦🎉🎉🎉，免费哟！")]),n._v(" "),v("p",[n._v("在这里，你可以和志同道合的前端朋友们一起进阶前端算法，从0到1构建完整的数据结构与算法体系。")]),n._v(" "),v("p",[n._v("扫码加入【前端算法交流群交流群】，若二维码失效后，可在公众号「前端瓶子君」内回复「算法」")])])}),[],!1,null,null,null);v.default=a.exports}}]);