(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{320:function(_,t,i){"use strict";i.r(t);var a=i(4),v=Object(a.a)({},(function(){var _=this,t=_._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"简单复习下前端算法复杂度相关的知识"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简单复习下前端算法复杂度相关的知识"}},[_._v("#")]),_._v(" 简单复习下前端算法复杂度相关的知识")]),_._v(" "),t("blockquote",[t("p",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/TQpBj4D_2LaVKzTzXBiC7A",target:"_blank",rel:"noopener noreferrer"}},[_._v("https://mp.weixin.qq.com/s/TQpBj4D_2LaVKzTzXBiC7A"),t("OutboundLink")],1)])]),_._v(" "),t("p",[_._v("从广义上讲")]),_._v(" "),t("blockquote",[t("p",[_._v("数据结构就是指"),t("code",[_._v("一组数据的存储结构")]),_._v("。")]),_._v(" "),t("p",[_._v("算法就是"),t("code",[_._v("操作数据的一组方法")]),_._v("。")])]),_._v(" "),t("h2",{attrs:{id:"从狭义上讲"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#从狭义上讲"}},[_._v("#")]),_._v(" 从狭义上讲")]),_._v(" "),t("p",[_._v("是指某些著名的数据结构和算法，比如队列、栈、堆、二分查找、动态规划等")]),_._v(" "),t("h2",{attrs:{id:"数据结构和算法关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据结构和算法关系"}},[_._v("#")]),_._v(" 数据结构和算法关系")]),_._v(" "),t("p",[_._v("数据结构是为算法服务的，算法要作用在特定的数据结构之上")]),_._v(" "),t("blockquote",[t("p",[_._v("比如，因为数组具有随机访问的特点，常用的二分查找算法需要用数组来存储数据。但如果我们选择链表这种数据结构，二分查找算法就无法工作了，因为链表并不支持随机访问")])]),_._v(" "),t("h1",{attrs:{id:"复杂度分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#复杂度分析"}},[_._v("#")]),_._v(" 复杂度分析")]),_._v(" "),t("h2",{attrs:{id:"事后统计法的局限性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事后统计法的局限性"}},[_._v("#")]),_._v(" 事后统计法的局限性")]),_._v(" "),t("ol",[t("li",[_._v("测试结果非常依赖测试环境")])]),_._v(" "),t("p",[_._v("测试环境中硬件的不同会对测试结果有很大的影响")]),_._v(" "),t("ol",[t("li",[_._v("测试结果受数据规模的影响很大")])]),_._v(" "),t("h3",{attrs:{id:"对于小规模的数据排序-插入排序可能反倒会比快速排序要快"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对于小规模的数据排序-插入排序可能反倒会比快速排序要快"}},[_._v("#")]),_._v(" 对于小规模的数据排序，插入排序可能反倒会比快速排序要快")]),_._v(" "),t("h2",{attrs:{id:"大-o-复杂度表示法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#大-o-复杂度表示法"}},[_._v("#")]),_._v(" 大 O 复杂度表示法")]),_._v(" "),t("ul",[t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li")]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v(" int cal(int n) {   int sum = 0;   int i = 1;   int j = 1;   for (; i <= n; ++i) {     j = 1;     for (; j <= n; ++j) {       sum = sum +  i * j;     }   } }\n")])])]),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/KEXUm19zKo7cbqGKbHhKea4IjdwN9Fd2Hss7JUzXS0oJI5MAkor5fG5GGpIozw4KIkEziad2u9rhcV1Eicy94Wfg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),_._v(" "),t("h3",{attrs:{id:"公式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#公式"}},[_._v("#")]),_._v(" 公式：")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/iclmxCdEUxyL0tIn2EOzAAFraeAofUPLzCyoopHPlEqJ4mYRvaEc6dIK5gHYtpAYc35tlf4U7yHjeF9flvrkFyQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),_._v(" "),t("blockquote",[t("p",[_._v("上边例子可表示为T(n) = O(2n^2+2n+3)")])]),_._v(" "),t("p",[_._v("大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是"),t("code",[_._v("表示代码执行时间随数据规模增长的变化趋势")]),_._v("，所以，也叫"),t("code",[_._v("作渐进时间复杂度")]),_._v("（asymptotic time complexity），简称"),t("code",[_._v("时间复杂度")]),_._v("。")]),_._v(" "),t("p",[t("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),_._v(" "),t("p",[t("strong",[_._v("常量级时间")])]),_._v(" "),t("p",[_._v("即便这段代码循环 10000 次、100000 次，只要是一个已知的数，跟 n 无关，照样也是常量级的执行时间")]),_._v(" "),t("h2",{attrs:{id:"时间复杂度分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度分析"}},[_._v("#")]),_._v(" 时间复杂度分析")]),_._v(" "),t("h3",{attrs:{id:"_1-只关注循环执行次数最多的一段代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-只关注循环执行次数最多的一段代码"}},[_._v("#")]),_._v(" 1. 只关注循环执行次数最多的一段代码")]),_._v(" "),t("blockquote",[t("p",[_._v("忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了")]),_._v(" "),t("p",[_._v("我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。这段核心代码执行次数的 n 的量级，就是整段要分析代码的时间复杂度。")])]),_._v(" "),t("ul",[t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li")]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v(" int cal(int n) {   int sum = 0;   int i = 1;   for (; i <= n; ++i) {     sum = sum + i;   }   return sum; }\n")])])]),t("ol",[t("li",[_._v("第 2、3 行代码都是常量级的执行时间，与 n 的大小无关，所以对于复杂度并没有影响。")]),_._v(" "),t("li",[_._v("循环执行次数最多的是第 4、5 行代码，所以这块代码要重点分析。这两行代码被执行了 n 次，所以总的时间复杂度就是 "),t("code",[_._v("O(n)")])])]),_._v(" "),t("h3",{attrs:{id:"_2-加法法则-总复杂度等于量级最大的那段代码的复杂度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-加法法则-总复杂度等于量级最大的那段代码的复杂度"}},[_._v("#")]),_._v(" 2. 加法法则：总复杂度等于量级最大的那段代码的复杂度")]),_._v(" "),t("ul",[t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li")]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("int cal(int n) {   int sum_1 = 0;   int p = 1;   for (; p < 100; ++p) {     sum_1 = sum_1 + p;   }\n   int sum_2 = 0;   int q = 1;   for (; q < n; ++q) {     sum_2 = sum_2 + q;   }    int sum_3 = 0;   int i = 1;   int j = 1;   for (; i <= n; ++i) {     j = 1;      for (; j <= n; ++j) {       sum_3 = sum_3 +  i * j;     }   }    return sum_1 + sum_2 + sum_3; }\n")])])]),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/KEXUm19zKo7cbqGKbHhKea4IjdwN9Fd2GRIy0oLBDfcqby1v1v6rcxiawjias1VO95yfGlFhOfBJWGOJmYRHaV6g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),_._v(" "),t("h3",{attrs:{id:"_3-乘法法则-嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-乘法法则-嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"}},[_._v("#")]),_._v(" 3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积")]),_._v(" "),t("p",[_._v("落实到具体的代码上，我们可以把乘法法则看成是"),t("code",[_._v("嵌套循环")])]),_._v(" "),t("ul",[t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li")]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("int cal(int n) {   int ret = 0;    int i = 1;   for (; i < n; ++i) {     ret = ret + f(i);   }  }   int f(int n) {  int sum = 0;  int i = 1;  for (; i < n; ++i) {    sum = sum + i;  }   return sum; }\n")])])]),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/KEXUm19zKo7cbqGKbHhKea4IjdwN9Fd262pHnQuQqibg2ibXqnNSAEyhic2hYIteqb8rulabE1k9WYYYibibzc0Qsrw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),_._v(" "),t("p",[_._v("几种常见时间复杂度实例分析")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/KEXUm19zKo7cbqGKbHhKea4IjdwN9Fd2tnl7AaC2kEYNnlXe2sjj2G0cfMpqmLsOnbeabJV6rDbzNfKQ7MibjHQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),_._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/iclmxCdEUxyL0tIn2EOzAAFraeAofUPLzH2plTVxicTaUxLBL7Wbp2Zg8qDXiboSt9BE3Q1m3xpiajibgvjR9triafrg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),_._v(" "),t("h4",{attrs:{id:"_1-o-1-常量级时间复杂度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-o-1-常量级时间复杂度"}},[_._v("#")]),_._v(" 1. O(1)常量级时间复杂度")]),_._v(" "),t("p",[_._v("要代码的执行时间"),t("code",[_._v("不随 n 的增大而增长")]),_._v("，这样代码的时间复杂度我们都记作 "),t("code",[_._v("O(1)")]),_._v("。")]),_._v(" "),t("p",[_._v("只要算法中"),t("code",[_._v("不存在")]),t("strong",[t("code",[_._v("循环语句")])]),_._v("、"),t("strong",[t("code",[_._v("递归语句")])]),_._v("，即使有成千上万行的代码，其时间复杂度也是Ο(1)。")]),_._v(" "),t("h4",{attrs:{id:"_2-o-logn-、o-nlogn-对数阶时间复杂度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-o-logn-、o-nlogn-对数阶时间复杂度"}},[_._v("#")]),_._v(" 2. O(logn)、O(nlogn)对数阶时间复杂度")]),_._v(" "),t("ul",[t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li")]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("i=1; while (i <= n)  {   i = i * 2; }\n")])])]),t("blockquote",[t("p",[_._v("变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时")]),_._v(" "),t("p",[_._v("变量 i 的取值就是一个等比数列")])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/iclmxCdEUxyL0tIn2EOzAAFraeAofUPLz6ZS4He0FztBQxBOqFXiaJSTMREqqp6P7ibBvFPfkJib1YznT3MnljTCwg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),_._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/KEXUm19zKo7cbqGKbHhKea4IjdwN9Fd2TOCFicsoDz98V6IQrS3ngLIWx1FnAFuf8SpLN54nNphrxDy2utgUZvQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),_._v(" "),t("h4",{attrs:{id:"_3-o-m-n-、o-m-n-由两个数据的规模来决定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-o-m-n-、o-m-n-由两个数据的规模来决定"}},[_._v("#")]),_._v(" 3. O(m+n)、O(m*n)由两个数据的规模来决定")]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("int cal(int m, int n) {\n  int sum_1 = 0;\n  int i = 1;\n  for (; i < m; ++i) {\n    sum_1 = sum_1 + i;\n  }\n\n  int sum_2 = 0;\n  int j = 1;\n  for (; j < n; ++j) {\n    sum_2 = sum_2 + j;\n  }\n\n  return sum_1 + sum_2;\n}\n\n复制代码\n")])])]),t("p",[_._v("上面代码的时间复杂度就是 O(m+n)")]),_._v(" "),t("h2",{attrs:{id:"空间复杂度分析-只计算与n有关的内存空间"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#空间复杂度分析-只计算与n有关的内存空间"}},[_._v("#")]),_._v(" 空间复杂度分析（只计算与n有关的内存空间）")]),_._v(" "),t("blockquote",[t("p",[_._v("空间复杂度全称就是"),t("code",[_._v("渐进空间复杂度")]),_._v("（asymptotic space complexity），"),t("code",[_._v("表示算法的存储空间与数据规模之间的增长关系")])]),_._v(" "),t("p",[_._v("常见的空间复杂度就是 "),t("code",[_._v("O(1)")]),_._v("、"),t("code",[_._v("O(n)")]),_._v("、"),t("code",[_._v("O(n2 )")]),_._v("，像 "),t("code",[_._v("O(logn)")]),_._v("、"),t("code",[_._v("O(nlogn)")]),_._v(" 这样的对数阶复杂度平时都用不到")])]),_._v(" "),t("ul",[t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li")]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("void print(int n) {  int i = 0;  int[] a = new int[n];  for (i; i <n; ++i) {    a[i] = i * i;  }\n  for (i = n-1; i >= 0; --i) {    print out a[i]  }}\n")])])]),t("p",[_._v("第 2 行代码中，我们申请了一个空间存储变量 "),t("code",[_._v("i")]),_._v("，但是它是"),t("code",[_._v("常量阶的")]),_._v("，跟数据规模 "),t("code",[_._v("n 没有关系")]),_._v("，所以我们可以"),t("code",[_._v("忽略")]),_._v("。")]),_._v(" "),t("p",[_._v("第 3 行申请了一个大小为 "),t("code",[_._v("n 的 int 类型数组")]),_._v("，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 "),t("code",[_._v("O(n)")]),_._v("。")]),_._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[_._v("#")]),_._v(" 总结")]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("复杂度`也叫`渐进复杂度`，包括`时间复杂度`和`空间复杂度`，用来分析`算法执行效率`与`数据规模`之间的增长关系，可以粗略地表示，`越高阶复杂度的算法，执行效率越低\n")])])]),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/iclmxCdEUxyL0tIn2EOzAAFraeAofUPLzxLno7YpZWib34FHrtuQJbUotibucvic5iafqHk8CibdI6O34LsOD5ok8obQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),_._v(" "),t("h1",{attrs:{id:"浅析最好、最坏、平均、均摊时间复杂度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浅析最好、最坏、平均、均摊时间复杂度"}},[_._v("#")]),_._v(" 浅析最好、最坏、平均、均摊时间复杂度")]),_._v(" "),t("h2",{attrs:{id:"最好、最坏情况时间复杂度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最好、最坏情况时间复杂度"}},[_._v("#")]),_._v(" 最好、最坏情况时间复杂度")]),_._v(" "),t("ul",[t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li")]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("// n表示数组array的长度int find(int[] array, int n, int x) {  int i = 0;  int pos = -1;  for (; i < n; ++i) {    if (array[i] == x) pos = i;  }  return pos;}\n")])])]),t("p",[_._v("上面 这段代码的复杂度是 O(n)，其中，n 代表数组的长度")]),_._v(" "),t("ul",[t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li")]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("int find(int[] array, int n, int x) {  int i = 0;  int pos = -1;  for (; i < n; ++i) {    if (array[i] == x) {       pos = i;       break;  //加入了break    }  }  return pos;}\n")])])]),t("blockquote",[t("p",[_._v("上边的代码 如果数组中第一个元素正好是要查找的变量 x，那就不需要继续遍历剩下的 n-1 个数据了，那时间复杂度就是 O(1)。")]),_._v(" "),t("p",[_._v("但如果数组中不存在变量 x，那我们就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)。所以，不同的情况下，这段代码的时间复杂度是不一样的。")])]),_._v(" "),t("h3",{attrs:{id:"最好情况时间复杂度就是-在最理想的情况下-执行这段代码的时间复杂度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最好情况时间复杂度就是-在最理想的情况下-执行这段代码的时间复杂度"}},[_._v("#")]),_._v(" 最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度")]),_._v(" "),t("h3",{attrs:{id:"最坏情况时间复杂度就是-在最糟糕的情况下-执行这段代码的时间复杂度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最坏情况时间复杂度就是-在最糟糕的情况下-执行这段代码的时间复杂度"}},[_._v("#")]),_._v(" 最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度")]),_._v(" "),t("h2",{attrs:{id:"平均情况时间复杂度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#平均情况时间复杂度"}},[_._v("#")]),_._v(" 平均情况时间复杂度")]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("// n表示数组array的长度\nint find(int[] array, int n, int x) {\n  int i = 0;\n  int pos = -1;\n  for (; i < n; ++i) {\n    if (array[i] == x) {\n       pos = i;\n       break;  //加入了break\n    }\n  }\n  return pos;\n}\n")])])]),t("p",[_._v("假设"),t("code",[_._v("在数组中")]),_._v("与"),t("code",[_._v("不在数组中")]),_._v("的概率都为 "),t("code",[_._v("1/2")]),_._v("。")]),_._v(" "),t("p",[_._v("另外，要查找的数据出现在 "),t("code",[_._v("0～n-1")]),_._v(" 这 "),t("code",[_._v("n")]),_._v(" 个位置的概率也是一样的，为 "),t("code",[_._v("1/n")]),_._v("。")]),_._v(" "),t("p",[_._v("所以，根据概率乘法法则，要查找的数据出现在 "),t("code",[_._v("0～n-1")]),_._v(" 中任意位置的概率就是 "),t("code",[_._v("1/(2n)")])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/iclmxCdEUxyL0tIn2EOzAAFraeAofUPLz0x5SRoQFhAVibAu1sS1Lv4eMzhw9ebhyHZmYEbibeGAgPEJIhBu6iaIug/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),_._v(" "),t("p",[_._v("这个值就是"),t("code",[_._v("概率论")]),_._v("中的"),t("code",[_._v("加权平均值")]),_._v("，也叫作"),t("code",[_._v("期望值")]),_._v("，")]),_._v(" "),t("p",[_._v("所以"),t("code",[_._v("平均时间复杂度")]),_._v("的全称应该叫"),t("code",[_._v("加权平均时间复杂度")]),_._v("或者"),t("code",[_._v("期望时间复杂度")]),_._v("。")]),_._v(" "),t("p",[_._v("用大 O 表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是 "),t("code",[_._v("O(n)")]),_._v("。")]),_._v(" "),t("blockquote",[t("p",[_._v("大多数情况下，我们并不需要区分最好、最坏、平均情况时间复杂度三种情况")]),_._v(" "),t("p",[_._v("只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分")])]),_._v(" "),t("h2",{attrs:{id:"均摊时间复杂度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#均摊时间复杂度"}},[_._v("#")]),_._v(" 均摊时间复杂度")]),_._v(" "),t("blockquote",[t("p",[_._v("摊还分析法，通过摊还分析得到的时间复杂度我们起了一个名字，叫均摊时间复杂度。")])]),_._v(" "),t("ul",[t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li")]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v(" // array表示一个长度为n的数组 // 代码中的array.length就等于n int[] array = new int[n]; int count = 0;  void insert(int val) {    if (count == array.length) {       int sum = 0;       for (int i = 0; i < array.length; ++i) {          sum = sum + array[i];       }       array[0] = sum;       count = 1;    }\n    array[count] = val;    ++count; }\n")])])]),t("p",[_._v("这段代码实现了一个往数组中插入数据的功能。")]),_._v(" "),t("p",[_._v("当数组满了之后，也就是代码中的 count == array.length 时，我们用 for 循环遍历数组求和，并清空数组，将求和之后的 sum 值放到数组的第一个位置")]),_._v(" "),t("p",[_._v("然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组")]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("最理想的情况下`，数组中有空闲空间，我们只需要将数据插入到数组下标为 count 的位置就可以了，所以最好情况时间复杂度为 `O(1)\n")])])]),t("p",[t("code",[_._v("最坏的情况下")]),_._v("，数组中没有空闲空间了，我们需要先做一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为 O(n)")]),_._v(" "),t("p",[t("code",[_._v("平均时间复杂度")]),_._v("是O(1): 假设数组的长度是 n，根据数据插入的位置的不同，我们可以分为 n 种情况，每种情况的时间复杂度是 O(1)。除此之外，还有一种“额外”的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是 O(n)。而且，这 n+1 种情况发生的概率一样，都是 1/(n+1)。所以，根据加权平均的计算方法，我们求得的平均时间复杂度就是：")]),_._v(" "),t("p",[t("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),_._v(" "),t("p",[_._v("O(n) 的插入操作 就是 "),t("code",[_._v("最坏的情况下")]),_._v(" 求和清空插入 O(1) 的插入操作 就是 "),t("code",[_._v("最理想的情况下")]),_._v(" 直接插入")]),_._v(" "),t("p",[_._v("每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)，这就是均摊分析的大致思路")]),_._v(" "),t("blockquote",[t("p",[_._v("在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。")])]),_._v(" "),t("ul",[t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li"),_._v(" "),t("li")]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("// 全局变量，大小为10的数组array，长度len，下标i。int array[] = new int[10]; int len = 10;int i = 0;\n// 往数组中添加一个元素void add(int element) {   if (i >= len) { // 数组空间不够了     // 重新申请一个2倍大小的数组空间     int new_array[] = new int[len*2];     // 把原来array数组中的数据依次copy到new_array     for (int j = 0; j < len; ++j) {       new_array[j] = array[j];     }     // new_array复制给array，array现在大小就是2倍len了     array = new_array;     len = 2 * len;   }   // 将element放到下标为i的位置，下标i加一   array[i] = element;   ++i;}\n")])])]),t("blockquote",[t("p",[_._v("转自：https://juejin.cn/post/7001810638703951902")])])])}),[],!1,null,null,null);t.default=v.exports}}]);