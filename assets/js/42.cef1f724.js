(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{334:function(e,t,a){"use strict";a.r(t);var s=a(4),v=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"_10-问-10-答-带你快速入门前端算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-问-10-答-带你快速入门前端算法"}},[e._v("#")]),e._v(" 10 问 10 答，带你快速入门前端算法")]),e._v(" "),t("p",[e._v("原创 前端瓶子君 前端瓶子君 "),t("em",[e._v("2020-04-11")])]),e._v(" "),t("h3",{attrs:{id:"引言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引言"}},[e._v("#")]),e._v(" 引言")]),e._v(" "),t("p",[e._v("各位大佬好，本节是前端进阶算法集训营半月的总结与回顾👇，主要内容包括：")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&mid=2247484204&idx=1&sn=3433b9191b67ac9b09452b0d6e3a0639&chksm=faec87f4cd9b0ee213f03f451069f4c5fd352cf0c573d043c1819760ef1085a4457af99605a8&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("前端进阶算法1：如何分析、统计算法的执行效率和资源消耗？"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&mid=2247484213&idx=1&sn=6b7b9cd11b7a151b1b5396c918d7692f&chksm=faec87edcd9b0efb118b006b13b3df234aa3c8a5aa5bcd168cdf07ee3990fee28a5f039baa0f&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("前端进阶算法2：从Chrome V8源码看JavaScript数组(附赠腾讯面试题)"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&mid=2247484265&idx=1&sn=7feafe63a80ce6371a1b6834884a6d05&chksm=faec87b1cd9b0ea7ea773e24341918cefa1df7ccbc2c12c0fee679fcf62d2603f86351f732d1&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("前端进阶算法3：从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&mid=2247484292&idx=1&sn=c2dfcccab0ed82267061340f969d5de2&chksm=faec875ccd9b0e4a4b1b015785bd439c9ec37ca6882e9b18f66c523e03110e29f1b6d4c57f62&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("前端进阶算法4：链表原来如此简单(+leetcode刷题）"),t("OutboundLink")],1)])]),e._v(" "),t("p",[e._v("以及题目：")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("图解leetcode88：合并两个有序数组")]),e._v("[1]")]),e._v(" "),t("li",[t("strong",[e._v("字节&leetcode1：两数之和")]),e._v("[2]")]),e._v(" "),t("li",[t("strong",[e._v("腾讯：数组扁平化、去重、排序")]),e._v("[3]")]),e._v(" "),t("li",[t("strong",[e._v("leetcode349：给定两个数组，编写一个函数来计算它们的交集")]),e._v("[4]")]),e._v(" "),t("li",[t("strong",[e._v("leetcode146：设计和实现一个LRU（最近最少使用）缓存机制")]),e._v("[5]")]),e._v(" "),t("li",[t("strong",[e._v("阿里算法题：编写一个函数计算多个数组的交集")]),e._v("[6]")]),e._v(" "),t("li",[t("strong",[e._v("leetcode21：合并两个有序链表")]),e._v("[7]")]),e._v(" "),t("li",[t("strong",[e._v("有赞&leetcode141：判断一个单链表是否有环")]),e._v("[8]")]),e._v(" "),t("li",[t("strong",[e._v("图解leetcode206：反转链表")]),e._v("[9]")])]),e._v(" "),t("p",[e._v("下面进入正文吧👇")]),e._v(" "),t("h3",{attrs:{id:"一、前端进阶算法1-如何分析、统计算法的执行效率和资源消耗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、前端进阶算法1-如何分析、统计算法的执行效率和资源消耗"}},[e._v("#")]),e._v(" 一、前端进阶算法1：如何分析、统计算法的执行效率和资源消耗？")]),e._v(" "),t("p",[e._v("好的数据结构与算法能够大大缩短代码的执行时间与存储空间，那么我们如何去衡量它喃？这节就主要介绍算法性能的衡量指标—复杂度分析。")]),e._v(" "),t("p",[e._v("复杂度可分为：")]),e._v(" "),t("ul",[t("li",[e._v("时间复杂度")]),e._v(" "),t("li",[e._v("空间复杂度")])]),e._v(" "),t("h4",{attrs:{id:"_1-如何表示算法复杂度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-如何表示算法复杂度"}},[e._v("#")]),e._v(" 1. 如何表示算法复杂度？")]),e._v(" "),t("p",[e._v("通常采用 "),t("strong",[e._v("大 O 表示法")]),e._v(" 来表示复杂度。它并不代表真正的执行时间或存储空间消耗，而是表示代码执行时间随数据规模增长的变化趋势（时间复杂度）或存储空间随数据规模增长的变化趋势（空间复杂度），所以，也叫作"),t("strong",[e._v("渐进时间（或空间）复杂度（asymptotic time complexity）")]),e._v("，简称"),t("strong",[e._v("时间（或空间）复杂度")]),e._v("。")]),e._v(" "),t("h4",{attrs:{id:"_2-常见复杂度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-常见复杂度"}},[e._v("#")]),e._v(" 2. 常见复杂度")]),e._v(" "),t("p",[t("strong",[e._v("多项式量级：")])]),e._v(" "),t("ul",[t("li",[e._v("常量阶：O(1)：当算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)")]),e._v(" "),t("li",[e._v("对数阶：O(logn): 简单介绍一下")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let i=1;\nwhile (i <= n)  {\n  i = i * 2;\n}\n")])])]),t("ul",[t("li",[e._v("每次循环 "),t("code",[e._v("i")]),e._v(" 都乘以 "),t("code",[e._v("2")]),e._v(" ，直至 "),t("code",[e._v("i > n")]),e._v(" ，即执行过程是：20、21、22、…、2k、…、2x、 n 所以总执行次数 x ，可以写成 2x = n ，则时间复杂度为 O(log2n) 。这里是 "),t("code",[e._v("2")]),e._v(" ，也可以是其他常量 "),t("code",[e._v("k")]),e._v(" ，时间复杂度也是：O(log~3~n) = O(log32 * log2n) = O(log2n)")]),e._v(" "),t("li",[e._v("线性阶：O(n)")]),e._v(" "),t("li",[e._v("线性对数阶：O(nlogn)")]),e._v(" "),t("li",[e._v("平方阶、立方阶、….、k次方阶：O(n2)、O(n3)、…、O(nk)")])]),e._v(" "),t("p",[t("strong",[e._v("非多项式量阶：")])]),e._v(" "),t("ul",[t("li",[e._v("指数阶：O(2n)")]),e._v(" "),t("li",[e._v("阶乘阶：O(n!)")])]),e._v(" "),t("h4",{attrs:{id:"_3-复杂度的划分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-复杂度的划分"}},[e._v("#")]),e._v(" 3. 复杂度的划分")]),e._v(" "),t("p",[e._v("以时间复杂度为例，时间复杂度受数据本身影响，还分为：")]),e._v(" "),t("ul",[t("li",[e._v("最好时间复杂度：在最理想的情况下，执行这段代码的时间复杂度")]),e._v(" "),t("li",[e._v("最坏时间复杂度：在最糟糕的情况下，执行这段代码的时间复杂度")]),e._v(" "),t("li",[e._v("平均时间复杂度：所有情况下，求一个平均值，可以省略掉系数、低阶、常量")])]),e._v(" "),t("p",[e._v("详情："),t("strong",[e._v("前端进阶算法1：如何分析、统计算法的执行效率和资源消耗？")]),e._v("[10]")]),e._v(" "),t("h3",{attrs:{id:"二、前端进阶算法2-从chrome-v8源码看javascript数组-附赠腾讯面试题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、前端进阶算法2-从chrome-v8源码看javascript数组-附赠腾讯面试题"}},[e._v("#")]),e._v(" 二、前端进阶算法2：从Chrome V8源码看JavaScript数组（附赠腾讯面试题）")]),e._v(" "),t("h4",{attrs:{id:"_1-javascript-中-数组的应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-javascript-中-数组的应用"}},[e._v("#")]),e._v(" 1. JavaScript 中，数组的应用")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let arr = [1, 2, 3]\n")])])]),t("p",[e._v("它的这种特定的存储结构决定了：")]),e._v(" "),t("p",[t("strong",[e._v("优点")])]),e._v(" "),t("ul",[t("li",[e._v("随机访问：可以通过下标随机访问数组中的任意位置上的数据")])]),e._v(" "),t("p",[t("strong",[e._v("缺点")])]),e._v(" "),t("ul",[t("li",[e._v("对数据的删除和插入不是很友好")])]),e._v(" "),t("p",[t("strong",[e._v("查找：")]),e._v(" 根据下标随机访问的时间复杂度为 O(1)；")]),e._v(" "),t("p",[t("strong",[e._v("插入或删除：")]),e._v(" 时间复杂度为 O(n)；")]),e._v(" "),t("p",[e._v("在 JavaScript 中的数组几乎是万能的，它不光可以作为一个普通的数组使用，可以作为栈或队列使用。")]),e._v(" "),t("p",[e._v("数组：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let array = [1, 2, 3]\n")])])]),t("p",[e._v("栈：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let stack = [1, 2, 3]\n// 进栈\nstack.push(4)\n// 出栈\nstcak.pop()\n")])])]),t("p",[e._v("队列：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let queue = [1, 2, 3]\n// 进队\nqueue.push(4)\n// 出队\nqueue.shift()\n")])])]),t("h4",{attrs:{id:"_2-javascript-中-数组的独特之处"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-javascript-中-数组的独特之处"}},[e._v("#")]),e._v(" 2. JavaScript 中，数组的独特之处")]),e._v(" "),t("blockquote",[t("p",[e._v("我们知道在 JavaScript 中，可以在数组中保存不同类型值，并且数组可以动态增长，不像其它语言，例如 C，创建的时候要决定数组的大小，如果数组满了，就要重新申请内存空间。这是为什么喃？")])]),e._v(" "),t("p",[e._v("JavaScript 中， "),t("code",[e._v("JSArray")]),e._v(" 继承自 "),t("code",[e._v("JSObject")]),e._v(" ，或者说它就是一个特殊的对象，内部是以 key-value 形式存储数据，所以 JavaScript 中的数组可以存放不同类型的值。它有两种存储方式，快数组与慢数组，初始化空数组时，使用快数组，快数组使用连续的内存空间，当数组长度达到最大时，"),t("code",[e._v("JSArray")]),e._v(" 会进行动态的扩容，以存储更多的元素，相对慢数组，性能要好得多。当数组中 "),t("code",[e._v("hole")]),e._v(" 太多时，会转变成慢数组，即以哈希表的方式（ key-value 的形式）存储数据，以节省内存空间。")]),e._v(" "),t("p",[e._v("具体快慢数组、动态扩容前往："),t("strong",[e._v("前端进阶算法2：从Chrome V8源码看JavaScript数组（附赠腾讯面试题）")]),e._v("[11]")]),e._v(" "),t("h3",{attrs:{id:"三、前端进阶算法3-从浏览器缓存淘汰策略和vue的keep-alive学习lru算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、前端进阶算法3-从浏览器缓存淘汰策略和vue的keep-alive学习lru算法"}},[e._v("#")]),e._v(" 三、前端进阶算法3：从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法")]),e._v(" "),t("h4",{attrs:{id:"_1-浏览器缓存淘汰策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-浏览器缓存淘汰策略"}},[e._v("#")]),e._v(" 1. 浏览器缓存淘汰策略")]),e._v(" "),t("p",[e._v("当我们打开一个网页时，例如 "),t("code",[e._v("https://github.com/sisterAn/JavaScript-Algorithms")]),e._v(" ，它会在发起真正的网络请求前，查询浏览器缓存，看是否有要请求的文件，如果有，浏览器将会拦截请求，返回缓存文件，并直接结束请求，不会再去服务器上下载。如果不存在，才会去服务器请求。")]),e._v(" "),t("p",[e._v("其实，浏览器中的缓存是一种在本地保存资源副本，它的大小是有限的，当我们请求数过多时，缓存空间会被用满，此时，继续进行网络请求就需要确定缓存中哪些数据被保留，哪些数据被移除，这就是"),t("strong",[e._v("浏览器缓存淘汰策略")]),e._v("，最常见的淘汰策略有 FIFO（先进先出）、LFU（最少使用）、LRU（最近最少使用）。")]),e._v(" "),t("p",[e._v("LRU （ "),t("code",[e._v("Least Recently Used")]),e._v(" ：最近最少使用 ）缓存淘汰策略，故名思义，就是根据数据的历史访问记录来进行淘汰数据，其核心思想是 "),t("strong",[e._v("如果数据最近被访问过，那么将来被访问的几率也更高")]),e._v(" ，优先淘汰最近没有被访问到的数据。")]),e._v(" "),t("p",[e._v("画个图帮助我们理解 LRU：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQ3WsOP2syTPC4uAkQaScm1vaibj2l4F1OW4AiaEyTAaWq0yN9icXgR4twutq8J1ThxuTrQxfeDgm3IA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),t("h4",{attrs:{id:"_2-vue-的-keep-alive-源码解读"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-vue-的-keep-alive-源码解读"}},[e._v("#")]),e._v(" 2. Vue 的 keep-alive 源码解读")]),e._v(" "),t("p",[e._v("在 "),t("code",[e._v("keep-alive")]),e._v(" 缓存超过 "),t("code",[e._v("max")]),e._v(" 时，使用的缓存淘汰算法就是 LRU 算法，它在实现的过程中用到了 "),t("code",[e._v("cache")]),e._v(" 对象用于保存缓存的组件实例及 "),t("code",[e._v("key")]),e._v(" 值，"),t("code",[e._v("keys")]),e._v(" 数组用于保存缓存组件的 "),t("code",[e._v("key")]),e._v("，当 "),t("code",[e._v("keep-alive")]),e._v(" 中渲染一个需要缓存的实例时：")]),e._v(" "),t("ul",[t("li",[e._v("判断缓存中是否已缓存了该实例，缓存了则直接获取，并调整 "),t("code",[e._v("key")]),e._v(" 在 "),t("code",[e._v("keys")]),e._v(" 中的位置（移除 "),t("code",[e._v("keys")]),e._v(" 中 "),t("code",[e._v("key")]),e._v(" ，并放入 "),t("code",[e._v("keys")]),e._v(" 数组的最后一位）")]),e._v(" "),t("li",[e._v("如果没有缓存，则缓存该实例，若 "),t("code",[e._v("keys")]),e._v(" 的长度大于 "),t("code",[e._v("max")]),e._v(" （缓存长度超过上限），则移除 "),t("code",[e._v("keys[0]")]),e._v(" 缓存")])]),e._v(" "),t("p",[e._v("主要实现LRU代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// --------------------------------------------------\n// 下面就是 LRU 算法了，\n// 如果在缓存里有则调整，\n// 没有则放入（长度超过 max，则淘汰最近没有访问的）\n// --------------------------------------------------\n// 如果命中缓存，则从缓存中获取 vnode 的组件实例，\n// 并且调整 key 的顺序放入 keys 数组的末尾\nif (cache[key]) {\n  vnode.componentInstance = cache[key].componentInstance;\n  // make current key freshest\n  remove(keys, key);\n  keys.push(key);\n}\n// 如果没有命中缓存,就把 vnode 放进缓存\nelse {\n  cache[key] = vnode;\n  keys.push(key);\n  // prune oldest entry\n  // 如果配置了 max 并且缓存的长度超过了 this.max，还要从缓存中删除第一个\n  if (this.max && keys.length > parseInt(this.max)) {\n    pruneCacheEntry(cache, keys[0], keys, this._vnode);\n  }\n}\n")])])]),t("p",[e._v("源码详情："),t("strong",[e._v("前端进阶算法3：从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法")]),e._v("[12]")]),e._v(" "),t("h3",{attrs:{id:"四、前端进阶算法4-链表原来如此简单-leetcode刷题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四、前端进阶算法4-链表原来如此简单-leetcode刷题"}},[e._v("#")]),e._v(" 四、前端进阶算法4：链表原来如此简单（+leetcode刷题）")]),e._v(" "),t("h4",{attrs:{id:"_1-图解链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-图解链表"}},[e._v("#")]),e._v(" 1. 图解链表")]),e._v(" "),t("p",[e._v("常用的链表类型有单链表、双链表以及循环链表，其中 "),t("code",[e._v("next")]),e._v(" 为后继指针，指向它的后继节点，"),t("code",[e._v("prev")]),e._v(" 为前驱指针，指向它的前驱节点。")]),e._v(" "),t("p",[t("strong",[e._v("单链表")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQ3WsOP2syTPC4uAkQaScm1FFt3MOlGW5Uia2GnF906dJmsBq6DFXk6ibicSmTMdGz9DbQVZ9X6yIDAA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),t("p",[t("strong",[e._v("双链表")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQ3WsOP2syTPC4uAkQaScm1kJaibq1enTywseChcGXhBIibZMibMSkC0rCts2Wgo38F1SPica8via0GgLQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),t("p",[t("strong",[e._v("循环链表")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQ3WsOP2syTPC4uAkQaScm1dlKquJjOHVVVZ9yJWtN23gYiaeTib3m8ZLnP4ObMlMdd9IQpBN9M0tng/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),t("h4",{attrs:{id:"_2-链表复杂度一览表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-链表复杂度一览表"}},[e._v("#")]),e._v(" 2. 链表复杂度一览表")]),e._v(" "),t("p",[t("strong",[e._v("单链表")])]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",{staticStyle:{"text-align":"center"}},[e._v("操作方法")]),e._v(" "),t("th",{staticStyle:{"text-align":"center"}},[e._v("时间复杂度")]),e._v(" "),t("th",{staticStyle:{"text-align":"center"}},[e._v("说明")])])]),e._v(" "),t("tbody",[t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("append")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("O(n)")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("在链表尾部追加节点")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("search")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("O(n)")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("在链表中查找任意元素")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("insert")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("O(n)")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("在链表中任意位置插入一个节点")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("remove")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("O(n)")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("删除链表中任意位置的一个节点")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("searchNext")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("O(1)")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("查找某节点的后继节点")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("insertNext")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("O(1)")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("在某一节点后插入一个节点（后继节点）")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("removeNext")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("O(1)")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("在某一节点后删除一个节点（后继节点）")])])])]),e._v(" "),t("p",[t("strong",[e._v("双链表")])]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",{staticStyle:{"text-align":"center"}},[e._v("操作方法")]),e._v(" "),t("th",{staticStyle:{"text-align":"center"}},[e._v("时间复杂度")]),e._v(" "),t("th",{staticStyle:{"text-align":"center"}},[e._v("说明")])])]),e._v(" "),t("tbody",[t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("search")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("O(n)")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("在链表中查找任意元素")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("insert")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("O(n)")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("在链表中任意位置插入一个节点")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("remove")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("O(n)")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("删除链表中任意位置的一个节点")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("searchNext 或 searchPre")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("O(1)")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("查找某节点的后继节点或前驱节点")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("insertNext 或 insertPre")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("O(1)")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("插入某节点的后继节点或前驱节点")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("removeNext 或 removePre")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("O(1)")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("删除某节点的前驱节点或后继节点")])])])]),e._v(" "),t("p",[t("strong",[e._v("循环链表")])]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",{staticStyle:{"text-align":"center"}},[e._v("操作方法")]),e._v(" "),t("th",{staticStyle:{"text-align":"center"}},[e._v("时间复杂度")]),e._v(" "),t("th",{staticStyle:{"text-align":"center"}},[e._v("说明")])])]),e._v(" "),t("tbody",[t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("search")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("O(n)")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("在链表中查找任意元素")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("insert")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("O(n)")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("在链表中任意位置插入一个节点")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("remove")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("O(n)")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("删除链表中任意位置的一个节点")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("searchNext")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("O(1)")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("查找某节点的后继节点")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("insertNext")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("O(1)")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("在某一节点后插入一个节点（后继节点）")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("removeNext")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("O(1)")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("在某一节点后删除一个节点（后继节点）")])])])]),e._v(" "),t("p",[e._v("详情："),t("strong",[e._v("前端进阶算法4：链表原来如此简单（+leetcode刷题）")]),e._v("[13]")]),e._v(" "),t("h3",{attrs:{id:"五、图解leetcode88-合并两个有序数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#五、图解leetcode88-合并两个有序数组"}},[e._v("#")]),e._v(" 五、图解leetcode88：合并两个有序数组")]),e._v(" "),t("h4",{attrs:{id:"_1-题目"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-题目"}},[e._v("#")]),e._v(" 1. 题目")]),e._v(" "),t("p",[e._v("给你两个有序整数数组 "),t("code",[e._v("nums1")]),e._v(" 和 "),t("code",[e._v("nums2")]),e._v("，请你将 "),t("code",[e._v("nums2")]),e._v(" 合并到 "),t("code",[e._v("nums1")]),e._v(" 中，使 "),t("code",[e._v("num1")]),e._v(" 成为一个有序数组。")]),e._v(" "),t("p",[e._v("说明:")]),e._v(" "),t("p",[e._v("初始化 "),t("code",[e._v("nums1")]),e._v(" 和 "),t("code",[e._v("nums2")]),e._v(" 的元素数量分别为 "),t("code",[e._v("m")]),e._v(" 和 "),t("code",[e._v("n")]),e._v(" 。你可以假设 "),t("code",[e._v("nums1")]),e._v(" 有足够的空间（空间大小大于或等于 "),t("code",[e._v("m + n")]),e._v(" ）来保存 "),t("code",[e._v("nums2")]),e._v(" 中的元素。")]),e._v(" "),t("p",[t("strong",[e._v("示例:")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("输入:\nnums1 = [1,2,3,0,0,0], m = 3\nnums2 = [2,5,6],       n = 3\n\n输出: [1,2,2,3,5,6]\n")])])]),t("h4",{attrs:{id:"_2-解答"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-解答"}},[e._v("#")]),e._v(" 2. 解答")]),e._v(" "),t("p",[t("strong",[e._v("解题思路：")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQ3WsOP2syTPC4uAkQaScm1yLq60Diceic2MMgId8HhDfzcn0Mm5nIKWXFzRj2xpEWuOV72TxFVH5fA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),t("ul",[t("li",[t("p",[t("code",[e._v("nums1")]),e._v(" 、 "),t("code",[e._v("nums2")]),e._v(" 有序，若把 "),t("code",[e._v("nums2")]),e._v(" 全部合并到 "),t("code",[e._v("nums1")]),e._v(" ，则合并后的 "),t("code",[e._v("nums1")]),e._v(" 长度为 "),t("code",[e._v("m+n")])])]),e._v(" "),t("li",[t("p",[e._v("我们可以从下标 "),t("code",[e._v("m+n-1")]),e._v(" 的位置填充 "),t("code",[e._v("nums1")]),e._v(" ，比较 "),t("code",[e._v("nums1[len1]")]),e._v(" 与 "),t("code",[e._v("nums2[len2]")]),e._v(" 的大小，将最大值写入 "),t("code",[e._v("nums1[len]")]),e._v("，即")])]),e._v(" "),t("li",[t("ul",[t("li",[t("code",[e._v("nums1[len1]>=nums2[len2]")]),e._v(" ，"),t("code",[e._v("nums1[len--] = nums1[len1--]")]),e._v(" ,这里 "),t("code",[e._v("--")]),e._v(" 是因为写入成功后，下标自动建议，继续往前比较")]),e._v(" "),t("li",[e._v("否则 "),t("code",[e._v("nums1[len--] = nums2[len2--]")])])])]),e._v(" "),t("li",[t("p",[e._v("边界条件：")])]),e._v(" "),t("li",[t("ul",[t("li",[e._v("若 "),t("code",[e._v("len1 < 0")]),e._v("，即 "),t("code",[e._v("len2 >= 0")]),e._v(" ，此时 "),t("code",[e._v("nums1")]),e._v(" 已重写入， "),t("code",[e._v("nums2")]),e._v(" 还未合并完，仅仅需要将 "),t("code",[e._v("nums2")]),e._v(" 的剩余元素（0…len）写入 "),t("code",[e._v("nums2")]),e._v(" 即可，写入后，合并完成")]),e._v(" "),t("li",[e._v("若 "),t("code",[e._v("len2 < 0")]),e._v("，此时 "),t("code",[e._v("nums2")]),e._v(" 已全部合并到 "),t("code",[e._v("nums1")]),e._v(" ，合并完成")])])])]),e._v(" "),t("p",[t("strong",[e._v("时间复杂度为 O(m+n)")])]),e._v(" "),t("p",[t("strong",[e._v("代码实现：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var merge = function(nums1, m, nums2, n) {\n    let len1 = m - 1,\n        len2 = n - 1,\n        len = m + n - 1\n    while(len2 >= 0) {\n        if(len1 < 0) {\n            nums1[len--] = nums2[len2--]\n            continue\n        }\n        nums1[len--] = nums1[len1] >= nums2[len2] ? nums1[len1--]: nums2[len2--]\n    }\n};\n")])])]),t("h4",{attrs:{id:"_3-更多解答请看-图解leetcode88-合并两个有序数组-14"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-更多解答请看-图解leetcode88-合并两个有序数组-14"}},[e._v("#")]),e._v(" 3. 更多解答请看：图解leetcode88：合并两个有序数组[14]")]),e._v(" "),t("h3",{attrs:{id:"六、字节-leetcode1-两数之和"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#六、字节-leetcode1-两数之和"}},[e._v("#")]),e._v(" 六、字节&leetcode1：两数之和")]),e._v(" "),t("h4",{attrs:{id:"_1-题目-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-题目-2"}},[e._v("#")]),e._v(" 1. 题目")]),e._v(" "),t("p",[e._v("给定一个整数数组 "),t("code",[e._v("nums")]),e._v(" 和一个目标值 "),t("code",[e._v("target")]),e._v(" ，请你在该数组中找出和为目标值的那 "),t("strong",[e._v("两个")]),e._v(" 整数，并返回他们的数组下标。")]),e._v(" "),t("p",[e._v("你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。")]),e._v(" "),t("p",[t("strong",[e._v("示例:")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n")])])]),t("h4",{attrs:{id:"_2-解答-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-解答-2"}},[e._v("#")]),e._v(" 2. 解答")]),e._v(" "),t("p",[t("strong",[e._v("解题思路：")])]),e._v(" "),t("ul",[t("li",[t("p",[e._v("初始化一个 "),t("code",[e._v("map = new Map()")])])]),e._v(" "),t("li",[t("p",[e._v("从第一个元素开始遍历 "),t("code",[e._v("nums")])])]),e._v(" "),t("li",[t("p",[e._v("获取目标值与 "),t("code",[e._v("nums[i]")]),e._v(" 的差值，即 "),t("code",[e._v("k = target - nums[i]")]),e._v(" ，判断差值在 "),t("code",[e._v("map")]),e._v(" 中是否存在")])]),e._v(" "),t("li",[t("ul",[t("li",[e._v("不存在（ "),t("code",[e._v("map.has(k)")]),e._v(" 为 "),t("code",[e._v("false")]),e._v(" ） ，则将 "),t("code",[e._v("nums[i]")]),e._v(" 加入到 "),t("code",[e._v("map")]),e._v(" 中（key为"),t("code",[e._v("nums[i]")]),e._v(", value为 "),t("code",[e._v("i")]),e._v(" ，方便查找map中是否存在某值，并可以通过 "),t("code",[e._v("get")]),e._v(" 方法直接拿到下标）")]),e._v(" "),t("li",[e._v("存在（ "),t("code",[e._v("map.has(k)")]),e._v(" ），返回 "),t("code",[e._v("[map.get(k), i]")]),e._v(" ，求解结束")])])]),e._v(" "),t("li",[t("p",[e._v("遍历结束，则 "),t("code",[e._v("nums")]),e._v(" 中没有符合条件的两个数，返回 "),t("code",[e._v("[]")])])])]),e._v(" "),t("p",[t("strong",[e._v("时间复杂度：O(n)")])]),e._v(" "),t("p",[t("strong",[e._v("代码实现：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var twoSum = function(nums, target) {\n    let map = new Map()\n    for(let i = 0; i< nums.length; i++) {\n        let k = target-nums[i]\n        if(map.has(k)) {\n            return [map.get(k), i]\n        }\n        map.set(nums[i], i)\n    }\n    return [];\n};\n")])])]),t("h4",{attrs:{id:"_3-更多解答请看-字节-leetcode1-两数之和-15"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-更多解答请看-字节-leetcode1-两数之和-15"}},[e._v("#")]),e._v(" 3. 更多解答请看：字节&leetcode1：两数之和[15]")]),e._v(" "),t("h3",{attrs:{id:"七、腾讯-数组扁平化、去重、排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#七、腾讯-数组扁平化、去重、排序"}},[e._v("#")]),e._v(" 七、腾讯：数组扁平化、去重、排序")]),e._v(" "),t("h4",{attrs:{id:"_1-题目-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-题目-3"}},[e._v("#")]),e._v(" 1. 题目")]),e._v(" "),t("blockquote",[t("p",[e._v("已知如下数组：var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];")]),e._v(" "),t("p",[e._v("编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组")])]),e._v(" "),t("h4",{attrs:{id:"_2-答案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-答案"}},[e._v("#")]),e._v(" 2. 答案：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]\n// 扁平化\nlet flatArr = arr.flat(4)\n// 去重\nlet disArr = Array.from(new Set(flatArr))\n// 排序\nlet result = disArr.sort(function(a, b) {\n    return a-b\n})\nconsole.log(result)\n// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n")])])]),t("p",[e._v("感谢 "),t("strong",[e._v("352800205")]),e._v(" 的补充："),t("code",[e._v("flat()")]),e._v(" 方法对node版本有要求，至少需要12.0以上")]),e._v(" "),t("h4",{attrs:{id:"_3-更多解答请看-腾讯-数组扁平化、去重、排序-16"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-更多解答请看-腾讯-数组扁平化、去重、排序-16"}},[e._v("#")]),e._v(" 3. 更多解答请看：腾讯：数组扁平化、去重、排序[16]")]),e._v(" "),t("h3",{attrs:{id:"八、leetcode349-给定两个数组-编写一个函数来计算它们的交集"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#八、leetcode349-给定两个数组-编写一个函数来计算它们的交集"}},[e._v("#")]),e._v(" 八、leetcode349：给定两个数组，编写一个函数来计算它们的交集")]),e._v(" "),t("h4",{attrs:{id:"_1-题目-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-题目-4"}},[e._v("#")]),e._v(" 1. 题目")]),e._v(" "),t("p",[e._v("给定两个数组，编写一个函数来计算它们的交集。")]),e._v(" "),t("p",[t("strong",[e._v("示例 1:")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("输入: nums1 = [1,2,2,1], nums2 = [2,2]\n输出: [2]\n")])])]),t("p",[t("strong",[e._v("示例 2:")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n输出: [9,4]\n")])])]),t("p",[t("strong",[e._v("说明:")])]),e._v(" "),t("p",[e._v("输出结果中的每个元素一定是唯一的。我们可以不考虑输出结果的顺序。")]),e._v(" "),t("h4",{attrs:{id:"_2-答案-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-答案-2"}},[e._v("#")]),e._v(" 2. 答案")]),e._v(" "),t("p",[t("strong",[e._v("解题思路：")])]),e._v(" "),t("ul",[t("li",[t("code",[e._v("filter")]),e._v(" 过滤")]),e._v(" "),t("li",[t("code",[e._v("Set")]),e._v(" 去重")])]),e._v(" "),t("p",[t("strong",[e._v("代码实现：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var intersection = function(nums1, nums2) {\n    return [...new Set(nums1.filter((item)=>nums2.includes(item)))]\n};\n")])])]),t("h4",{attrs:{id:"_3-更多解答请看-leetcode349-给定两个数组-编写一个函数来计算它们的交集-17"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-更多解答请看-leetcode349-给定两个数组-编写一个函数来计算它们的交集-17"}},[e._v("#")]),e._v(" 3. 更多解答请看：leetcode349：给定两个数组，编写一个函数来计算它们的交集[17]")]),e._v(" "),t("h3",{attrs:{id:"九、leetcode146-设计和实现一个lru-最近最少使用-缓存机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#九、leetcode146-设计和实现一个lru-最近最少使用-缓存机制"}},[e._v("#")]),e._v(" 九、leetcode146：设计和实现一个LRU（最近最少使用）缓存机制")]),e._v(" "),t("h4",{attrs:{id:"_1-题目-5"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-题目-5"}},[e._v("#")]),e._v(" 1. 题目")]),e._v(" "),t("p",[e._v("运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作：获取数据 "),t("code",[e._v("get")]),e._v(" 和写入数据 "),t("code",[e._v("put")]),e._v(" 。")]),e._v(" "),t("p",[e._v("获取数据 "),t("code",[e._v("get(key)")]),e._v(" - 如果密钥 ( "),t("code",[e._v("key")]),e._v(" ) 存在于缓存中，则获取密钥的值（总是正数），否则返回 "),t("code",[e._v("-1")]),e._v(" 。写入数据 "),t("code",[e._v("put(key, value)")]),e._v(" - 如果密钥不存在，则写入数据。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据，从而为新数据留出空间。")]),e._v(" "),t("p",[t("strong",[e._v("进阶:")])]),e._v(" "),t("p",[e._v("你是否可以在 "),t("strong",[e._v("O(1)")]),e._v(" 时间复杂度内完成这两种操作？")]),e._v(" "),t("p",[t("strong",[e._v("示例:")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );\n\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);       // 返回  1\ncache.put(3, 3);    // 该操作会使得密钥 2 作废\ncache.get(2);       // 返回 -1 (未找到)\ncache.put(4, 4);    // 该操作会使得密钥 1 作废\ncache.get(1);       // 返回 -1 (未找到)\ncache.get(3);       // 返回  3\ncache.get(4);       // 返回  4\n")])])]),t("h4",{attrs:{id:"_2-答案-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-答案-3"}},[e._v("#")]),e._v(" 2. 答案")]),e._v(" "),t("p",[t("strong",[e._v("基础解法：数组+对象实现")])]),e._v(" "),t("p",[e._v("类 vue keep-alive 实现")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var LRUCache = function(capacity) {\n    this.keys = []\n    this.cache = Object.create(null)\n    this.capacity = capacity\n};\n\nLRUCache.prototype.get = function(key) {\n    if(this.cache[key]) {\n        // 调整位置\n        remove(this.keys, key)\n        this.keys.push(key)\n        return this.cache[key]\n    }\n    return -1\n};\n\nLRUCache.prototype.put = function(key, value) {\n    if(this.cache[key]) {\n        // 存在即更新\n        this.cache[key] = value\n        remove(this.keys, key)\n        this.keys.push(key)\n    } else {\n        // 不存在即加入\n        this.keys.push(key)\n        this.cache[key] = value\n        // 判断缓存是否已超过最大值\n        if(this.keys.length > this.capacity) {\n            removeCache(this.cache, this.keys, this.keys[0])\n        }\n    }\n};\n\n// 移除 key\nfunction remove(arr, key) {\n    if (arr.length) {\n        const index = arr.indexOf(key)\n        if (index > -1) {\n            return arr.splice(index, 1)\n        }\n    }\n}\n\n// 移除缓存中 key\nfunction removeCache(cache, keys, key) {\n    cache[key] = null\n    remove(keys, key)\n}\n")])])]),t("p",[t("strong",[e._v("进阶：Map")])]),e._v(" "),t("p",[e._v("利用 Map 既能保存键值对，并且能够记住键的原始插入顺序")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var LRUCache = function(capacity) {\n    this.cache = new Map()\n    this.capacity = capacity\n}\n\nLRUCache.prototype.get = function(key) {\n    if (this.cache.has(key)) {\n        // 存在即更新\n        let temp = this.cache.get(key)\n        this.cache.delete(key)\n        this.cache.set(key, temp)\n        return temp\n    }\n    return -1\n}\n\nLRUCache.prototype.put = function(key, value) {\n    if (this.cache.has(key)) {\n        // 存在即更新（删除后加入）\n        this.cache.delete(key)\n    } else if (this.cache.size >= this.capacity) {\n        // 不存在即加入\n        // 缓存超过最大值，则移除最近没有使用的\n        this.cache.delete(this.cache.keys().next().value)\n    }\n    this.cache.set(key, value)\n}\n")])])]),t("h4",{attrs:{id:"_3-更多解答请看-leetcode146-设计和实现一个lru-最近最少使用-缓存机制-18"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-更多解答请看-leetcode146-设计和实现一个lru-最近最少使用-缓存机制-18"}},[e._v("#")]),e._v(" 3. 更多解答请看：leetcode146：设计和实现一个LRU（最近最少使用）缓存机制[18]")]),e._v(" "),t("h3",{attrs:{id:"十、阿里算法题-编写一个函数计算多个数组的交集"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#十、阿里算法题-编写一个函数计算多个数组的交集"}},[e._v("#")]),e._v(" 十、阿里算法题：编写一个函数计算多个数组的交集")]),e._v(" "),t("h4",{attrs:{id:"_1-题目-6"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-题目-6"}},[e._v("#")]),e._v(" 1. 题目")]),e._v(" "),t("p",[e._v("**要求：**输出结果中的每个元素一定是唯一的")]),e._v(" "),t("h4",{attrs:{id:"_2-答案-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-答案-4"}},[e._v("#")]),e._v(" 2. 答案")]),e._v(" "),t("p",[e._v("使用 reducer 函数")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var intersection = function(...args) {\n    if (args.length === 0) {\n    return []\n  }\n  if (args.length === 1) {\n    return args[0]\n  }\n  return [...new Set(args.reduce((result, arg) => {\n    return result.filter(item => arg.includes(item))\n  }))]\n};\n")])])]),t("h4",{attrs:{id:"_3-更多解答请看-阿里算法题-编写一个函数计算多个数组的交集-19"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-更多解答请看-阿里算法题-编写一个函数计算多个数组的交集-19"}},[e._v("#")]),e._v(" 3. 更多解答请看：阿里算法题：编写一个函数计算多个数组的交集[19]")]),e._v(" "),t("h3",{attrs:{id:"十一、leetcode21-合并两个有序链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#十一、leetcode21-合并两个有序链表"}},[e._v("#")]),e._v(" 十一、leetcode21：合并两个有序链表")]),e._v(" "),t("h4",{attrs:{id:"_1-题目-7"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-题目-7"}},[e._v("#")]),e._v(" 1. 题目")]),e._v(" "),t("p",[e._v("将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。")]),e._v(" "),t("p",[t("strong",[e._v("示例：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("输入：1->2->4, 1->3->4\n输出：1->1->2->3->4->4\n")])])]),t("h4",{attrs:{id:"_2-答案-5"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-答案-5"}},[e._v("#")]),e._v(" 2. 答案")]),e._v(" "),t("p",[t("strong",[e._v("解答：")])]),e._v(" "),t("p",[t("strong",[e._v("确定解题的数据结构：")]),e._v(" 单链表")]),e._v(" "),t("p",[t("strong",[e._v("确定解题思路：")]),e._v(" 从链表头开始比较，"),t("code",[e._v("l1")]),e._v(" 与 "),t("code",[e._v("l2")]),e._v(" 是有序递增的，所以比较 "),t("code",[e._v("l1.val")]),e._v(" 与 "),t("code",[e._v("l2.val")]),e._v("的较小值就是合并后链表的最小值，次小值就是小节点的 "),t("code",[e._v("next.val")]),e._v(" 与大节点的 "),t("code",[e._v("val")]),e._v(" 比较的较小值，依次递归，直到递归到 "),t("code",[e._v("l1")]),e._v(" "),t("code",[e._v("l2")]),e._v(" 均为 "),t("code",[e._v("null")])]),e._v(" "),t("p",[t("strong",[e._v("画图实现：")]),e._v(" 画图帮助理解一下")]),e._v(" "),t("p",[t("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),t("p",[t("strong",[e._v("确定边界条件：")]),e._v(" 当递归到任意链表为 "),t("code",[e._v("null")]),e._v(" ，直接将 "),t("code",[e._v("next")]),e._v(" 指向另外的链表即可，不需要继续递归了")]),e._v(" "),t("p",[t("strong",[e._v("代码实现：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function mergeTwoLists(l1, l2) {\n    if(l1 === null) {\n        return l2\n    }\n    if(l2 === null) {\n        return l1\n    }\n    if(l1.val <= l2.val) {\n        l1.next = mergeTwoLists(l1.next, l2)\n        return l1\n    } else {\n        l2.next = mergeTwoLists(l2.next, l1)\n        return l2\n    }\n}\n")])])]),t("h4",{attrs:{id:"_3-更多解答请看-leetcode21-合并两个有序链表-20"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-更多解答请看-leetcode21-合并两个有序链表-20"}},[e._v("#")]),e._v(" 3. 更多解答请看：leetcode21：合并两个有序链表[20]")]),e._v(" "),t("h3",{attrs:{id:"十二、有赞-leetcode141-判断一个单链表是否有环"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#十二、有赞-leetcode141-判断一个单链表是否有环"}},[e._v("#")]),e._v(" 十二、有赞&leetcode141：判断一个单链表是否有环")]),e._v(" "),t("h4",{attrs:{id:"_1-题目-8"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-题目-8"}},[e._v("#")]),e._v(" 1. 题目")]),e._v(" "),t("p",[e._v("给定一个链表，判断链表中是否有环。")]),e._v(" "),t("p",[e._v("为了表示给定链表中的环，我们使用整数 "),t("code",[e._v("pos")]),e._v(" 来表示链表尾连接到链表中的位置（索引从 "),t("code",[e._v("0")]),e._v("开始）。如果 "),t("code",[e._v("pos")]),e._v(" 是 "),t("code",[e._v("-1")]),e._v("，则在该链表中没有环。")]),e._v(" "),t("p",[t("strong",[e._v("示例 1：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n")])])]),t("p",[t("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),t("p",[t("strong",[e._v("示例 2：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("输入：head = [1,2], pos = 0\n输出：true\n解释：链表中有一个环，其尾部连接到第一个节点。\n")])])]),t("p",[t("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),t("p",[t("strong",[e._v("示例 3：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("输入：head = [1], pos = -1\n输出：false\n解释：链表中没有环。\n")])])]),t("p",[t("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),t("p",[t("strong",[e._v("进阶：")])]),e._v(" "),t("p",[e._v("你能用 O(1)（即，常量）内存解决此问题吗？")]),e._v(" "),t("h4",{attrs:{id:"_2-答案-6"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-答案-6"}},[e._v("#")]),e._v(" 2. 答案")]),e._v(" "),t("h5",{attrs:{id:"解法一-标志法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解法一-标志法"}},[e._v("#")]),e._v(" 解法一：标志法")]),e._v(" "),t("p",[e._v("给每个已遍历过的节点加标志位，遍历链表，当出现下一个节点已被标志时，则证明单链表有环")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var hasCycle = function(head) {\n    while(head) {\n        if(head.flag) return true\n        head.flag = true\n        head = head.next\n    }\n    return false\n};\n")])])]),t("p",[t("strong",[e._v("时间复杂度：O(n)")])]),e._v(" "),t("p",[t("strong",[e._v("空间复杂度：O(n)")])]),e._v(" "),t("h5",{attrs:{id:"解法二-利用-json-stringify-不能序列化含有循环引用的结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解法二-利用-json-stringify-不能序列化含有循环引用的结构"}},[e._v("#")]),e._v(" 解法二：利用 "),t("code",[e._v("JSON.stringify()")]),e._v(" 不能序列化含有循环引用的结构")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var hasCycle = function(head) {\n    try{\n        JSON.stringify(head);\n        return false;\n    }\n    catch(err){\n        return true;\n    }\n};\n")])])]),t("p",[t("strong",[e._v("时间复杂度：O(n)")])]),e._v(" "),t("p",[t("strong",[e._v("空间复杂度：O(n)")])]),e._v(" "),t("h5",{attrs:{id:"解法三-快慢指针-双指针法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解法三-快慢指针-双指针法"}},[e._v("#")]),e._v(" 解法三：快慢指针（双指针法）")]),e._v(" "),t("p",[e._v("设置快慢两个指针，遍历单链表，快指针一次走两步，慢指针一次走一步，如果单链表中存在环，则快慢指针终会指向同一个节点，否则直到快指针指向 "),t("code",[e._v("null")]),e._v(" 时，快慢指针都不可能相遇")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var hasCycle = function(head) {\n    if(!head || !head.next) {\n        return false\n    }\n    let fast = head.next.next, slow = head\n    while(fast !== slow) {\n        if(!fast || !fast.next) return false\n        fast = fast.next.next\n        slow = slow.next\n    }\n    return true\n};\n")])])]),t("p",[t("strong",[e._v("时间复杂度：O(n)")])]),e._v(" "),t("p",[t("strong",[e._v("空间复杂度：O(1)")])]),e._v(" "),t("h4",{attrs:{id:"_3-更多解答请看-有赞-leetcode141-判断一个单链表是否有环-21"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-更多解答请看-有赞-leetcode141-判断一个单链表是否有环-21"}},[e._v("#")]),e._v(" 3. 更多解答请看：有赞&leetcode141：判断一个单链表是否有环[21]")]),e._v(" "),t("h3",{attrs:{id:"十三、图解leetcode206-反转链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#十三、图解leetcode206-反转链表"}},[e._v("#")]),e._v(" 十三、图解leetcode206：反转链表")]),e._v(" "),t("h4",{attrs:{id:"_1-题目-9"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-题目-9"}},[e._v("#")]),e._v(" 1. 题目")]),e._v(" "),t("p",[t("strong",[e._v("示例:")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("输入: 1->2->3->4->5->NULL\n输出: 5->4->3->2->1->NULL\n")])])]),t("p",[e._v("**进阶:**你可以迭代或递归地反转链表。你能否用两种方法解决这道题？")]),e._v(" "),t("h4",{attrs:{id:"_2-解答-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-解答-3"}},[e._v("#")]),e._v(" 2. 解答")]),e._v(" "),t("h5",{attrs:{id:"解法一-迭代法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解法一-迭代法"}},[e._v("#")]),e._v(" 解法一：迭代法")]),e._v(" "),t("p",[t("strong",[e._v("解题思路：")]),e._v(" 将单链表中的每个节点的后继指针指向它的前驱节点即可")]),e._v(" "),t("p",[t("strong",[e._v("画图实现：")]),e._v(" 画图帮助理解一下")]),e._v(" "),t("p",[t("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),t("p",[t("strong",[e._v("确定边界条件：")]),e._v(" 当链表为 "),t("code",[e._v("null")]),e._v(" 或链表中仅有一个节点时，不需要反转")]),e._v(" "),t("p",[t("strong",[e._v("代码实现：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var reverseList = function(head) {\n    if(!head || !head.next) return head\n    var prev = null, curr = head\n    while(curr) {\n        // 用于临时存储 curr 后继节点\n        var next = curr.next\n        // 反转 curr 的后继指针\n        curr.next = prev\n        // 变更prev、curr \n        // 待反转节点指向下一个节点 \n        prev = curr\n        curr = next\n    }\n    head = prev\n    return head\n};\n")])])]),t("p",[t("strong",[e._v("时间复杂度：O(n)")])]),e._v(" "),t("p",[t("strong",[e._v("空间复杂度：O(1)")])]),e._v(" "),t("h5",{attrs:{id:"解法二-尾递归法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解法二-尾递归法"}},[e._v("#")]),e._v(" 解法二：尾递归法")]),e._v(" "),t("p",[t("strong",[e._v("解题思路：")]),e._v(" 从头节点开始，递归反转它的每一个节点，直到 "),t("code",[e._v("null")]),e._v(" ，思路和解法一类似")]),e._v(" "),t("p",[t("strong",[e._v("代码实现：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var reverseList = function(head) {\n    if(!head || !head.next) return head\n    head = reverse(null, head)\n    return head\n};\n\nvar reverse = function(prev, curr) {\n    if(!curr) return prev\n    var next = curr.next\n    curr.next = prev\n    return reverse(curr, next)\n};\n")])])]),t("p",[t("strong",[e._v("时间复杂度：O(n)")])]),e._v(" "),t("p",[t("strong",[e._v("空间复杂度：O(n)")])]),e._v(" "),t("h5",{attrs:{id:"解法三-递归法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解法三-递归法"}},[e._v("#")]),e._v(" 解法三：递归法")]),e._v(" "),t("p",[t("strong",[e._v("解题思路：")]),e._v(" 不断递归反转当前节点 "),t("code",[e._v("head")]),e._v(" 的后继节点 "),t("code",[e._v("next")])]),e._v(" "),t("p",[t("strong",[e._v("画图实现：")]),e._v(" 画图帮助理解一下")]),e._v(" "),t("p",[t("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),t("p",[t("strong",[e._v("代码实现：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var reverseList = function(head) {\n    if(!head || !head.next) return head\n    var next = head.next\n    // 递归反转\n    var reverseHead = reverseList(next)\n    // 变更指针\n    next.next = head\n    head.next = null\n    return reverseHead\n};\n")])])]),t("p",[t("strong",[e._v("时间复杂度：O(n)")])]),e._v(" "),t("p",[t("strong",[e._v("空间复杂度：O(n)")])]),e._v(" "),t("h4",{attrs:{id:"_3-更多解答请看-图解-leetcode206-反转链表-22"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-更多解答请看-图解-leetcode206-反转链表-22"}},[e._v("#")]),e._v(" 3. 更多解答请看：图解 leetcode206：反转链表[22]")]),e._v(" "),t("h3",{attrs:{id:"十四、前端算法集训营第一期免费加入啦"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#十四、前端算法集训营第一期免费加入啦"}},[e._v("#")]),e._v(" 十四、前端算法集训营第一期免费加入啦")]),e._v(" "),t("p",[e._v("欢迎关注「前端瓶子君」，回复「算法」自动加入，从0到1构建完整的数据结构与算法体系！")]),e._v(" "),t("p",[e._v("在这里，瓶子君不仅介绍算法，还将算法与前端各个领域进行结合，包括浏览器、HTTP、V8、React、Vue源码等。")]),e._v(" "),t("p",[e._v("在这里，你可以每天学习一道大厂算法题（阿里、腾讯、百度、字节等等）或 leetcode，瓶子君都会在第二天解答哟！")]),e._v(" "),t("p",[t("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),t("p",[e._v("⬆️ "),t("strong",[e._v("扫码关注公众号「前端瓶子君」，回复「算法」即可自动加入 👍👍👍")])]),e._v(" "),t("p",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&mid=2247484298&idx=1&sn=846c8c4117fa0eb5f9a7e66c54b7ae5a&chksm=faec8752cd9b0e44326a3b532ec3e5f57498c83642211c68017dd212f1ddeca53b45b44fe42e&scene=178&cur_album_id=1342984294104662017&rd2werd=1&key=6b251770640032827c15d145b3fb42b4be42b8c0fe29a4bace1dfad3933fc7b5c44d4e18a36192539ad91625e242ec5a25eeb8edc3f1272ce1b89cd01926986bcdd7db23979837ea36d4344f7da3cb95738b281c1134d7abbe777fd58e3605b765f90ce904ed4c03544132fb8d06923787eb7caa8ea3a1d41404e0d797f4f93c&ascene=1&uin=MTE5NzkwMDQyOA%3D%3D&devicetype=iMac+MacBookPro16%2C1+OSX+OSX+10.16+build(20G95)&version=13010510&nettype=WIFI&lang=zh_CN&fontScale=100&exportkey=AVa0oS1%2FhPgXikJEJRCvabU%3D&pass_ticket=wFWGmZwhuThchaxD%2F8KCFyP5ohv32kJThs87R2RE0n8DjhSFnI501UNUy31Bvchp&wx_header=0&fontgear=3.000000",target:"_blank",rel:"noopener noreferrer"}},[e._v("》》面试官都在用的题库，点击学习《《"),t("OutboundLink")],1)]),e._v(" "),t("h3",{attrs:{id:"github地址"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#github地址"}},[e._v("#")]),e._v(" github地址")]),e._v(" "),t("p",[e._v("[1]图解leetcode88：合并两个有序数组: "),t("em",[e._v("https://github.com/sisterAn/JavaScript-Algorithms/issues/3")]),e._v("[2]字节&leetcode1：两数之和: "),t("em",[e._v("https://github.com/sisterAn/JavaScript-Algorithms/issues/4")]),e._v("[3]腾讯：数组扁平化、去重、排序: "),t("em",[e._v("https://github.com/sisterAn/JavaScript-Algorithms/issues/5")]),e._v("[4]leetcode349：给定两个数组，编写一个函数来计算它们的交集: "),t("em",[e._v("https://github.com/sisterAn/JavaScript-Algorithms/issues/6")]),e._v("[5]leetcode146：设计和实现一个LRU（最近最少使用）缓存机制: "),t("em",[e._v("https://github.com/sisterAn/JavaScript-Algorithms/issues/7")]),e._v("[6]阿里算法题：编写一个函数计算多个数组的交集: "),t("em",[e._v("https://github.com/sisterAn/JavaScript-Algorithms/issues/10")]),e._v("[7]leetcode21：合并两个有序链表: "),t("em",[e._v("https://github.com/sisterAn/JavaScript-Algorithms/issues/11")]),e._v("[8]有赞&leetcode141：判断一个单链表是否有环: "),t("em",[e._v("https://github.com/sisterAn/JavaScript-Algorithms/issues/13")]),e._v("[9]图解leetcode206：反转链表: "),t("em",[e._v("https://github.com/sisterAn/JavaScript-Algorithms/issues/14")]),e._v("[10]前端进阶算法1：如何分析、统计算法的执行效率和资源消耗？: "),t("em",[e._v("https://github.com/sisterAn/JavaScript-Algorithms/issues/1")]),e._v("[11]前端进阶算法2：从Chrome V8源码看JavaScript数组（附赠腾讯面试题）: "),t("em",[e._v("https://github.com/sisterAn/JavaScript-Algorithms/issues/2")]),e._v("[12]前端进阶算法3：从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法: "),t("em",[e._v("https://github.com/sisterAn/JavaScript-Algorithms/issues/9")]),e._v("[13]前端进阶算法4：链表原来如此简单（+leetcode刷题）: "),t("em",[e._v("https://github.com/sisterAn/JavaScript-Algorithms/issues/12")]),e._v("[14]图解leetcode88：合并两个有序数组: "),t("em",[e._v("https://github.com/sisterAn/JavaScript-Algorithms/issues/3")]),e._v("[15]字节&leetcode1：两数之和: "),t("em",[e._v("https://github.com/sisterAn/JavaScript-Algorithms/issues/4")]),e._v("[16]腾讯：数组扁平化、去重、排序: "),t("em",[e._v("https://github.com/sisterAn/JavaScript-Algorithms/issues/5")]),e._v("[17]leetcode349：给定两个数组，编写一个函数来计算它们的交集: "),t("em",[e._v("https://github.com/sisterAn/JavaScript-Algorithms/issues/6")]),e._v("[18]leetcode146：设计和实现一个LRU（最近最少使用）缓存机制: "),t("em",[e._v("https://github.com/sisterAn/JavaScript-Algorithms/issues/7")]),e._v("[19]阿里算法题：编写一个函数计算多个数组的交集: "),t("em",[e._v("https://github.com/sisterAn/JavaScript-Algorithms/issues/10")]),e._v("[20]leetcode21：合并两个有序链表: "),t("em",[e._v("https://github.com/sisterAn/JavaScript-Algorithms/issues/11")]),e._v("[21]有赞&leetcode141：判断一个单链表是否有环: "),t("em",[e._v("https://github.com/sisterAn/JavaScript-Algorithms/issues/13")]),e._v("[22]图解 leetcode206：反转链表: "),t("em",[e._v("https://github.com/sisterAn/JavaScript-Algorithms/issues/14")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qlogo.cn/mmbiz_jpg/iaUXCIgN4lOFcYSsSBnCia2E6kJJmR2Suh7a0Lm4TsmAxtmiaYRr5etvyHb7vIA6jb9kfVl2WSQBiciauzhLA50mtxg/0?wx_fmt=jpeg",alt:"作者"}})]),e._v(" "),t("p",[e._v("前端瓶子君")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&mid=2247484298&idx=1&sn=846c8c4117fa0eb5f9a7e66c54b7ae5a&chksm=faec8752cd9b0e44326a3b532ec3e5f57498c83642211c68017dd212f1ddeca53b45b44fe42e&scene=178&cur_album_id=1342984294104662017&rd2werd=1&key=6b251770640032827c15d145b3fb42b4be42b8c0fe29a4bace1dfad3933fc7b5c44d4e18a36192539ad91625e242ec5a25eeb8edc3f1272ce1b89cd01926986bcdd7db23979837ea36d4344f7da3cb95738b281c1134d7abbe777fd58e3605b765f90ce904ed4c03544132fb8d06923787eb7caa8ea3a1d41404e0d797f4f93c&ascene=1&uin=MTE5NzkwMDQyOA%3D%3D&devicetype=iMac+MacBookPro16%2C1+OSX+OSX+10.16+build(20G95)&version=13010510&nettype=WIFI&lang=zh_CN&fontScale=100&exportkey=AVa0oS1%2FhPgXikJEJRCvabU%3D&pass_ticket=wFWGmZwhuThchaxD%2F8KCFyP5ohv32kJThs87R2RE0n8DjhSFnI501UNUy31Bvchp&wx_header=0&fontgear=3.000000",alt:"赞赏二维码"}}),t("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzUzNjk5MTE1OQ==&mid=2247484298&idx=1&sn=846c8c4117fa0eb5f9a7e66c54b7ae5a&chksm=faec8752cd9b0e44326a3b532ec3e5f57498c83642211c68017dd212f1ddeca53b45b44fe42e&scene=178&cur_album_id=1342984294104662017&rd2werd=1&key=6b251770640032827c15d145b3fb42b4be42b8c0fe29a4bace1dfad3933fc7b5c44d4e18a36192539ad91625e242ec5a25eeb8edc3f1272ce1b89cd01926986bcdd7db23979837ea36d4344f7da3cb95738b281c1134d7abbe777fd58e3605b765f90ce904ed4c03544132fb8d06923787eb7caa8ea3a1d41404e0d797f4f93c&ascene=1&uin=MTE5NzkwMDQyOA%3D%3D&devicetype=iMac+MacBookPro16%2C1+OSX+OSX+10.16+build(20G95)&version=13010510&nettype=WIFI&lang=zh_CN&fontScale=100&exportkey=AVa0oS1%2FhPgXikJEJRCvabU%3D&pass_ticket=wFWGmZwhuThchaxD%2F8KCFyP5ohv32kJThs87R2RE0n8DjhSFnI501UNUy31Bvchp&wx_header=0&fontgear=3.000000##",target:"_blank",rel:"noopener noreferrer"}},[e._v("喜欢作者"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("1 人喜欢")]),e._v(" "),t("p",[t("img",{attrs:{src:"http://wx.qlogo.cn/mmhead/zULCKyBNbgbKjaMkWQU9TDibJ5u6baic5O3ia4D2PSwT94/132",alt:"img"}})]),e._v(" "),t("p",[e._v("阅读 2488")]),e._v(" "),t("p",[e._v("赞3在看16")])])}),[],!1,null,null,null);t.default=v.exports}}]);