(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{321:function(e,t,a){"use strict";a.r(t);var n=a(4),s=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"前端进阶算法2-从chrome-v8源码看javascript数组-附赠腾讯面试题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端进阶算法2-从chrome-v8源码看javascript数组-附赠腾讯面试题"}},[e._v("#")]),e._v(" 前端进阶算法2：从Chrome V8源码看JavaScript数组(附赠腾讯面试题)")]),e._v(" "),t("p",[e._v("原创 前端瓶子君 前端瓶子君 "),t("em",[e._v("2020-04-02")])]),e._v(" "),t("h3",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[e._v("#")]),e._v(" 简介")]),e._v(" "),t("p",[e._v("数组、链表、栈、队列都是线性表，它表示的结构都是一段线性的结构，与之对应的就是非线性表，例如树、图、堆等，它表示的结构都非线性。")]),e._v(" "),t("p",[e._v("本节主要介绍 JavaScript 数组，在开始本章节前，思考一个问题：")]),e._v(" "),t("p",[e._v("我们知道在 JavaScript 中，可以在数组中保存不同类型值，并且数组可以动态增长，不像其它语言，例如 C，创建的时候要决定数组的大小，如果数组满了，就要重新申请内存空间。这是为什么喃？")]),e._v(" "),t("p",[e._v("本节从 Chrome v8 源码角度回答这个问题，分为四个方面：")]),e._v(" "),t("ul",[t("li",[e._v("数组基础入门")]),e._v(" "),t("li",[e._v("JavaScript 中，数组为什么可以保存不同类型？")]),e._v(" "),t("li",[e._v("JavaScript 中，数组是如何存储的喃？")]),e._v(" "),t("li",[e._v("JavaScript 中，数组的动态扩容与减容（ "),t("code",[e._v("FastElements")]),e._v(" ）")])]),e._v(" "),t("p",[e._v("下面进入正题吧！（文末有惊喜）😊")]),e._v(" "),t("p",[e._v("想要更多更快的学习本系列，可以关注公众号「前端瓶子君」和我的「Github：https://github.com/sisterAn/JavaScript-Algorithms」")]),e._v(" "),t("h3",{attrs:{id:"一、数组-基础"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、数组-基础"}},[e._v("#")]),e._v(" 一、数组（基础）")]),e._v(" "),t("p",[e._v("一种最基础的数据结构，每种编程语言都有，它编号从 0 开始，代表一组连续的储存结构，用来储存同一种类型的数据。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let arr = [1, 2, 3]\n")])])]),t("p",[e._v("它的这种特定的存储结构（连续存储空间存储同一类型数据）决定了：")]),e._v(" "),t("p",[t("strong",[e._v("优点")])]),e._v(" "),t("ul",[t("li",[e._v("随机访问：可以通过下标随机访问数组中的任意位置上的数据")])]),e._v(" "),t("p",[t("strong",[e._v("缺点")])]),e._v(" "),t("ul",[t("li",[e._v("对数据的删除和插入不是很友好")])]),e._v(" "),t("p",[t("strong",[e._v("查找：")]),e._v(" 根据下标随机访问的时间复杂度为 O(1)；")]),e._v(" "),t("p",[t("strong",[e._v("插入或删除：")]),e._v(" 时间复杂度为 O(n)；")]),e._v(" "),t("p",[e._v("在 JavaScript 中的数组几乎是万能的，它不光可以作为一个普通的数组使用，可以作为栈或队列使用。")]),e._v(" "),t("p",[e._v("数组：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let array = [1, 2, 3]\n")])])]),t("p",[e._v("栈：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let stack = [1, 2, 3]\n// 进栈\nstack.push(4)\n// 出栈\nstcak.pop()\n")])])]),t("p",[e._v("队列：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let queue = [1, 2, 3]\n// 进队\nqueue.push(4)\n// 出队\nqueue.shift()\n")])])]),t("h3",{attrs:{id:"二、javascript-中-数组可以保存不同类型值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、javascript-中-数组可以保存不同类型值"}},[e._v("#")]),e._v(" 二、JavaScript 中，数组可以保存不同类型值")]),e._v(" "),t("p",[e._v("看一下 Chrome v8 源码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// The JSArray describes JavaScript Arrays\n//  Such an array can be in one of two modes:\n//    - fast, backing storage is a FixedArray and length <= elements.length();\n//       Please note: push and pop can be used to grow and shrink the array.\n//    - slow, backing storage is a HashTable with numbers as keys.\nclass JSArray: public JSObject {\n public:\n  // [length]: The length property.\n  DECL_ACCESSORS(length, Object)\n    \n  // ...\n   \n  // Number of element slots to pre-allocate for an empty array.\n  static const int kPreallocatedArrayElements = 4;\n};\n")])])]),t("p",[e._v("我们可以看到 "),t("code",[e._v("JSArray")]),e._v(" 是继承自 "),t("code",[e._v("JSObject")]),e._v(" 的，所以在 JavaScript 中，数组可以是一个特殊的对象，内部也是以 key-value 形式存储数据，所以 JavaScript 中的数组可以存放不同类型的值。")]),e._v(" "),t("h3",{attrs:{id:"三、javascript-中-数组的存储"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、javascript-中-数组的存储"}},[e._v("#")]),e._v(" 三、JavaScript 中，数组的存储")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// The JSArray describes JavaScript Arrays\n//  Such an array can be in one of two modes:\n//    - fast, backing storage is a FixedArray and length <= elements.length();\n//       Please note: push and pop can be used to grow and shrink the array.\n//    - slow, backing storage is a HashTable with numbers as keys.\nclass JSArray: public JSObject {\n public:\n  // [length]: The length property.\n  DECL_ACCESSORS(length, Object)\n    \n  // ...\n   \n  // Number of element slots to pre-allocate for an empty array.\n  static const int kPreallocatedArrayElements = 4;\n};\n")])])]),t("p",[t("code",[e._v("JSArray")]),e._v(" 继承于 "),t("code",[e._v("JSObject")]),e._v(" ，从注释上看，它有两种存储方式：")]),e._v(" "),t("ul",[t("li",[e._v("fast：存储结构是 "),t("code",[e._v("FixedArray")]),e._v(" ，并且数组长度 "),t("code",[e._v("<= elements.length()")]),e._v(" ，"),t("code",[e._v("push")]),e._v(" 或 "),t("code",[e._v("pop")]),e._v(" 时可能会伴随着动态扩容或减容")]),e._v(" "),t("li",[e._v("slow：存储结构是 "),t("code",[e._v("HashTable")]),e._v("（哈希表），并且数组下标作为 "),t("code",[e._v("key")])])]),e._v(" "),t("p",[t("code",[e._v("fast")]),e._v(" 模式下数组在源码里面叫 "),t("code",[e._v("FastElements")]),e._v(" ，而 "),t("code",[e._v("slow")]),e._v(" 模式下的叫做 "),t("code",[e._v("SlowElements")]),e._v(" 。")]),e._v(" "),t("h4",{attrs:{id:"_1-快数组-fastelements"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-快数组-fastelements"}},[e._v("#")]),e._v(" 1. 快数组（FastElements）")]),e._v(" "),t("p",[t("code",[e._v("FixedArray")]),e._v(" 是 V8 实现的一个类似于数组的类，它表示一段连续的内存，可以使用索引直接定位。新创建的空数组默认就是快数组。当数组满（数组的长度达到数组在内存中申请的内存容量最大值）的时候，继续 "),t("code",[e._v("push")]),e._v(" 时， "),t("code",[e._v("JSArray")]),e._v(" 会进行动态的扩容，以存储更多的元素。")]),e._v(" "),t("h4",{attrs:{id:"_2-慢数组-slowelements"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-慢数组-slowelements"}},[e._v("#")]),e._v(" 2. 慢数组（SlowElements）")]),e._v(" "),t("p",[e._v("慢数组以哈希表的形式存储在内存空间里，它不需要开辟连续的存储空间，但需要额外维护一个哈希表，与快数组相比，性能相对较差。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// src/objects/dictionary.h\nclass EXPORT_TEMPLATE_DECLARE(V8_EXPORT_PRIVATE) Dictionary\n    : public HashTable<Derived, Shape> {\n  using DerivedHashTable = HashTable<Derived, Shape>;\n\n public:\n  using Key = typename Shape::Key;\n  // Returns the value at entry.\n  inline Object ValueAt(InternalIndex entry);\n  inline Object ValueAt(const Isolate* isolate, InternalIndex entry);\n  \n  // ...\n};\n")])])]),t("p",[e._v("从源码中可以看出，它的内部就是一个 HashTable。")]),e._v(" "),t("h4",{attrs:{id:"_3-什么时候会从-fast-转变为-slow-喃"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-什么时候会从-fast-转变为-slow-喃"}},[e._v("#")]),e._v(" 3. 什么时候会从 fast 转变为 slow 喃？")]),e._v(" "),t("p",[e._v("从 Chrome V8 源码上看，")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// src/objects/js-objects.h\nstatic const uint32_t kMaxGap = 1024;\n\n// src/objects/dictionary.h\n// JSObjects prefer dictionary elements if the dictionary saves this much\n// memory compared to a fast elements backing store.\nstatic const uint32_t kPreferFastElementsSizeFactor = 3;\n\n// src/objects/js-objects-inl.h\n// If the fast-case backing storage takes up much more memory than a dictionary\n// backing storage would, the object should have slow elements.\n// static\nstatic inline bool ShouldConvertToSlowElements(uint32_t used_elements,\n                                               uint32_t new_capacity) {\n  uint32_t size_threshold = NumberDictionary::kPreferFastElementsSizeFactor *\n                            NumberDictionary::ComputeCapacity(used_elements) *\n                            NumberDictionary::kEntrySize;\n  // 快数组新容量是扩容后的容量3倍之多时，也会被转成慢数组\n  return size_threshold <= new_capacity;\n}\n\nstatic inline bool ShouldConvertToSlowElements(JSObject object,\n                                               uint32_t capacity,\n                                               uint32_t index,\n                                               uint32_t* new_capacity) {\n  STATIC_ASSERT(JSObject::kMaxUncheckedOldFastElementsLength <=\n                JSObject::kMaxUncheckedFastElementsLength);\n  if (index < capacity) {\n    *new_capacity = capacity;\n    return false;\n  }\n  // 当加入的索引值（例如例3中的2000）比当前容量capacity 大于等于 1024时，\n  // 返回true，转为慢数组\n  if (index - capacity >= JSObject::kMaxGap) return true;\n  *new_capacity = JSObject::NewElementsCapacity(index + 1);\n  DCHECK_LT(index, *new_capacity);\n  // TODO(ulan): Check if it works with young large objects.\n  if (*new_capacity <= JSObject::kMaxUncheckedOldFastElementsLength ||\n      (*new_capacity <= JSObject::kMaxUncheckedFastElementsLength &&\n       ObjectInYoungGeneration(object))) {\n    return false;\n  }\n  return ShouldConvertToSlowElements(object.GetFastElementsUsage(),\n                                     *new_capacity);\n}\n")])])]),t("p",[e._v("所以，当处于以下情况时，快数组会被转变为慢数组：")]),e._v(" "),t("ul",[t("li",[e._v("当加入的索引值 index 比当前容量 capacity 差值大于等于 1024 时（index - capacity >= 1024）")]),e._v(" "),t("li",[e._v("快数组新容量是扩容后的容量 3 倍之多时")])]),e._v(" "),t("p",[e._v("例如：向快数组里增加一个大索引同类型值")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var arr = [1, 2, 3]\narr[2000] = 10;\n")])])]),t("p",[e._v("当往 "),t("code",[e._v("arr")]),e._v(" 增加一个 "),t("code",[e._v("2000")]),e._v(" 的索引时，"),t("code",[e._v("arr")]),e._v(" 被转成慢数组。节省了大量的内存空间（从索引为 2 到索引为 2000）。")]),e._v(" "),t("h4",{attrs:{id:"_4-什么时候会从-slow-转变为-fast-喃"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-什么时候会从-slow-转变为-fast-喃"}},[e._v("#")]),e._v(" 4. 什么时候会从 slow 转变为 fast 喃？")]),e._v(" "),t("p",[e._v("我们已经知道在什么时候会出现由快变慢，那由慢变快就很简单了")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("static bool ShouldConvertToFastElements(JSObject object,\n                                        NumberDictionary dictionary,\n                                        uint32_t index,\n                                        uint32_t* new_capacity) {\n  // If properties with non-standard attributes or accessors were added, we\n  // cannot go back to fast elements.\n  if (dictionary.requires_slow_elements()) return false;\n  // Adding a property with this index will require slow elements.\n  if (index >= static_cast<uint32_t>(Smi::kMaxValue)) return false;\n  if (object.IsJSArray()) {\n    Object length = JSArray::cast(object).length();\n    if (!length.IsSmi()) return false;\n    *new_capacity = static_cast<uint32_t>(Smi::ToInt(length));\n  } else if (object.IsJSArgumentsObject()) {\n    return false;\n  } else {\n    *new_capacity = dictionary.max_number_key() + 1;\n  }\n  *new_capacity = Max(index + 1, *new_capacity);\n  uint32_t dictionary_size = static_cast<uint32_t>(dictionary.Capacity()) *\n                             NumberDictionary::kEntrySize;\n  // Turn fast if the dictionary only saves 50% space.\n  return 2 * dictionary_size >= *new_capacity;\n}\n")])])]),t("p",[e._v("当慢数组的元素可存放在快数组中且长度在 smi 之间且仅节省了50%的空间，则会转变为快数组")]),e._v(" "),t("h3",{attrs:{id:"四、javascript-中-数组的动态扩容与减容-fastelements"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四、javascript-中-数组的动态扩容与减容-fastelements"}},[e._v("#")]),e._v(" 四、JavaScript 中，数组的动态扩容与减容（FastElements）")]),e._v(" "),t("p",[e._v("默认空数组初始化大小为 "),t("code",[e._v("4")]),e._v(" :")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// Number of element slots to pre-allocate for an empty array.\nstatic const int kPreallocatedArrayElements = 4;\n")])])]),t("p",[e._v("在 JavaScript 中，当数组执行 "),t("code",[e._v("push")]),e._v(" 操作时，一旦发现数组内存不足，将进行扩容。")]),e._v(" "),t("p",[e._v("在 Chrome 源码中， "),t("code",[e._v("push")]),e._v(" 的操作是用汇编实现的，在 c++ 里嵌入的汇编，以提高执行效率，并且在汇编的基础上用 c++ 封装了一层，在编译执行的时候，会将这些 c++ 代码转成汇编代码。")]),e._v(" "),t("p",[e._v("计算新容量的函数：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// js-objects.h\nstatic const uint32_t kMinAddedElementsCapacity = 16;\n\n// code-stub-assembler.cc\nNode* CodeStubAssembler::CalculateNewElementsCapacity(Node* old_capacity,\n                                                      ParameterMode mode) {\n  CSA_SLOW_ASSERT(this, MatchesParameterMode(old_capacity, mode));\n  Node* half_old_capacity = WordOrSmiShr(old_capacity, 1, mode);\n  Node* new_capacity = IntPtrOrSmiAdd(half_old_capacity, old_capacity, mode);\n  Node* padding =\n      IntPtrOrSmiConstant(JSObject::kMinAddedElementsCapacity, mode);\n  return IntPtrOrSmiAdd(new_capacity, padding, mode);\n}\n")])])]),t("p",[e._v("所以扩容后新容量计公式为：")]),e._v(" "),t("blockquote",[t("p",[e._v("new_capacity = old_capacity /2 + old_capacity + 16")])]),e._v(" "),t("p",[e._v("即老的容量的 1.5 倍加上 16 。初始化为 4 个，当 "),t("code",[e._v("push")]),e._v(" 第 5 个的时候，容量将会变成：")]),e._v(" "),t("blockquote",[t("p",[e._v("new_capacity = 4 / 2 + 4 + 16 = 22")])]),e._v(" "),t("p",[e._v("接着申请一块这么大的内存，把老的数据拷过去，把新元素放在当前 length 位置，然后将数组的 length + 1，并返回 length。")]),e._v(" "),t("p",[e._v("所以，扩容可以分为以下几步：")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("push")]),e._v(" 操作时，发现数组内存不足")]),e._v(" "),t("li",[e._v("申请 new_capacity = old_capacity /2 + old_capacity + 16 那么长度的内存空间")]),e._v(" "),t("li",[e._v("将数组拷贝到新内存中")]),e._v(" "),t("li",[e._v("把新元素放在当前 length 位置")]),e._v(" "),t("li",[e._v("数组的 length + 1")]),e._v(" "),t("li",[e._v("返回 length")])]),e._v(" "),t("p",[e._v("整个过程，用户是无感知的，不像 C，需用用户手动申请内存空间。")]),e._v(" "),t("p",[e._v("当数组执行 "),t("code",[e._v("pop")]),e._v(" 操作时，会判断 "),t("code",[e._v("pop")]),e._v(" 后数组的容量，是否需要进行减容。")]),e._v(" "),t("p",[e._v("不同于数组的 "),t("code",[e._v("push")]),e._v(" 使用汇编实现的， "),t("code",[e._v("pop")]),e._v(" 使用 c++ 实现的。")]),e._v(" "),t("p",[e._v("判断是否进行减容：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("if (2 * length <= capacity) {\n  // If more than half the elements won't be used, trim the array.\n  isolate->heap()->RightTrimFixedArray(*backing_store, capacity - length);\n} else {\n  // Otherwise, fill the unused tail with holes.\n  BackingStore::cast(*backing_store)->FillWithHoles(length, old_length);\n}\n")])])]),t("p",[e._v("所以，当数组 "),t("code",[e._v("pop")]),e._v(" 后，如果数组容量大于等于 length 的 2 倍，则进行容量调整，使用 "),t("code",[e._v("RightTrimFixedArray")]),e._v(" 函数，计算出需要释放的空间大小，做好标记，等待 GC 回收；如果数组容量小于 length 的 2 倍，则用 holes 对象填充。")]),e._v(" "),t("p",[e._v("所以，减容可以分为以下几步：")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("pop")]),e._v(" 操作时，获取数组 "),t("code",[e._v("length")])]),e._v(" "),t("li",[e._v("获取 "),t("code",[e._v("length - 1")]),e._v(" 上的元素（要删除的元素）")]),e._v(" "),t("li",[e._v("数组 "),t("code",[e._v("length - 1")])]),e._v(" "),t("li",[e._v("判断数组的总容量是否大于等于 length - 1 的 2 倍")]),e._v(" "),t("li",[e._v("是的话，使用 "),t("code",[e._v("RightTrimFixedArray")]),e._v(" 函数，计算出需要释放的空间大小，并做好标记，等待 "),t("code",[e._v("GC")]),e._v(" 回收")]),e._v(" "),t("li",[e._v("不是的话，用 "),t("code",[e._v("holes")]),e._v(" 对象填充")]),e._v(" "),t("li",[e._v("返回要删除的元素")])]),e._v(" "),t("h3",{attrs:{id:"五、解答开篇问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#五、解答开篇问题"}},[e._v("#")]),e._v(" 五、解答开篇问题")]),e._v(" "),t("p",[e._v("JavaScript 中， "),t("code",[e._v("JSArray")]),e._v(" 继承自 "),t("code",[e._v("JSObject")]),e._v(" ，或者说它就是一个特殊的对象，内部是以 key-value 形式存储数据，所以 JavaScript 中的数组可以存放不同类型的值。它有两种存储方式，快数组与慢数组，初始化空数组时，使用快数组，快数组使用连续的内存空间，当数组长度达到最大时，"),t("code",[e._v("JSArray")]),e._v(" 会进行动态的扩容，以存储更多的元素，相对慢数组，性能要好得多。当数组中 "),t("code",[e._v("hole")]),e._v(" 太多时，会转变成慢数组，即以哈希表的方式（ key-value 的形式）存储数据，以节省内存空间。")]),e._v(" "),t("h3",{attrs:{id:"六、最后附赠一道前端面试题-腾讯-数组扁平化、去重、排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#六、最后附赠一道前端面试题-腾讯-数组扁平化、去重、排序"}},[e._v("#")]),e._v(" 六、最后附赠一道前端面试题（腾讯）：数组扁平化、去重、排序")]),e._v(" "),t("p",[e._v("关于 "),t("code",[e._v("Array")]),e._v(" 的属性、方法这里不再做介绍，详看 MDN Array 。")]),e._v(" "),t("p",[e._v("面试题：")]),e._v(" "),t("blockquote",[t("p",[e._v("已知如下数组：var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];")]),e._v(" "),t("p",[e._v("编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组")])]),e._v(" "),t("p",[e._v("答案：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]\n// 扁平化\nlet flatArr = arr.flat(4)\n// 去重\nlet disArr = Array.from(new Set(flatArr))\n// 排序\nlet result = disArr.sort(function(a, b) {\n    return a-b\n})\nconsole.log(result)\n// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n")])])]),t("p",[e._v("关于 Set 请查阅 Set、WeakSet、Map及WeakMap")]),e._v(" "),t("p",[e._v("参考链接：")]),e._v(" "),t("p",[e._v("探究JS V8引擎下的“数组”底层实现")]),e._v(" "),t("p",[e._v("从Chrome源码看JS Array的实现")]),e._v(" "),t("h3",{attrs:{id:"七、认识更多的前端道友-一起进阶前端开发"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#七、认识更多的前端道友-一起进阶前端开发"}},[e._v("#")]),e._v(" 七、认识更多的前端道友，一起进阶前端开发")]),e._v(" "),t("p",[e._v("前端算法集训营第一期开营啦🎉🎉🎉")]),e._v(" "),t("p",[e._v("在这里，你可以和志同道合的前端朋友们一起进阶前端算法，从0到1构建完整的数据结构与算法体系。")]),e._v(" "),t("p",[e._v("扫码加入【前端算法交流群交流群")])])}),[],!1,null,null,null);t.default=s.exports}}]);